<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@stratix/utils](./utils.md) &gt; [async](./utils.async.md)

## async namespace

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[asyncify(fn)](./utils.async.asyncify.md)


</td><td>

将同步函数转换为异步函数（返回Promise）

此函数将一个同步函数包装为返回Promise的异步函数， 使其可以在异步上下文（如async/await）中使用。 如果原函数抛出异常，Promise将被拒绝。

与promisify的区别：promisify用于转换Node.js风格的回调函数(error-first callbacks)， 而asyncify用于转换普通的同步函数。


</td></tr>
<tr><td>

[debounce(func, wait, options)](./utils.async.debounce.md)


</td><td>

创建防抖函数，限制函数调用频率

防抖函数会延迟执行，如果在延迟时间内再次调用，则重新计时。 可选择是否在延迟开始前立即执行一次（leading）以及在延迟结束后执行（trailing）。


</td></tr>
<tr><td>

[limitConcurrency(fn, maxConcurrent)](./utils.async.limitconcurrency.md)


</td><td>

限制异步函数的并发执行数量

此函数接收一个异步函数和最大并发数，返回一个新函数，调用新函数时如果 当前活跃的调用数已达到最大并发数，则会将新的调用放入队列等待，直到有 调用完成后才会执行队列中等待的调用。


</td></tr>
<tr><td>

[parallelLimit(tasks, limit)](./utils.async.parallellimit.md)


</td><td>

并行执行异步任务，同时限制最大并发数

此函数接收一个异步任务数组，并控制同时执行的任务数量。当任务数量超过 指定的并发限制时，将等待部分任务完成后再执行新任务。返回的结果顺序与输入任务顺序一致。


</td></tr>
<tr><td>

[pMap(array, mapper, options)](./utils.async.pmap.md)


</td><td>

将数组中的每个项目映射到异步函数，并控制并发执行数量

类似于Array.prototype.map，但用于处理异步映射函数，并可以限制并发执行的数量。 当数据量大或每个操作消耗资源较多时，控制并发数可以避免资源耗尽。


</td></tr>
<tr><td>

[promisify(fn)](./utils.async.promisify.md)


</td><td>

将Node.js风格的回调函数转换为返回Promise的函数

此函数将遵循Node.js回调模式的函数（最后一个参数为(err, result) =<!-- -->&gt; {<!-- -->}<!-- -->） 转换为返回Promise的函数，使其可以与async/await一起使用。


</td></tr>
<tr><td>

[promisifyAll(target, methods)](./utils.async.promisifyall.md)


</td><td>

将对象的多个回调风格函数转换为Promise风格

此函数遍历对象的指定方法（或全部方法），将每个回调风格的方法转换为 返回Promise的方法，并添加Async后缀。原始方法保持不变。


</td></tr>
<tr><td>

[queue(worker, concurrency)](./utils.async.queue.md)


</td><td>

创建一个队列，用于管理并发异步任务

此函数创建一个任务队列，可以添加异步任务并控制同时执行的任务数量。 当任务添加到队列中后，会在资源可用时自动开始执行。可以暂停和恢复队列， 以及等待队列中所有任务完成。


</td></tr>
<tr><td>

[retry(fn, options)](./utils.async.retry.md)


</td><td>

重试执行异步函数，在失败时自动重新尝试

此函数在执行异步操作失败时提供自动重试能力，适用于网络请求、 数据库操作等可能因暂时性故障而失败的场景。


</td></tr>
<tr><td>

[sleep(ms)](./utils.async.sleep.md)


</td><td>

异步延迟函数，创建一个在指定时间后解析的Promise

此函数使用Promise和setTimeout实现异步延迟，可用于暂停异步函数执行， 实现轮询间隔，或在操作之间添加延迟。


</td></tr>
<tr><td>

[throttle(func, wait, options)](./utils.async.throttle.md)


</td><td>

创建节流函数，限制函数调用频率

节流函数确保函数在一段时间内最多执行一次，无论调用多少次。 可选择是否在节流开始前立即执行一次（leading）以及在节流结束后执行（trailing）。


</td></tr>
<tr><td>

[timeout(ms, message)](./utils.async.timeout.md)


</td><td>

创建一个在指定时间后拒绝的Promise

此函数创建一个Promise，它会在指定的毫秒数后自动拒绝， 可用于实现超时控制和竞态条件处理。


</td></tr>
<tr><td>

[waterfall(tasks)](./utils.async.waterfall.md)


</td><td>

按顺序执行异步函数，每个函数的结果作为下一个函数的输入

此函数接收一个异步函数数组，并按顺序执行它们。第一个函数不接收参数， 后续每个函数都接收前一个函数的返回值作为参数。整个流程的结果是最后一个 函数的返回值。如果任何一个函数抛出异常，整个流程会立即中断并抛出该异常。


</td></tr>
<tr><td>

[withTimeout(promise, ms, message)](./utils.async.withtimeout.md)


</td><td>

为Promise添加超时控制，如果原Promise未在指定时间内完成则拒绝

此函数使用Promise.race将原始Promise与一个超时Promise竞争， 如果超时Promise先完成，则返回超时错误。


</td></tr>
</tbody></table>

## Interfaces

<table><thead><tr><th>

Interface


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[DebounceOptions](./utils.async.debounceoptions.md)


</td><td>

防抖选项接口，配置防抖行为


</td></tr>
<tr><td>

[PMapOptions](./utils.async.pmapoptions.md)


</td><td>

并发映射选项接口，配置映射的并发行为


</td></tr>
<tr><td>

[Queue](./utils.async.queue.md)


</td><td>

任务队列接口

定义了异步任务队列的公共方法和属性。


</td></tr>
<tr><td>

[RetryOptions](./utils.async.retryoptions.md)


</td><td>

重试选项接口，配置重试行为


</td></tr>
<tr><td>

[ThrottleOptions](./utils.async.throttleoptions.md)


</td><td>

节流选项接口，配置节流行为


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[PromisifiedObject](./utils.async.promisifiedobject.md)


</td><td>

表示经过Promise化处理的对象类型

将对象中的回调式方法转换为返回Promise的方法，并添加Async后缀


</td></tr>
</tbody></table>
