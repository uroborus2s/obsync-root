# 学生签到接口修复总结

## 修复时间
2025-10-21

## 修复范围
app-icalink 中的学生签到功能（checkin 接口）

---

## 一、修复内容概览

### 1. 更新 CheckinRequest 类型定义
**文件**：`apps/app-icalink/src/types/api.ts`

**修改内容**：
```typescript
export interface CheckinRequest {
  location?: string;
  latitude?: number;
  longitude?: number;
  accuracy?: number;
  remark?: string;
  // 新增字段 - 用于优化签到性能
  course_start_time: string;        // 课程开始时间（ISO 8601格式）
  window_id?: string;                // 窗口ID（窗口期签到时必填）
  window_open_time?: string;         // 窗口开启时间（ISO 8601格式）
  window_close_time?: string;        // 窗口关闭时间（ISO 8601格式）
}
```

**目的**：
- 支持前端传递时间参数，减少后端查询
- 支持窗口期签到功能

---

### 2. 优化 checkin() 方法
**文件**：`apps/app-icalink/src/services/AttendanceService.ts`

#### 2.1 移除高频校验（性能优化）
**移除的校验**：
- ❌ 课程存在性校验（`attendanceCourseRepository.findOne`）
- ❌ 选课关系校验（`courseStudentRepository.findOne`）

**保留的校验**：
- ✅ 用户身份验证（确保是学生）
- ✅ 时间窗口验证

**原因**：
- 签到是高频请求，每次都查询数据库会影响性能
- 这些校验可以在队列处理时异步进行

#### 2.2 修改时间验证逻辑
**新逻辑**：
```typescript
// 判断是否为窗口期签到
if (checkinData.window_id && checkinData.window_open_time && checkinData.window_close_time) {
  // 窗口期签到：检查当前时间是否在窗口时间范围内
  const windowOpenTime = new Date(checkinData.window_open_time);
  const windowCloseTime = new Date(checkinData.window_close_time);
  
  if (now >= windowOpenTime && now <= windowCloseTime) {
    canCheckin = true;
    isWindowCheckin = true;
  }
} else {
  // 正常签到：检查当前时间是否在课程开始前10分钟至课程开始后10分钟内
  const selfCheckinStart = new Date(courseStartTime.getTime() - 10 * 60 * 1000);
  const selfCheckinEnd = new Date(courseStartTime.getTime() + 10 * 60 * 1000);
  
  if (now >= selfCheckinStart && now <= selfCheckinEnd) {
    canCheckin = true;
    isWindowCheckin = false;
  }
}
```

**优势**：
- 使用前端传递的时间参数，避免查询数据库
- 清晰区分正常签到和窗口期签到

#### 2.3 添加幂等性判断
**实现方式**：
```typescript
// 使用 BullMQ 的 jobId 实现幂等性
const jobId = `checkin_${courseExtId}_${studentInfo.userId}_${now.toISOString().split('T')[0]}`;

// 检查是否已存在相同的任务
const existingJob = await this.queueClient.getJob('checkin', jobId);
if (existingJob) {
  return right({
    status: 'queued',
    message: '签到请求已在处理中'
  });
}

// 添加任务时使用 jobId
await this.queueClient.add('checkin', data, { jobId });
```

**原理**：
- BullMQ 原生支持通过 jobId 去重
- 相同 jobId 的任务只会被处理一次
- jobId 格式：`checkin_{courseExtId}_{studentId}_{date}`

#### 2.4 记录签到时间
**关键点**：
```typescript
// 记录签到时间（用户点击签到按钮的时间）
const checkinTime = now;

// 将签到时间传递给队列任务
await this.queueClient.add('checkin', {
  courseExtId,
  studentInfo,
  checkinData,
  checkinTime: checkinTime.toISOString(), // 传递签到时间
  isWindowCheckin
}, { jobId });
```

**重要**：
- `checkin_time` 字段记录的是用户点击签到按钮的时间（加入队列的时间）
- 而不是队列处理的时间
- 这样才能准确判断是否迟到

---

### 3. 在 onReady() 中注册消息队列 Worker
**文件**：`apps/app-icalink/src/services/AttendanceService.ts`

**修改内容**：
```typescript
onReady() {
  // 注册签到队列 Worker
  this.logger.info('Registering checkin queue worker...');
  this.queueClient.process('checkin', async (job) => {
    return await this.processCheckinJob(job.data);
  });
  this.logger.info('✅ Checkin queue worker registered successfully');
}
```

**说明**：
- 在 Service 的 `onReady()` 生命周期方法中注册 Worker
- Worker 监听 'checkin' 队列
- 调用 `processCheckinJob()` 方法处理签到任务

---

### 4. 实现 processCheckinJob() 方法
**文件**：`apps/app-icalink/src/services/AttendanceService.ts`

#### 4.1 方法签名
```typescript
private async processCheckinJob(data: any): Promise<any>
```

#### 4.2 处理流程
```
1. 查询课程信息（在队列中异步校验）
   ↓
2. 验证选课关系（在队列中异步校验）
   ↓
3. 查询学生信息（获取班级、专业等信息）
   ↓
4. 查询或创建签到记录
   ↓
5. 判断迟到状态
   ↓
6. 准备签到数据
   ↓
7. 处理窗口期签到的特殊逻辑
   ↓
8. 写入签到数据到数据库
```

#### 4.3 迟到判断逻辑
```typescript
// 使用队列任务中的 checkinTime（用户点击签到的时间）
const checkinDateTime = new Date(checkinTime);
const courseStartTime = new Date(course.start_time);
const isLate = checkinDateTime > courseStartTime;
const lateMinutes = isLate
  ? Math.floor((checkinDateTime.getTime() - courseStartTime.getTime()) / (1000 * 60))
  : 0;
```

#### 4.4 窗口期签到处理
```typescript
if (isWindowCheckin && checkinData.window_id) {
  // 查询窗口信息
  const window = await this.verificationWindowRepository.findByWindowId(
    checkinData.window_id
  );

  if (window) {
    // 窗口期签到：更新窗口相关字段
    checkinRecordData.window_id = checkinData.window_id;
    checkinRecordData.last_checkin_source = 'window';
    
    // 注意：以下字段在当前数据库表结构中不存在，需要先添加
    // checkinRecordData.verification_status = 'verified';
    // checkinRecordData.verification_round = window.verification_round;
    // checkinRecordData.last_verification_time = new Date();
  } else {
    checkinRecordData.last_checkin_source = 'regular';
  }
} else {
  // 正常签到
  checkinRecordData.last_checkin_source = 'regular';
}
```

#### 4.5 数据库写入
```typescript
if (isNone(attendanceRecord)) {
  // 创建新记录
  const newRecord = {
    attendance_course_id: course.id,
    student_id: studentInfo.userId,
    student_name: studentData?.xm || studentInfo.userName || '',
    class_name: studentData?.bjmc || '',
    major_name: studentData?.zymc || '',
    ...checkinRecordData,
    created_by: studentInfo.userId
  };

  await this.attendanceRecordRepository.create(newRecord);
} else {
  // 更新现有记录 - 使用 updateMany 方法
  await this.attendanceRecordRepository.updateMany(
    (qb: any) =>
      qb
        .where('attendance_course_id', '=', course.id)
        .where('student_id', '=', studentInfo.userId),
    checkinRecordData
  );
}
```

---

## 二、技术要点

### 1. BullMQ 幂等性机制
- BullMQ 原生支持通过 `jobId` 实现幂等性
- 相同 `jobId` 的任务只会被添加一次
- 如果任务已存在，`add()` 方法会返回现有任务

### 2. 签到时间记录
- `checkin_time` 字段记录的是用户点击签到按钮的时间
- 在加入队列时记录当前时间，并传递给队列任务
- 队列处理时使用传递的时间，而不是处理时的当前时间

### 3. 窗口期签到判断
- 根据 `window_id`、`window_open_time`、`window_close_time` 的存在性判断
- 如果三个字段都存在，则为窗口期签到
- 否则为正常签到

### 4. 数据库操作
- 创建记录：使用 `create()` 方法
- 更新记录：使用 `updateMany()` 方法（支持条件查询）
- 不使用 `update(id, data)` 方法，因为需要通过复合条件查询

---

## 三、待完成事项

### 1. 数据库字段缺失 ⚠️
**缺少的字段**：
- `verification_status`：验证状态（'pending' | 'verified' | 'failed'）
- `verification_round`：验证轮次
- `last_verification_time`：最后验证时间

**影响**：
- 窗口期签到的验证状态无法记录
- 无法追踪验证轮次
- 无法记录最后验证时间

**解决方案**：
1. 创建数据库迁移脚本，添加这些字段
2. 更新 `IcalinkAttendanceRecord` 类型定义
3. 更新 `AttendanceRecordRepository` 的 Schema 定义
4. 在 `processCheckinJob()` 中启用相关代码

### 2. 前端适配
**需要前端配合**：
1. 在签到请求中传递 `course_start_time` 参数（必填）
2. 如果是窗口期签到，传递 `window_id`、`window_open_time`、`window_close_time` 参数
3. 确保时间格式为 ISO 8601 格式（例如：`2025-10-21T10:00:00.000Z`）

---

## 四、性能优化效果

### 优化前
```
签到请求 → 查询课程 → 查询选课关系 → 查询验证窗口 → 时间验证 → 加入队列
```
- 每次签到需要 3 次数据库查询
- 高并发时数据库压力大

### 优化后
```
签到请求 → 时间验证（使用前端参数）→ 幂等性检查 → 加入队列
```
- 签到接口只需要 1 次 Redis 查询（幂等性检查）
- 数据库查询移到队列处理中异步执行
- 大幅降低数据库压力

---

## 五、测试建议

### 1. 正常签到测试
- 在课程开始前 10 分钟内签到
- 验证签到状态为 'present'
- 验证 `is_late` 为 false

### 2. 迟到签到测试
- 在课程开始后签到
- 验证签到状态为 'late'
- 验证 `is_late` 为 true
- 验证 `late_minutes` 计算正确

### 3. 窗口期签到测试
- 在验证窗口时间内签到
- 传递 `window_id`、`window_open_time`、`window_close_time` 参数
- 验证 `last_checkin_source` 为 'window'
- 验证 `window_id` 字段正确保存

### 4. 幂等性测试
- 同一学生在同一天对同一课程多次签到
- 验证只有第一次签到生效
- 后续请求返回 "签到请求已在处理中"

### 5. 时间窗口验证测试
- 在签到时间窗口外签到
- 验证返回错误信息："当前不在签到时间窗口内"

---

## 六、部署注意事项

1. **确保 Redis 正常运行**
   - BullMQ 依赖 Redis
   - 检查 Redis 连接配置

2. **监控队列状态**
   - 使用 BullMQ 的监控工具查看队列状态
   - 关注失败任务和重试情况

3. **日志监控**
   - 关注签到队列的处理日志
   - 监控错误日志，及时发现问题

4. **性能监控**
   - 监控签到接口响应时间
   - 监控队列处理速度
   - 监控数据库查询性能

---

## 七、总结

本次修复完成了以下目标：

✅ **性能优化**：移除高频校验，大幅提升签到接口性能  
✅ **幂等性保护**：使用 BullMQ 的 jobId 机制防止重复提交  
✅ **时间准确性**：确保 checkin_time 记录用户实际签到时间  
✅ **窗口期支持**：实现窗口期签到的基础逻辑  
✅ **队列处理**：在 Service 的 onReady 中注册 Worker  

⚠️ **待完成**：
- 数据库字段迁移（verification_status、verification_round、last_verification_time）
- 前端适配（传递时间参数）

---

**修复人员**：Augment Agent  
**审核状态**：待审核  
**版本**：v1.0

