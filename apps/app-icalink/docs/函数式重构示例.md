# 函数式 Service 层重构示例

本文档展示如何将现有的 OOP Service 方法重构为函数式风格。

## 目录
1. [示例 1：简单查询 - getStudentAttendanceRecord](#示例-1简单查询---getstudentattendancerecord)
2. [示例 2：复杂业务逻辑 - submitLeaveApplication](#示例-2复杂业务逻辑---submitleaveapplication)
3. [示例 3：文件上传 - uploadImage](#示例-3文件上传---uploadimage)

---

## 示例 1：简单查询 - getStudentAttendanceRecord

### 原始 OOP 代码

```typescript
// apps/app-icalink/src/services/AttendanceService.ts
class AttendanceService implements IAttendanceService {
  constructor(
    private readonly attendanceRecordRepository: IAttendanceRecordRepository,
    private readonly attendanceCourseRepository: IAttendanceCourseRepository,
    private readonly logger: Logger
  ) {}

  async getStudentAttendanceRecord(
    courseId: string,
    studentInfo: UserInfo
  ): Promise<ServiceResult<any>> {
    return wrapServiceCall(async () => {
      this.logger.info(
        { courseId, studentId: studentInfo.id },
        'Getting student attendance record'
      );

      // 获取课程数据
      const courseResult = await this.attendanceCourseRepository.findByExternalId(courseId);
      if (!isSuccessResult(courseResult)) {
        throw new Error('课程不存在');
      }

      const course = courseResult.data;
      if (!course) {
        throw new Error('课程不存在');
      }

      // 计算课程状态
      const startTime = new Date(course.start_time);
      const endTime = new Date(course.end_time);
      const now = new Date();

      let courseStatus: 'not_started' | 'in_progress' | 'finished';
      if (now < startTime) {
        courseStatus = 'not_started';
      } else if (now > endTime) {
        courseStatus = 'finished';
      } else {
        courseStatus = 'in_progress';
      }

      // 获取学生的考勤记录
      const attendanceRecordResult =
        await this.attendanceRecordRepository.findByCourseAndStudent(
          course.id,
          studentInfo.id
        );

      let attendanceRecord = null;
      if (isSuccessResult(attendanceRecordResult)) {
        attendanceRecord = attendanceRecordResult.data;
      }

      return {
        course,
        courseStatus,
        attendanceRecord
      };
    }, ServiceErrorCode.DATABASE_ERROR);
  }
}
```

**问题分析**：
- ❌ 依赖 `this` 上下文
- ❌ 多次使用 `isSuccessResult` 检查
- ❌ 使用异常处理错误
- ❌ 业务逻辑混杂在一起
- ❌ 难以测试和复用

### 函数式重构

```typescript
// apps/app-icalink/src/services/functional/attendance.ts
import { pipe, eitherChain, eitherMap, tryCatchAsync } from '@stratix/utils/functional';
import type { Either } from '@stratix/utils/functional';
import {
  createServiceFunction,
  toServiceError,
  validateExists
} from '../../utils/functional-service.js';
import type { ServiceError } from '../../types/service.js';
import { ServiceErrorCode } from '../../types/service.js';

// 定义依赖类型
type AttendanceDeps = {
  attendanceRecordRepository: IAttendanceRecordRepository;
  attendanceCourseRepository: IAttendanceCourseRepository;
  logger: Logger;
};

// 定义返回类型
type StudentAttendanceRecord = {
  course: IcasyncAttendanceCourse;
  courseStatus: 'not_started' | 'in_progress' | 'finished';
  attendanceRecord: IcalinkAttendanceRecord | null;
};

// 辅助函数：计算课程状态
const calculateCourseStatus = (course: IcasyncAttendanceCourse): 'not_started' | 'in_progress' | 'finished' => {
  const startTime = new Date(course.start_time);
  const endTime = new Date(course.end_time);
  const now = new Date();

  if (now < startTime) return 'not_started';
  if (now > endTime) return 'finished';
  return 'in_progress';
};

// 辅助函数：获取课程
const fetchCourse = (deps: AttendanceDeps) => (courseId: string): Promise<Either<ServiceError, IcasyncAttendanceCourse>> =>
  pipe(
    tryCatchAsync(
      () => deps.attendanceCourseRepository.findByExternalId(courseId),
      toServiceError(ServiceErrorCode.DATABASE_ERROR, '获取课程失败')
    ),
    async (result) => result,
    eitherChain(validateExists('课程不存在'))
  );

// 辅助函数：获取考勤记录（允许不存在）
const fetchAttendanceRecord = (deps: AttendanceDeps) => 
  (courseId: number, studentId: string): Promise<Either<ServiceError, IcalinkAttendanceRecord | null>> =>
    tryCatchAsync(
      async () => {
        const result = await deps.attendanceRecordRepository.findByCourseAndStudent(courseId, studentId);
        return result.success ? result.data : null;
      },
      toServiceError(ServiceErrorCode.DATABASE_ERROR, '获取考勤记录失败')
    );

// 主函数：获取学生考勤记录
const getStudentAttendanceRecordCore = (deps: AttendanceDeps) => 
  async (courseId: string, studentInfo: UserInfo): Promise<Either<ServiceError, StudentAttendanceRecord>> => {
    // 获取课程
    const courseEither = await fetchCourse(deps)(courseId);
    if (isLeft(courseEither)) return courseEither;
    
    const course = courseEither.right;
    const courseStatus = calculateCourseStatus(course);
    
    // 获取考勤记录
    const recordEither = await fetchAttendanceRecord(deps)(course.id, studentInfo.id);
    if (isLeft(recordEither)) return recordEither;
    
    return right({
      course,
      courseStatus,
      attendanceRecord: recordEither.right
    });
  };

// 导出：应用装饰器
export const getStudentAttendanceRecord = (deps: AttendanceDeps) =>
  createServiceFunction(
    'getStudentAttendanceRecord',
    deps.logger,
    getStudentAttendanceRecordCore(deps),
    {
      enableLogging: true,
      enablePerformanceMonitoring: true,
      slowThreshold: 500
    }
  );
```

**改进点**：
- ✅ 纯函数，无 `this` 依赖
- ✅ 使用 Either 类型，编译时类型检查
- ✅ 业务逻辑分解为小函数
- ✅ 自动日志和性能监控
- ✅ 易于测试

### 测试示例

```typescript
// apps/app-icalink/src/services/functional/__tests__/attendance.test.ts
import { describe, it, expect } from 'vitest';
import { isRight, isLeft } from '@stratix/utils/functional';
import { getStudentAttendanceRecord } from '../attendance.js';

describe('getStudentAttendanceRecord', () => {
  it('should return student attendance record when course exists', async () => {
    const mockCourse = {
      id: 1,
      external_id: 'course-1',
      start_time: new Date('2024-01-01T09:00:00'),
      end_time: new Date('2024-01-01T11:00:00')
    };

    const mockRecord = {
      id: 1,
      course_id: 1,
      student_id: 'student-1',
      status: 'present'
    };

    const deps = {
      attendanceCourseRepository: {
        findByExternalId: async () => ({ success: true, data: mockCourse })
      },
      attendanceRecordRepository: {
        findByCourseAndStudent: async () => ({ success: true, data: mockRecord })
      },
      logger: { info: () => {}, error: () => {}, warn: () => {}, debug: () => {} }
    };

    const result = await getStudentAttendanceRecord(deps)('course-1', { id: 'student-1' });

    expect(isRight(result)).toBe(true);
    if (isRight(result)) {
      expect(result.right.course).toEqual(mockCourse);
      expect(result.right.attendanceRecord).toEqual(mockRecord);
    }
  });

  it('should return error when course not found', async () => {
    const deps = {
      attendanceCourseRepository: {
        findByExternalId: async () => ({ success: true, data: null })
      },
      attendanceRecordRepository: {
        findByCourseAndStudent: async () => ({ success: true, data: null })
      },
      logger: { info: () => {}, error: () => {}, warn: () => {}, debug: () => {} }
    };

    const result = await getStudentAttendanceRecord(deps)('course-1', { id: 'student-1' });

    expect(isLeft(result)).toBe(true);
    if (isLeft(result)) {
      expect(result.left.message).toContain('课程不存在');
    }
  });
});
```

---

## 示例 2：复杂业务逻辑 - submitLeaveApplication

### 原始 OOP 代码

```typescript
// apps/app-icalink/src/services/LeaveService.ts
class LeaveService implements ILeaveService {
  async submitLeaveApplication(
    userInfo: UserInfo,
    request: LeaveApplicationRequest
  ): Promise<ServiceResult<LeaveApplicationResponse>> {
    return wrapServiceCall(async () => {
      // 验证日期范围
      const startDateValidation = validateDateString(request.start_date, '开始日期');
      if (!isSuccessResult(startDateValidation)) {
        throw new Error(startDateValidation.error?.message);
      }

      const endDateValidation = validateDateString(request.end_date, '结束日期');
      if (!isSuccessResult(endDateValidation)) {
        throw new Error(endDateValidation.error?.message);
      }

      const startDate = startDateValidation.data;
      const endDate = endDateValidation.data;

      const rangeValidation = validateDateRange(startDate, endDate);
      if (!isSuccessResult(rangeValidation)) {
        throw new Error(rangeValidation.error?.message);
      }

      // 验证请假类型
      const typeValidation = validateLeaveType(request.leave_type);
      if (!isSuccessResult(typeValidation)) {
        throw new Error(typeValidation.error?.message);
      }

      // 验证请假原因
      const reasonValidation = validateLeaveReason(request.reason);
      if (!isSuccessResult(reasonValidation)) {
        throw new Error(reasonValidation.error?.message);
      }

      // 检查是否有冲突的请假申请
      const conflictingResult =
        await this.leaveApplicationRepository.findConflictingApplications(
          userInfo.id,
          startDate,
          endDate
        );

      if (isSuccessResult(conflictingResult) && conflictingResult.data.length > 0) {
        throw new Error('存在冲突的请假申请');
      }

      // 创建请假申请
      const applicationResult = await this.leaveApplicationRepository.create({
        student_id: userInfo.id,
        leave_type: request.leave_type,
        start_date: formatDate(startDate),
        end_date: formatDate(endDate),
        reason: request.reason,
        status: 'pending',
        created_at: getCurrentDateTime()
      });

      if (!isSuccessResult(applicationResult)) {
        throw new Error('创建请假申请失败');
      }

      return {
        application_id: applicationResult.data.id,
        status: 'pending',
        message: '请假申请已提交'
      };
    }, ServiceErrorCode.DATABASE_ERROR);
  }
}
```

### 函数式重构

```typescript
// apps/app-icalink/src/services/functional/leave.ts
import { pipe, pipeAsync, eitherChain, eitherMap } from '@stratix/utils/functional';
import {
  createServiceFunction,
  toServiceError,
  validateRequired,
  validateStringLength
} from '../../utils/functional-service.js';

type LeaveDeps = {
  leaveApplicationRepository: ILeaveApplicationRepository;
  logger: Logger;
};

// 验证请假请求
const validateLeaveRequest = (request: LeaveApplicationRequest): Either<ServiceError, LeaveApplicationRequest> =>
  pipe(
    request,
    (req) => validateRequired('start_date')(req.start_date).then(() => req),
    eitherChain((req) => validateRequired('end_date')(req.end_date).then(() => req)),
    eitherChain((req) => validateRequired('leave_type')(req.leave_type).then(() => req)),
    eitherChain((req) => validateRequired('reason')(req.reason).then(() => req)),
    eitherChain((req) => validateStringLength('reason', 10, 500)(req.reason).then(() => req)),
    eitherChain(validateDateRange)
  );

// 验证日期范围
const validateDateRange = (request: LeaveApplicationRequest): Either<ServiceError, LeaveApplicationRequest> => {
  const startDate = new Date(request.start_date);
  const endDate = new Date(request.end_date);
  
  if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
    return left(toServiceError(ServiceErrorCode.INVALID_DATE_FORMAT, '日期格式无效')(new Error()));
  }
  
  if (startDate > endDate) {
    return left(toServiceError(ServiceErrorCode.INVALID_TIME_RANGE, '开始日期不能晚于结束日期')(new Error()));
  }
  
  return right(request);
};

// 检查冲突的请假申请
const checkConflictingLeaves = (deps: LeaveDeps) => 
  (request: LeaveApplicationRequest, studentId: string): Promise<Either<ServiceError, LeaveApplicationRequest>> =>
    pipe(
      tryCatchAsync(
        () => deps.leaveApplicationRepository.findConflictingApplications(
          studentId,
          new Date(request.start_date),
          new Date(request.end_date)
        ),
        toServiceError(ServiceErrorCode.DATABASE_ERROR, '检查冲突请假失败')
      ),
      eitherChain((result) =>
        result.success && result.data && result.data.length > 0
          ? left(toServiceError(ServiceErrorCode.LEAVE_APPLICATION_ALREADY_EXISTS, '存在冲突的请假申请')(new Error()))
          : right(request)
      )
    );

// 创建请假申请
const createLeaveApplication = (deps: LeaveDeps) => 
  (request: LeaveApplicationRequest, studentId: string): Promise<Either<ServiceError, any>> =>
    tryCatchAsync(
      () => deps.leaveApplicationRepository.create({
        student_id: studentId,
        leave_type: request.leave_type,
        start_date: request.start_date,
        end_date: request.end_date,
        reason: request.reason,
        status: 'pending',
        created_at: new Date().toISOString()
      }),
      toServiceError(ServiceErrorCode.DATABASE_ERROR, '创建请假申请失败')
    ).then(eitherChain((result) =>
      result.success && result.data
        ? right(result.data)
        : left(toServiceError(ServiceErrorCode.DATABASE_ERROR, '创建请假申请失败')(new Error()))
    ));

// 格式化响应
const formatLeaveResponse = (application: any): LeaveApplicationResponse => ({
  application_id: application.id,
  status: 'pending',
  message: '请假申请已提交'
});

// 主函数
const submitLeaveApplicationCore = (deps: LeaveDeps) => 
  async (userInfo: UserInfo, request: LeaveApplicationRequest): Promise<Either<ServiceError, LeaveApplicationResponse>> => {
    // 验证请求
    const validatedRequest = validateLeaveRequest(request);
    if (isLeft(validatedRequest)) return validatedRequest;
    
    // 检查冲突
    const checkedRequest = await checkConflictingLeaves(deps)(validatedRequest.right, userInfo.id);
    if (isLeft(checkedRequest)) return checkedRequest;
    
    // 创建申请
    const application = await createLeaveApplication(deps)(checkedRequest.right, userInfo.id);
    if (isLeft(application)) return application;
    
    // 格式化响应
    return right(formatLeaveResponse(application.right));
  };

// 导出
export const submitLeaveApplication = (deps: LeaveDeps) =>
  createServiceFunction(
    'submitLeaveApplication',
    deps.logger,
    submitLeaveApplicationCore(deps),
    {
      enableLogging: true,
      enablePerformanceMonitoring: true,
      slowThreshold: 1000
    }
  );
```

---

## 示例 3：文件上传 - uploadImage

### 原始 OOP 代码

```typescript
// apps/app-icalink/src/services/OsspStorageService.ts
class OsspStorageService implements IOsspStorageService {
  async uploadImage(
    bucketName: string,
    imageData: Buffer,
    options: ImageUploadOptions
  ): Promise<ServiceResult<ImageUploadResult>> {
    return wrapServiceCall(async () => {
      this.logger.info(
        { bucketName, fileName: options.fileName, size: imageData.length },
        'Uploading image to OSSP'
      );

      // 确保存储桶存在
      await this.ensureBucket(bucketName);

      // 生成对象路径
      const objectPath = this.generateObjectPathFromOptions(options);

      // 准备元数据
      const metadata = {
        'Content-Type': options.mimeType,
        'x-amz-meta-original-filename': encodeURIComponent(options.fileName),
        ...options.metadata
      };

      // 上传原图
      const uploadResult = await this.osspClient.putObject(
        bucketName,
        objectPath,
        imageData,
        imageData.length,
        { metadata }
      );

      const result: ImageUploadResult = {
        objectPath,
        fileSize: imageData.length,
        etag: uploadResult.etag,
        versionId: uploadResult.versionId
      };

      // 生成并上传缩略图
      if (options.generateThumbnail) {
        try {
          const thumbnailData = await this.generateThumbnail(
            imageData,
            options.thumbnailWidth || 200,
            options.thumbnailHeight || 200
          );

          const thumbnailPath = this.generateObjectPathFromOptions(options, true);

          await this.osspClient.putObject(
            bucketName,
            thumbnailPath,
            thumbnailData,
            thumbnailData.length,
            { metadata: { ...metadata, 'is-thumbnail': 'true' } }
          );

          result.thumbnailPath = thumbnailPath;
          result.thumbnailSize = thumbnailData.length;
        } catch (error) {
          this.logger.warn({ error }, 'Failed to generate/upload thumbnail');
        }
      }

      return result;
    }, ServiceErrorCode.STORAGE_ERROR);
  }
}
```

### 函数式重构

```typescript
// apps/app-icalink/src/services/functional/storage.ts
import { pipe, eitherChain, eitherMap, tryCatchAsync } from '@stratix/utils/functional';
import { createServiceFunction, toServiceError } from '../../utils/functional-service.js';

type StorageDeps = {
  osspClient: OsspClientAdapter;
  logger: Logger;
};

// 确保存储桶存在
const ensureBucket = (deps: StorageDeps) => (bucketName: string): Promise<Either<ServiceError, string>> =>
  tryCatchAsync(
    async () => {
      const exists = await deps.osspClient.bucketExists(bucketName);
      if (!exists) {
        await deps.osspClient.makeBucket(bucketName, 'us-east-1');
      }
      return bucketName;
    },
    toServiceError(ServiceErrorCode.STORAGE_ERROR, '存储桶操作失败')
  );

// 上传原图
const uploadOriginalImage = (deps: StorageDeps) => 
  (bucketName: string, objectPath: string, imageData: Buffer, metadata: Record<string, string>): Promise<Either<ServiceError, any>> =>
    tryCatchAsync(
      () => deps.osspClient.putObject(bucketName, objectPath, imageData, imageData.length, { metadata }),
      toServiceError(ServiceErrorCode.STORAGE_ERROR, '上传图片失败')
    );

// 生成并上传缩略图（可选）
const uploadThumbnail = (deps: StorageDeps) => 
  async (bucketName: string, thumbnailPath: string, imageData: Buffer, width: number, height: number, metadata: Record<string, string>): Promise<Either<ServiceError, Buffer | null>> => {
    try {
      const thumbnailData = await sharp(imageData)
        .resize(width, height, { fit: 'inside', withoutEnlargement: true })
        .jpeg({ quality: 80 })
        .toBuffer();
      
      await deps.osspClient.putObject(
        bucketName,
        thumbnailPath,
        thumbnailData,
        thumbnailData.length,
        { metadata: { ...metadata, 'is-thumbnail': 'true' } }
      );
      
      return right(thumbnailData);
    } catch (error) {
      deps.logger.warn({ error }, 'Failed to generate/upload thumbnail');
      return right(null); // 缩略图失败不影响主流程
    }
  };

// 主函数
const uploadImageCore = (deps: StorageDeps) => 
  async (bucketName: string, imageData: Buffer, options: ImageUploadOptions): Promise<Either<ServiceError, ImageUploadResult>> => {
    // 确保存储桶存在
    const bucketEither = await ensureBucket(deps)(bucketName);
    if (isLeft(bucketEither)) return bucketEither;
    
    // 生成路径和元数据
    const objectPath = generateObjectPath(options);
    const metadata = {
      'Content-Type': options.mimeType,
      'x-amz-meta-original-filename': encodeURIComponent(options.fileName),
      ...options.metadata
    };
    
    // 上传原图
    const uploadEither = await uploadOriginalImage(deps)(bucketName, objectPath, imageData, metadata);
    if (isLeft(uploadEither)) return uploadEither;
    
    const result: ImageUploadResult = {
      objectPath,
      fileSize: imageData.length,
      etag: uploadEither.right.etag,
      versionId: uploadEither.right.versionId
    };
    
    // 上传缩略图（如果需要）
    if (options.generateThumbnail) {
      const thumbnailPath = generateObjectPath(options, true);
      const thumbnailEither = await uploadThumbnail(deps)(
        bucketName,
        thumbnailPath,
        imageData,
        options.thumbnailWidth || 200,
        options.thumbnailHeight || 200,
        metadata
      );
      
      if (isRight(thumbnailEither) && thumbnailEither.right) {
        result.thumbnailPath = thumbnailPath;
        result.thumbnailSize = thumbnailEither.right.length;
      }
    }
    
    return right(result);
  };

// 导出
export const uploadImage = (deps: StorageDeps) =>
  createServiceFunction(
    'uploadImage',
    deps.logger,
    uploadImageCore(deps),
    {
      enableLogging: true,
      enablePerformanceMonitoring: true,
      slowThreshold: 2000,
      timeout: 30000 // 30秒超时
    }
  );
```

---

## 总结

通过以上三个示例，我们可以看到函数式重构的主要模式：

1. **依赖注入**：通过函数参数显式传递依赖
2. **纯函数分解**：将复杂逻辑分解为小的纯函数
3. **Either 类型**：使用 Either 替代异常处理
4. **函数组合**：使用 pipe/pipeAsync 组合业务逻辑
5. **装饰器模式**：使用高阶函数添加横切关注点
6. **类型安全**：充分利用 TypeScript 的类型系统

这些模式使代码更加：
- **可测试**：纯函数易于测试
- **可维护**：逻辑清晰，职责单一
- **可复用**：小函数可以在多处复用
- **类型安全**：编译时错误检查

