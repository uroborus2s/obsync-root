# 动态引擎发现机制测试验证方案

## 1. 功能测试

### 1.1 基础发现测试

**测试场景1：新引擎加入**
```typescript
// 测试步骤
1. 启动节点A，等待初始化完成
2. 启动节点B，观察节点A是否能在60秒内发现节点B
3. 验证节点A的engines Map中包含节点B的信息
4. 检查日志中的"发现新引擎"记录

// 预期结果
- 节点A在60秒内发现节点B
- engines Map正确更新
- 触发engine_added事件
- 统计信息正确更新
```

**测试场景2：引擎状态更新**
```typescript
// 测试步骤
1. 两个节点都运行正常
2. 修改节点B的负载信息
3. 观察节点A是否能检测到变化

// 预期结果
- 节点A检测到引擎信息变化
- 触发engine_updated事件
- 内存中的引擎信息正确更新
```

**测试场景3：引擎移除检测**
```typescript
// 测试步骤
1. 两个节点都运行正常
2. 正常关闭节点B
3. 观察节点A的全量同步是否能检测到移除

// 预期结果
- 在下次全量同步时检测到引擎移除
- 触发engine_removed事件
- 从engines Map中移除对应引擎
```

### 1.2 智能间隔调整测试

**测试场景4：间隔自适应**
```typescript
// 测试步骤
1. 启动节点A，观察初始间隔（60秒）
2. 连续3次无变化后，观察间隔是否延长
3. 添加新引擎，观察间隔是否缩短

// 预期结果
- 无变化时间隔逐渐延长（最大300秒）
- 有变化时间隔缩短到基础值
- 智能调整日志正确记录
```

## 2. 性能测试

### 2.1 负载测试

**测试场景5：多引擎环境**
```typescript
// 测试配置
- 同时运行5个引擎节点
- 观察发现机制的性能表现
- 监控数据库查询频率

// 性能指标
- 发现延迟 < 120秒
- 数据库查询频率 < 1次/分钟/节点
- 内存使用增长 < 10MB
```

### 2.2 故障恢复测试

**测试场景6：数据库连接失败**
```typescript
// 测试步骤
1. 正常运行时断开数据库连接
2. 观察错误处理和间隔调整
3. 恢复数据库连接，观察恢复情况

// 预期结果
- 发现失败时延长检查间隔
- 记录详细错误日志
- 数据库恢复后正常工作
```

## 3. 边界情况测试

### 3.1 网络分区测试

**测试场景7：网络分区**
```typescript
// 测试步骤
1. 创建网络分区，隔离部分节点
2. 观察各分区内的引擎发现行为
3. 恢复网络连接，观察状态同步

// 预期结果
- 分区期间各自维护本地状态
- 网络恢复后状态正确同步
- 无数据不一致问题
```

### 3.2 并发测试

**测试场景8：并发引擎注册**
```typescript
// 测试步骤
1. 同时启动多个引擎节点
2. 观察并发注册和发现的处理
3. 验证最终状态一致性

// 预期结果
- 所有引擎都能被正确发现
- 无竞态条件导致的数据不一致
- 统计信息准确
```

## 4. 集成测试

### 4.1 与现有机制协调测试

**测试场景9：与心跳监控协调**
```typescript
// 测试步骤
1. 验证引擎发现与心跳监控不冲突
2. 观察故障检测和发现机制的协调
3. 验证引擎清理与发现的一致性

// 预期结果
- 两个机制协调工作
- 无重复或冲突的操作
- 状态保持一致
```

### 4.2 工作流分配测试

**测试场景10：动态负载均衡**
```typescript
// 测试步骤
1. 启动节点A，分配一些工作流
2. 启动节点B，观察新工作流的分配
3. 验证负载均衡是否利用新发现的引擎

// 预期结果
- 新引擎被纳入负载均衡
- 工作流分配更加均匀
- 系统整体性能提升
```

## 5. 监控和告警测试

### 5.1 健康检查测试

**测试场景11：健康状态监控**
```typescript
// 测试代码示例
const health = scheduler.getEngineDiscoveryHealth();
console.log('健康状态:', health.isHealthy);
console.log('同步延迟:', health.lastSyncAge);
console.log('问题列表:', health.issues);

// 验证点
- 健康状态准确反映系统状态
- 问题检测及时有效
- 监控指标完整准确
```

### 5.2 统计信息测试

**测试场景12：统计信息准确性**
```typescript
// 测试代码示例
const metrics = scheduler.getEngineDiscoveryMetrics();
console.log('发现统计:', {
  totalDiscoveries: metrics.totalDiscoveries,
  incrementalSyncs: metrics.incrementalSyncs,
  fullSyncs: metrics.fullSyncs,
  currentInterval: metrics.currentInterval
});

// 验证点
- 统计数据准确无误
- 计数器正确递增
- 时间戳准确记录
```

## 6. 自动化测试脚本

### 6.1 基础测试脚本

```typescript
// test/engine-discovery.test.ts
describe('动态引擎发现', () => {
  let schedulerA: DistributedScheduler;
  let schedulerB: DistributedScheduler;

  beforeEach(async () => {
    // 初始化测试环境
  });

  test('应该能发现新加入的引擎', async () => {
    // 启动节点A
    await schedulerA.onReady();
    
    // 等待初始化完成
    await sleep(1000);
    
    // 启动节点B
    await schedulerB.onReady();
    
    // 等待发现完成
    await sleep(65000);
    
    // 验证发现结果
    const engines = schedulerA.getEngines();
    expect(engines.size).toBe(2);
  });

  test('应该能检测引擎状态变化', async () => {
    // 实现状态变化检测测试
  });
});
```

## 7. 性能基准测试

### 7.1 基准指标

| 指标 | 目标值 | 测试方法 |
|------|--------|----------|
| 发现延迟 | < 120秒 | 新引擎加入到被发现的时间 |
| 数据库负载 | < 1 QPS/节点 | 监控数据库查询频率 |
| 内存开销 | < 10MB | 监控引擎发现相关内存使用 |
| CPU开销 | < 1% | 监控发现过程CPU使用率 |

### 7.2 压力测试

```typescript
// 压力测试配置
const stressTestConfig = {
  engineCount: 10,        // 同时运行的引擎数量
  testDuration: 3600,     // 测试持续时间（秒）
  changeFrequency: 300,   // 引擎状态变化频率（秒）
  monitoringInterval: 60  // 监控数据收集间隔（秒）
};
```

## 8. 故障注入测试

### 8.1 故障场景

1. **数据库连接中断**：模拟数据库不可用
2. **网络延迟**：模拟高延迟网络环境
3. **内存不足**：模拟系统资源紧张
4. **并发冲突**：模拟高并发访问场景

### 8.2 恢复验证

- 故障恢复后系统能否正常工作
- 数据一致性是否得到保证
- 性能是否恢复到正常水平
