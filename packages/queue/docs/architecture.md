# @stratix/queue 整体架构设计

## 🎯 项目概述

### 设计目标
基于Redis Streams + Redis Cluster构建高性能、高可用的分布式消息队列系统，支持：
- **高并发**: 支持10万+TPS消息处理
- **高可用**: 99.99%可用性保证
- **可扩展**: 支持水平扩展和分布式部署
- **可靠性**: 消息不丢失，支持事务和重试机制

### 技术选型对比

| 特性 | Redis Streams | RabbitMQ | Apache Kafka | AWS SQS |
|------|---------------|----------|--------------|---------|
| **性能** | 极高 (内存) | 高 | 极高 | 中等 |
| **延迟** | < 1ms | 1-5ms | 2-10ms | 50-100ms |
| **吞吐量** | 100万+/s | 10万/s | 100万+/s | 3000/s |
| **持久化** | AOF/RDB | 磁盘 | 磁盘 | 云托管 |
| **集群支持** | Redis Cluster | 原生集群 | 分布式 | 云原生 |
| **消费者组** | ✅ | ✅ | ✅ | 部分支持 |
| **消息顺序** | 分区有序 | 队列有序 | 分区有序 | FIFO队列 |
| **运维复杂度** | 低 | 中等 | 高 | 极低 |
| **成本** | 低 | 中等 | 中等 | 按使用付费 |

**选择Redis Streams的原因**：
1. **性能优势**: 内存操作，微秒级延迟
2. **简单部署**: 基于Redis，运维成本低
3. **原生集群**: Redis Cluster天然支持
4. **丰富功能**: 消费者组、消息确认、重试机制
5. **生态兼容**: 与现有Redis基础设施无缝集成

## 🏗️ 系统架构

### 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        应用层 (Application Layer)                │
├─────────────────────────────────────────────────────────────────┤
│  Producer App 1  │  Producer App 2  │  Consumer App 1  │ ...    │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    @stratix/queue 客户端库                      │
├─────────────────────────────────────────────────────────────────┤
│  QueueManager  │  Producer  │  Consumer  │  Monitor  │  Admin   │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Redis Cluster 集群                         │
├─────────────────────────────────────────────────────────────────┤
│  Master 1    │  Master 2    │  Master 3    │  Master 4         │
│  (Slot 0-    │  (Slot 4096- │  (Slot 8192- │  (Slot 12288-     │
│   4095)      │   8191)      │   12287)     │   16383)          │
│              │              │              │                   │
│  Slave 1     │  Slave 2     │  Slave 3     │  Slave 4          │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                        监控和管理层                              │
├─────────────────────────────────────────────────────────────────┤
│  Prometheus  │  Grafana     │  Redis Insight │  Alert Manager  │
└─────────────────────────────────────────────────────────────────┘
```

### 核心组件设计

#### 1. QueueManager (队列管理器)
- **职责**: 统一管理所有队列实例
- **功能**: 连接池管理、配置管理、健康检查
- **特性**: 单例模式、线程安全、自动重连

#### 2. Producer (生产者)
- **职责**: 消息发送和路由
- **功能**: 批量发送、优先级队列、延迟消息
- **特性**: 异步发送、失败重试、负载均衡

#### 3. Consumer (消费者)
- **职责**: 消息消费和处理
- **功能**: 消费者组、消息确认、重试机制
- **特性**: 并发控制、背压处理、死信队列

#### 4. Monitor (监控器)
- **职责**: 系统监控和指标收集
- **功能**: 性能指标、健康检查、告警通知
- **特性**: 实时监控、历史数据、可视化

#### 5. Admin (管理工具)
- **职责**: 队列管理和运维操作
- **功能**: 队列创建、消息查看、集群管理
- **特性**: Web界面、CLI工具、API接口

## 🔧 技术实现

### Redis Streams 核心特性

#### 1. 消息结构
```typescript
interface StreamMessage {
  id: string;           // 消息ID (时间戳-序号)
  fields: {
    payload: string;    // 消息内容 (JSON序列化)
    priority: number;   // 消息优先级 (0-9)
    delay: number;      // 延迟时间 (毫秒)
    retry: number;      // 重试次数
    created: number;    // 创建时间戳
    source: string;     // 消息来源
  }
}
```

#### 2. 消费者组机制
```typescript
interface ConsumerGroup {
  name: string;         // 消费者组名称
  stream: string;       // 流名称
  consumers: Consumer[]; // 消费者列表
  lastId: string;       // 最后消费的消息ID
  pending: number;      // 待确认消息数量
}
```

#### 3. 集群分片策略
- **Hash Slot**: 基于队列名称的一致性哈希
- **负载均衡**: 轮询、权重、最少连接
- **故障转移**: 自动检测、快速切换、数据恢复

### 消息生命周期

```
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ 生产者   │───▶│ 队列     │───▶│ 消费者   │───▶│ 确认     │
│ Producer│    │ Queue   │    │Consumer │    │ ACK     │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
                     │                           │
                     ▼                           │
               ┌─────────┐                       │
               │ 延迟队列 │                       │
               │ Delay   │                       │
               └─────────┘                       │
                     │                           │
                     ▼                           │
               ┌─────────┐                       │
               │ 重试队列 │◀──────────────────────┘
               │ Retry   │
               └─────────┘
                     │
                     ▼
               ┌─────────┐
               │ 死信队列 │
               │ DLQ     │
               └─────────┘
```

## 📊 性能设计

### 性能目标
- **吞吐量**: 100,000+ TPS
- **延迟**: P99 < 5ms
- **可用性**: 99.99%
- **并发**: 10,000+ 连接

### 优化策略
1. **连接池**: 复用Redis连接，减少连接开销
2. **批量操作**: 批量发送/接收，提高吞吐量
3. **管道化**: Pipeline操作，减少网络往返
4. **压缩**: 消息压缩，减少网络传输
5. **缓存**: 本地缓存，减少Redis访问

### 扩展性设计
1. **水平扩展**: 增加Redis节点
2. **垂直扩展**: 增加节点配置
3. **读写分离**: 主从复制
4. **分片策略**: 一致性哈希

## 🛡️ 可靠性保证

### 消息可靠性
1. **持久化**: AOF + RDB双重保障
2. **复制**: 主从复制，数据冗余
3. **确认机制**: 消息确认，防止丢失
4. **重试机制**: 指数退避重试
5. **死信队列**: 处理失败消息

### 系统可靠性
1. **健康检查**: 定期检查节点状态
2. **故障转移**: 自动切换主节点
3. **数据恢复**: 从备份恢复数据
4. **监控告警**: 实时监控系统状态

## 🔒 安全设计

### 访问控制
1. **认证**: Redis AUTH密码认证
2. **授权**: ACL访问控制列表
3. **加密**: TLS传输加密
4. **网络**: VPC网络隔离

### 数据安全
1. **加密**: 消息内容加密
2. **脱敏**: 敏感数据脱敏
3. **审计**: 操作日志记录
4. **备份**: 定期数据备份

## 📈 监控和运维

### 监控指标
1. **业务指标**: 消息量、延迟、错误率
2. **系统指标**: CPU、内存、网络、磁盘
3. **Redis指标**: 连接数、命令执行、内存使用
4. **集群指标**: 节点状态、分片分布、故障转移

### 告警策略
1. **阈值告警**: 超过预设阈值
2. **趋势告警**: 指标异常趋势
3. **故障告警**: 系统故障事件
4. **业务告警**: 业务异常事件

## 🚀 部署架构

### 生产环境部署
```yaml
# Redis Cluster 配置
redis-cluster:
  nodes: 6              # 3主3从
  memory: 16GB          # 每节点内存
  cpu: 4cores           # 每节点CPU
  disk: 100GB SSD       # 每节点磁盘
  network: 10Gbps       # 网络带宽

# 应用部署
application:
  instances: 3          # 应用实例数
  memory: 8GB           # 每实例内存
  cpu: 4cores           # 每实例CPU
  connections: 100      # Redis连接池大小
```

### 容器化部署
- **Docker**: 容器化部署
- **Kubernetes**: 容器编排
- **Helm**: 包管理
- **Istio**: 服务网格

## 📋 开发计划

### 第一阶段 (核心功能)
- [ ] Redis连接管理
- [ ] 基础消息发送/接收
- [ ] 消费者组支持
- [ ] 消息确认机制

### 第二阶段 (高级功能)
- [ ] 延迟消息
- [ ] 重试机制
- [ ] 死信队列
- [ ] 批量操作

### 第三阶段 (集群支持)
- [ ] Redis Cluster支持
- [ ] 负载均衡
- [ ] 故障转移
- [ ] 数据分片

### 第四阶段 (监控运维)
- [ ] 性能监控
- [ ] 健康检查
- [ ] 管理工具
- [ ] 可视化界面
