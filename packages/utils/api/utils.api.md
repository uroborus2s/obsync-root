## API Report File for "@stratix/utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { Duration } from 'date-fns';
import { ErrorObject } from 'ajv';
import { JSONSchemaType } from 'ajv';

// @public
function addDays(date: Date | number | string, amount: number): Date;

// @public
function addMonths(date: Date | number | string, amount: number): Date;

// @public
function addYears(date: Date | number | string, amount: number): Date;

// @public
function after<T extends (...args: any[]) => any>(n: number, func: T): (...args: Parameters<T>) => ReturnType<T> | undefined;

declare namespace array {
    export {
        chunk,
        compact,
        difference,
        flatten,
        groupBy,
        keyBy,
        intersection,
        partition,
        reduce,
        shuffle,
        sortBy,
        take,
        union,
        unique
    }
}

// @public
function ary<T extends (...args: any[]) => any>(func: T, n: number): (...args: any[]) => ReturnType<T>;

// @public
function assign<T extends Record<string, any>, S extends Record<string, any>[]>(target: T, ...sources: S): T & S[number];

declare namespace async {
    export {
        sleep,
        limitConcurrency,
        pMap,
        PMapOptions,
        parallelLimit,
        debounce,
        DebounceOptions,
        throttle,
        ThrottleOptions,
        queue,
        Queue,
        waterfall,
        promisify,
        promisifyAll,
        PromisifiedObject,
        asyncify,
        timeout,
        withTimeout,
        retry,
        RetryOptions
    }
}

// Warning: (ae-forgotten-export) The symbol "CacheableFunction" needs to be exported by the entry point index.d.ts
//
// @public
function asyncCache<T, A extends any[]>(fn: (...args: A) => Promise<T>, options?: AsyncCacheOptions<T, A>): CacheableFunction<T, A>;

// @public
interface AsyncCacheOptions<T, A extends any[]> {
    cacheErrors?: boolean;
    initialCache?: Record<string, {
        value: T;
        timestamp: number;
    }>;
    keyGenerator?: (...args: A) => string;
    maxItems?: number;
    refreshTTL?: boolean;
    ttl?: number;
}

// @public
function asyncify<T extends (...args: any[]) => any>(fn: T): (...args: Parameters<T>) => Promise<ReturnType<T>>;

// @public
function average(array: number[]): number;

// @public
function batch<T, R>(fn: (items: T[]) => Promise<R[]>, options?: BatchOptions): (item: T) => Promise<R>;

// @public
interface BatchOptions {
    maxBatchSize?: number;
    maxDelay?: number;
}

// @public
function before<T extends (...args: any[]) => any>(n: number, func: T): (...args: Parameters<T>) => ReturnType<T> | undefined;

// @public
function benchmark<T>(fn: () => T, iterations?: number, label?: string): BenchmarkResult<T>;

// @public
interface BenchmarkResult<T> {
    averageTime: number;
    iterations: number;
    result: T;
    totalTime: number;
}

// @public
function camelCase(string: string): string;

// @public
function capitalize(str: string): string;

// @public
function capitalizeAll(str: string): string;

// @public
function ceil(number: number, precision?: number): number;

// @public
function chunk<T>(array: T[], size?: number): T[][];

// @public
function clamp(number: number, lower: number, upper: number): number;

// @public
function clearContext<T extends Record<string, any>>(context: Context<T>): void;

declare namespace common {
    export {
        getType,
        isArray,
        isBoolean,
        isDate,
        isError,
        isFiniteNumber,
        isFunction,
        isInstanceOf,
        isNil,
        isNull,
        isNumber,
        isObject,
        isPlainObject,
        isPromise,
        isRegExp,
        isString,
        isUndefined,
        typeGuard,
        isAlpha,
        isAlphanumeric,
        isBase64,
        isEmail,
        isEmpty,
        isHexadecimal,
        isIP,
        isJSON,
        isNotEmpty,
        isNumeric,
        isPhoneNumber,
        isStrongPassword,
        isURL,
        isUrl,
        isUUID,
        validate,
        validateAll,
        validateObject,
        validateWithSchema,
        ValidationResult,
        ValidationRule,
        identity,
        memoize,
        noop,
        partial,
        negate,
        delay,
        defer,
        after,
        before,
        ary,
        unary,
        compose,
        pipe,
        composeAsync,
        pipeAsync,
        curry,
        once,
        generateNumberId,
        generateUuid,
        generateId,
        immutablePush,
        immutablePop,
        immutableUnshift,
        immutableShift,
        immutableReverse,
        immutableSort,
        immutableSplice,
        immutableSet,
        immutableUpdate,
        immutableDelete,
        immutableMerge,
        immutableDeepMerge,
        freeze,
        deepFreeze,
        createReducer,
        produce,
        Path,
        safeExecute,
        safeExecuteAsync,
        safeJsonParse,
        safeGet,
        toString,
        toNumber,
        toInteger,
        toBoolean,
        toArray,
        toObject,
        toDate
    }
}

// @public
function compact<T>(array: T[]): T[];

declare namespace compare {
    export {
        isEmpty,
        isNotEmpty,
        isEqual
    }
}

// Warning: (ae-forgotten-export) The symbol "AnyFn" needs to be exported by the entry point index.d.ts
//
// @public
function compose<R>(...fns: AnyFn[]): AnyFn;

// @public
function composeAsync<T = any, R = any>(...fns: Array<(arg: any) => any | Promise<any>>): (arg: T) => Promise<R>;

// @public
interface Context<T extends Record<string, any>> {
    clear(): Context<T>;
    get<K extends keyof T>(key: K): T[K];
    getAll(): T;
    getName(): string;
    has<K extends keyof T>(key: K): boolean;
    onChange(handler: (context: T) => void): () => void;
    remove<K extends keyof T>(key: K): Context<T>;
    set<K extends keyof T>(key: K, value: T[K]): Context<T>;
    setDefaults(defaultValues: Partial<T>): Context<T>;
    subscribe<K extends keyof T>(key: K, handler: (value: T[K], oldValue: T[K]) => void): () => void;
    withHandler<R>(handler: (context: T) => R): R;
}

declare namespace context {
    export {
        createContext,
        createNamespace,
        createContextScope,
        useContext,
        Context,
        NamespaceContext,
        ContextScope,
        UseContextReturn,
        MergeContextOptions,
        withContext,
        getContextValue,
        setContextValue,
        hasContextValue,
        removeContextValue,
        clearContext,
        mergeContexts,
        isolateContext
    }
}

// @public
interface ContextScope {
    createContext<T extends Record<string, any>>(defaultValues?: Partial<T>): Context<T>;
    getScopeName(): string;
}

// @public
interface CPUUsage {
    percentage: number;
    system: number;
    user: number;
}

// @public
function createContext<T extends Record<string, any>>(defaultValues?: Partial<T>): Context<T>;

// @public
function createContextScope(name: string): ContextScope;

// @public
function createNamespace<T extends Record<string, any>>(name: string, defaultValues?: Partial<T>): NamespaceContext<T>;

// @public
function createReducer<State, Action extends {
    type: string;
}>(handlers: Record<string, (state: State, action: Action) => State>, initialState: State): (state: State | undefined, action: Action) => State;

// @public
function curry<T extends (...args: any[]) => any>(fn: T, arity?: number): (...args: any[]) => any;

declare namespace data {
    export {
        array,
        compare,
        merge,
        object,
        select,
        chunk,
        compact,
        difference,
        flatten,
        groupBy,
        keyBy,
        intersection,
        partition,
        reduce,
        shuffle,
        sortBy,
        take,
        union,
        unique,
        isEmpty,
        isNotEmpty,
        isEqual,
        assign,
        defaults,
        deepClone,
        deepMerge,
        isObject,
        get,
        has,
        set,
        keys,
        values,
        entries,
        fromEntries,
        mapKeys,
        mapValues,
        transform,
        pick,
        omit
    }
}

// @public
function debounce<F extends (...args: any[]) => any>(func: F, wait?: number, options?: DebounceOptions): F & {
    cancel(): void;
    flush(): ReturnType<F>;
    pending(): boolean;
};

// Warning: (ae-forgotten-export) The symbol "BaseOptions" needs to be exported by the entry point index.d.ts
//
// @public
interface DebounceOptions extends BaseOptions {
    maxWait?: number;
}

// @public
function deepClone<T>(value: T): T;

// @public
function deepFreeze<T extends object>(obj: T): Readonly<T>;

// @public
function deepMerge<T extends Record<string, any>, S extends Record<string, any>[]>(target: T, ...sources: S): T & S[number];

// @public
function defaults<T extends Record<string, any>, S extends Record<string, any>[]>(target: T, ...sources: S): T & Partial<S[number]>;

// @public
function defer<T extends (...args: any[]) => any>(func: T, ...args: Parameters<T>): ReturnType<typeof setTimeout>;

// @public
function delay<T extends (...args: any[]) => any>(func: T, wait: number, ...args: Parameters<T>): ReturnType<typeof setTimeout>;

// @public
function difference<T>(array: T[], ...values: T[][]): T[];

// @public
function differenceInDays(dateLeft: Date | number | string, dateRight: Date | number | string): number;

// @public
function differenceInMonths(dateLeft: Date | number | string, dateRight: Date | number | string): number;

// @public
function differenceInYears(dateLeft: Date | number | string, dateRight: Date | number | string): number;

// @public
function endOfDay(date: Date | number | string): Date;

// @public
function endOfMonth(date: Date | number | string): Date;

// @public
function endOfYear(date: Date | number | string): Date;

// @public
function endsWith(str: string, target: string, position?: number): boolean;

// @public
function enhancedDeserialize<T = any>(data: string, options?: EnhancedDeserializeOptions): {
    success: boolean;
    data?: T;
    error?: string;
};

// @public
interface EnhancedDeserializeOptions {
    reviveFunctions?: boolean;
    reviver?: (key: string, value: any) => any;
    reviveSpecialObjects?: boolean;
    safeMode?: boolean;
}

// @public
function enhancedSerialize(data: any, options?: EnhancedSerializeOptions): EnhancedSerializeResult;

// @public
interface EnhancedSerializeOptions {
    handleCircular?: boolean;
    handleErrors?: boolean;
    handleFunctions?: boolean;
    handleSpecialObjects?: boolean;
    indent?: number;
    replacer?: (key: string, value: any) => any;
}

// @public
interface EnhancedSerializeResult {
    data?: string;
    error?: string;
    success: boolean;
}

// @public
function entries<T extends object>(object: T): Array<[keyof T, T[keyof T]]>;

declare namespace environment {
    export {
        get_2 as get,
        getBoolean,
        getNumber,
        getArray,
        getObject,
        isDevelopment,
        isProduction,
        isTest,
        getNodeEnv,
        hasEnv,
        required,
        load,
        getAll,
        set_2 as set,
        isBrowser,
        isNode,
        isWebWorker,
        supportsWebAPI,
        supportsCSS,
        getEnvironment,
        isSSR,
        getOSType,
        getBrowserInfo
    }
}

// @public
function escape_2(str: string): string;

// @public
function flatten<T>(array: any[], depth?: number): T[];

// @public
function floor(number: number, precision?: number): number;

// @public
function format(template: string, ...args: any[]): string;

// @public
function format_2(date: Date | number | string, formatStr: string, options?: FormatOptions): string;

// @public
function formatDuration(durationMs: number, options?: FormatDurationOptions): string;

// @public
interface FormatDurationOptions {
    delimiter?: string;
    format?: Array<keyof Duration>;
    locale?: string;
    zero?: boolean;
}

// @public
function formatNumber(number: number, options?: FormatNumberOptions): string;

// @public
interface FormatNumberOptions {
    decimalPlaces?: number;
    decimalSeparator?: string;
    prefix?: string;
    suffix?: string;
    thousandsSeparator?: string;
}

// @public
interface FormatOptions {
    locale?: 'zh-CN' | 'en-US' | 'en' | 'ja' | 'ja-JP';
    weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6;
}

// @public
function freeze<T extends object>(obj: T): Readonly<T>;

// @public
function fromEntries<K extends string | number | symbol, V>(entries: Array<[K, V]>): Record<K, V>;

// @public
function generateId(): string;

// @public
function generateNumberId(min?: number, max?: number): string;

// @public
function generateUuid(): string;

// @public
function get<T = any>(object: any, path: string | string[], defaultValue?: T): T;

// @public
function get_2<T = string>(key: string, defaultValue?: string, transform?: (value: string) => T): string | T | undefined;

// @public
function getAll(): Record<string, string>;

// @public
function getArray(key: string, defaultValue?: string[], separator?: string): string[];

// @public
function getBoolean(key: string, defaultValue?: boolean): boolean;

// @public
function getBrowserInfo(): {
    name: string;
    version: string;
} | null;

// @public
function getContextValue<T extends Record<string, any>, K extends keyof T>(context: Context<T>, key: K): T[K];

// @public
function getCPUUsage(): Promise<CPUUsage | null>;

// @public
function getEnvironment(): {
    type: 'browser' | 'node' | 'webworker' | 'unknown';
    browser?: string;
    nodeVersion?: string;
};

// @public
function getMemoryUsage(): MemoryUsage | null;

// @public
function getNodeEnv(): string;

// @public
function getNumber(key: string, defaultValue?: number): number;

// @public
function getObject<T extends Record<string, any>>(key: string, defaultValue?: T): T;

// @public
function getOSType(): 'windows' | 'macos' | 'linux' | 'unknown';

// @public
function getRelativeTime(date: Date | number | string, options?: RelativeTimeOptions): string;

// @public
function getResourceUsage(): Promise<ResourceUsage | null>;

// @public
function getType(value: unknown): string;

// @public
function groupBy<T>(array: T[], iteratee: ((item: T) => any) | string): Record<string, T[]>;

// @public
function has(object: any, path: string | string[]): boolean;

// @public
function hasContextValue<T extends Record<string, any>>(context: Context<T>, key: keyof T): boolean;

// @public
function hasEnv(key: string): boolean;

// @public
function identity<T>(value: T): T;

// @public
function immutableDeepMerge<T extends Record<string, any>>(target: T, source: Record<string, any>): T;

// @public
function immutableDelete<T extends Record<string, any>>(obj: T, path: Path): T;

// @public
function immutableMerge<T extends Record<string, any>>(target: T, source: Record<string, any>): T;

// @public
function immutablePop<T>(array: T[]): T[];

// @public
function immutablePush<T>(array: T[], ...elements: T[]): T[];

// @public
function immutableReverse<T>(array: T[]): T[];

// @public
function immutableSet<T extends Record<string, any>>(obj: T, path: Path, value: any): T;

// @public
function immutableShift<T>(array: T[]): T[];

// @public
function immutableSort<T>(array: T[], compareFn?: (a: T, b: T) => number): T[];

// @public
function immutableSplice<T>(array: T[], start: number, deleteCount: number, ...items: T[]): T[];

// @public
function immutableUnshift<T>(array: T[], ...elements: T[]): T[];

// @public
function immutableUpdate<T extends Record<string, any>>(obj: T, path: Path, updater: (value: any) => any): T;

// @public
function inRange(number: number, start: number, end?: number): boolean;

// @public
function intersection<T>(...arrays: T[][]): T[];

// @public
function isAfter(date: Date | number | string, dateToCompare: Date | number | string): boolean;

// @public
function isAlpha(value: string, locale?: string): boolean;

// @public
function isAlphanumeric(value: string, locale?: string): boolean;

// @public
function isArray(value: unknown): value is unknown[];

// @public
function isBase64(value: string): boolean;

// @public
function isBefore(date: Date | number | string, dateToCompare: Date | number | string): boolean;

// @public
function isBoolean(value: unknown): value is boolean;

// @public
function isBrowser(): boolean;

// @public
function isDate(value: unknown): value is Date;

// @public
function isDevelopment(): boolean;

// Warning: (ae-forgotten-export) The symbol "EmailOptions" needs to be exported by the entry point index.d.ts
//
// @public
function isEmail(value: string, options?: EmailOptions): boolean;

// @public
function isEmpty(value: unknown): boolean;

// @public
function isEqual(value: unknown, other: unknown): boolean;

// @public
function isError(value: unknown): value is Error;

// @public
function isFiniteNumber(value: unknown): value is number;

// @public
function isFloat(value: any): boolean;

// @public
function isFunction(value: unknown): value is Function;

// @public
function isHexadecimal(value: string): boolean;

// @public
function isInstanceOf<T>(value: unknown, constructor: new (...args: any[]) => T): value is T;

// @public
function isInteger(value: any): boolean;

// @public
function isIP(value: string, version?: 4 | 6): boolean;

// @public
function isJSON(value: string): boolean;

// @public
function isNil(value: unknown): value is null | undefined;

// @public
function isNode(): boolean;

// @public
function isNotEmpty(value: unknown): boolean;

// @public
function isNull(value: unknown): value is null;

// @public
function isNumber(value: unknown): value is number;

// @public
function isNumeric(value: string): boolean;

// @public
function isObject(value: unknown): value is Record<string, any>;

// @public
function isolateContext<T extends Record<string, any>>(context: Context<T>, initialOverrides?: Partial<T>): Context<T>;

// @public
function isPhoneNumber(value: string, locale?: string): boolean;

// @public
function isPlainObject(value: unknown): value is Record<string, unknown>;

// @public
function isProduction(): boolean;

// @public
function isPromise(value: unknown): value is Promise<unknown>;

// @public
function isRegExp(value: unknown): value is RegExp;

// @public
function isSameDay(dateLeft: Date | number | string, dateRight: Date | number | string): boolean;

// @public
function isSameMonth(dateLeft: Date | number | string, dateRight: Date | number | string): boolean;

// @public
function isSameYear(dateLeft: Date | number | string, dateRight: Date | number | string): boolean;

// @public
function isSSR(): boolean;

// @public
function isString(value: unknown): value is string;

// Warning: (ae-forgotten-export) The symbol "PasswordOptions" needs to be exported by the entry point index.d.ts
//
// @public
function isStrongPassword(value: string, options?: PasswordOptions): boolean;

// @public
function isTest(): boolean;

// @public
function isUndefined(value: unknown): value is undefined;

// Warning: (ae-forgotten-export) The symbol "URLOptions" needs to be exported by the entry point index.d.ts
//
// @public
function isURL(value: string, options?: URLOptions): boolean;

// @public @deprecated
function isUrl(value: string): boolean;

// @public
function isUUID(value: string, version?: 3 | 4 | 5 | 'all'): boolean;

// @public
function isValid(date: any): boolean;

// @public
function isValidJSON(jsonString: string): boolean;

// @public
function isWebWorker(): boolean;

declare namespace json {
    export {
        serialize,
        serializeCompact,
        serializePretty,
        serializeSafe,
        SerializeOptions,
        SerializeResult,
        isValidJSON,
        parse,
        parseSafe,
        tryParse,
        ParseOptions,
        ParseResult,
        SerializeOptions as BasicSerializeOptions,
        SerializeResult as BasicSerializeResult,
        ParseOptions as BasicParseOptions,
        ParseResult as BasicParseResult,
        enhancedDeserialize,
        enhancedSerialize,
        safeMerge,
        EnhancedDeserializeOptions,
        EnhancedSerializeOptions,
        EnhancedSerializeResult
    }
}

// @public
function kebabCase(string: string): string;

// @public
function keyBy<T>(array: T[], iteratee: ((item: T) => any) | string): Record<string, T>;

// @public
function keys<T extends object>(object: T): Array<keyof T>;

// @public
function limitConcurrency<T, A extends any[]>(fn: (...args: A) => Promise<T>, maxConcurrent: number): (...args: A) => Promise<T>;

// @public
function load(options?: {
    path?: string;
    override?: boolean;
    silent?: boolean;
}): void;

// @public
function mapKeys<T extends object, K extends string | number | symbol>(object: T, iteratee: (key: string, value: T[keyof T], object: T) => K): Record<K, T[keyof T]>;

// @public
function mapValues<T extends object, R>(object: T, iteratee: (value: T[keyof T], key: string, object: T) => R): Record<keyof T, R>;

// @public
function max(array: number[]): number;

// @public
function measure<T>(fn: () => T, label?: string): T;

// @public
function memoize<F extends (...args: any[]) => any>(func: F, resolver?: (...args: any[]) => string): F & {
    cache: Map<string, any>;
};

// @public
interface MemoryUsage {
    arrayBuffers?: number;
    external?: number;
    heapTotal: number;
    heapUsed: number;
    rss: number;
}

declare namespace merge {
    export {
        assign,
        defaults,
        deepClone,
        deepMerge
    }
}

// @public
interface MergeContextOptions {
    override?: 'first' | 'last' | 'error';
    prefix?: boolean;
}

// @public
function mergeContexts<T extends Record<string, any>>(contexts: Context<any>[], options?: MergeContextOptions): Context<T>;

// @public
function min(array: number[]): number;

// @public
function monitorPerformance(callback: (usage: ResourceUsage) => void, interval?: number): {
    stop: () => void;
};

// @public
interface NamespaceContext<T extends Record<string, any>> extends Context<T> {
    readonly name: string;
}

// @public
function negate<T extends (...args: any[]) => boolean>(func: T): (...args: Parameters<T>) => boolean;

// @public
function nextTick(callback: () => void): void;

// @public
function noop(): undefined;

// @public
function now(): number;

declare namespace number {
    export {
        ceil,
        floor,
        formatNumber,
        round,
        toFixed,
        FormatNumberOptions,
        average,
        max,
        min,
        sum,
        isFloat,
        isInteger,
        isFiniteNumber as isNumber,
        clamp,
        inRange,
        random
    }
}

declare namespace object {
    export {
        isObject,
        get,
        has,
        set,
        keys,
        values,
        entries,
        fromEntries,
        mapKeys,
        mapValues,
        transform
    }
}

// @public
function omit<T extends object, K extends keyof T>(object: T, paths: K[]): Omit<T, K>;

// @public
function once<T extends (...args: any[]) => any>(fn: T): T;

// @public
function padEnd(str: string, length: number, chars?: string): string;

// @public
function padStart(str: string, length: number, chars?: string): string;

// @public
function parallelLimit<T>(tasks: Array<() => Promise<T>>, limit: number): Promise<T[]>;

// @public
function parse<T = any>(jsonString: string, options?: ParseOptions): ParseResult<T>;

// @public
function parse_2(dateStr: string, formatStr: string, referenceDate?: Date, options?: ParseOptions_2): Date;

// @public
interface ParseOptions {
    reviveDates?: boolean;
    reviver?: (key: string, value: any) => any;
    reviveRegExp?: boolean;
}

// @public
interface ParseOptions_2 {
    locale?: string;
    weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6;
}

// @public
interface ParseResult<T = any> {
    data?: T;
    error?: string;
    success: boolean;
}

// @public
function parseSafe<T = any>(jsonString: string, defaultValue: T, options?: ParseOptions): T;

// @public
function partial<T extends (...args: any[]) => any>(func: T, ...partials: any[]): (...args: any[]) => ReturnType<T>;

// @public
function partition<T>(array: T[], predicate: (item: T) => boolean): [T[], T[]];

// @public
function pascalCase(string: string): string;

// @public
type Path = string | number | (string | number)[];

declare namespace performance_2 {
    export {
        benchmark,
        measure,
        profileFn,
        timer,
        BenchmarkResult,
        nextTick,
        rAF,
        getCPUUsage,
        getMemoryUsage,
        getResourceUsage,
        monitorPerformance,
        CPUUsage,
        MemoryUsage,
        ResourceUsage,
        asyncCache,
        AsyncCacheOptions,
        batch,
        BatchOptions,
        profile
    }
}

// @public
function pick<T extends object, K extends keyof T>(object: T, paths: K[]): Pick<T, K>;

// @public
function pipe<R>(...fns: AnyFn[]): AnyFn;

// @public
function pipeAsync<T = any, R = any>(...fns: Array<(arg: any) => any | Promise<any>>): (arg: T) => Promise<R>;

// @public
function pluralize(str: string): string;

// @public
function pMap<T, R>(array: T[], mapper: (item: T, index: number, array: T[]) => Promise<R>, options?: PMapOptions): Promise<R[]>;

// @public
interface PMapOptions {
    concurrency?: number;
}

// @public
function produce<T>(baseState: T, recipe: (draft: T) => void): T;

// @public
function profile<T>(fn: () => T, label?: string): T;

// @public
function profileFn<T>(fn: () => T, label?: string): T;

// @public
type PromisifiedObject<T> = {
    [K in keyof T]: T[K] extends (...args: any[]) => void ? (...args: Parameters<T[K]> extends [...infer P, Function] ? P : never) => Promise<any> : T[K];
} & {
    [K in keyof T as `${string & K}Async`]?: (...args: any[]) => Promise<any>;
};

// @public
function promisify<T = any>(fn: (...args: any[]) => void): (...args: any[]) => Promise<T>;

// @public
function promisifyAll<T extends Record<string, any>>(target: T, methods?: (keyof T)[]): PromisifiedObject<T>;

// @public
interface Queue<T, R> {
    clear(): void;
    drain(): Promise<void>;
    pause(): void;
    push(task: T): Promise<R>;
    pushAll(tasks: T[]): Promise<R>[];
    resume(): void;
    size(): number;
}

// @public
function queue<T, R>(worker: (task: T) => Promise<R>, concurrency?: number): Queue<T, R>;

// @public
function rAF(callback: (timestamp: number) => void): {
    cancel: () => void;
};

// @public
function random(lower?: number, upper?: number, floating?: boolean): number;

// @public
function reduce<T, R>(array: T[], iteratee: (accumulator: R, current: T, index: number, array: T[]) => R, initialValue: R): R;

// @public
interface RelativeTimeOptions {
    locale?: string;
    now?: Date | number | string;
}

// @public
function removeContextValue<T extends Record<string, any>>(context: Context<T>, key: keyof T): void;

// @public
function required(key: string, message?: string): string;

// @public
interface ResourceUsage {
    cpu: CPUUsage;
    memory: MemoryUsage;
}

// @public
function retry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>;

// @public
interface RetryOptions {
    delay?: number;
    onRetry?: (error: Error, attempt: number) => void;
    retries?: number;
    shouldRetry?: (error: Error) => boolean;
}

// @public
function round(number: number, precision?: number): number;

// @public
function safeExecute<T, D = undefined>(fn: () => T, defaultValue?: D): T | D;

// @public
function safeExecuteAsync<T, D = undefined>(fn: () => Promise<T>, defaultValue?: D): Promise<T | D>;

// @public
function safeGet<T = any, D = undefined>(obj: any, path: string | Array<string>, defaultValue?: D): T | D;

// @public
function safeJsonParse<T = any, D = undefined>(json: string, defaultValue?: D): T | D;

// @public
function safeMerge<T>(target: T, ...sources: any[]): T;

declare namespace select {
    export {
        pick,
        omit
    }
}

// @public
function serialize(value: any, options?: SerializeOptions): SerializeResult;

// @public
function serializeCompact(value: any, options?: Omit<SerializeOptions, 'indent'>): SerializeResult;

// @public
interface SerializeOptions {
    convertDates?: boolean;
    convertRegExp?: boolean;
    includeUndefined?: boolean;
    indent?: number;
    removeNull?: boolean;
    replacer?: (key: string, value: any) => any;
}

// @public
function serializePretty(value: any, indent?: number, options?: Omit<SerializeOptions, 'indent'>): SerializeResult;

// @public
interface SerializeResult {
    data?: string;
    error?: string;
    success: boolean;
}

// @public
function serializeSafe(value: any, options?: SerializeOptions): SerializeResult;

// @public
function set<T extends Record<string, any>>(object: T, path: string | string[], value: any): T;

// @public
function set_2(key: string, value: string): void;

// @public
function setContextValue<T extends Record<string, any>, K extends keyof T>(context: Context<T>, key: K, value: T[K]): void;

// @public
function shuffle<T>(array: T[]): T[];

// @public
function singularize(str: string): string;

// @public
function sleep(ms: number): Promise<void>;

// @public
function snakeCase(string: string): string;

// @public
function sortBy<T>(array: T[], iteratees: Array<((item: T) => any) | string> | ((item: T) => any) | string): T[];

// @public
function startOfDay(date: Date | number | string): Date;

// @public
function startOfMonth(date: Date | number | string): Date;

// @public
function startOfYear(date: Date | number | string): Date;

// @public
function startsWith(str: string, target: string, position?: number): boolean;

declare namespace string {
    export {
        camelCase,
        kebabCase,
        pascalCase,
        snakeCase,
        escape_2 as escape,
        format,
        template,
        truncate,
        unescape_2 as unescape,
        pluralize,
        singularize,
        capitalize,
        capitalizeAll,
        endsWith,
        padEnd,
        padStart,
        startsWith,
        toLowerCase,
        toUpperCase,
        trim
    }
}

// @public
function sum(array: number[]): number;

// @public
function supportsCSS(property: string): boolean;

// @public
function supportsWebAPI(apiName: string): boolean;

// @public
function take<T>(array: T[], n?: number): T[];

// @public
function template(str: string, values: Record<string, any>): string;

// @public
function throttle<F extends (...args: any[]) => any>(func: F, wait?: number, options?: ThrottleOptions): F & {
    cancel(): void;
    flush(): ReturnType<F>;
    pending(): boolean;
};

// @public
interface ThrottleOptions extends BaseOptions {
}

declare namespace time {
    export {
        format_2 as format,
        parse_2 as parse,
        now,
        isValid,
        isAfter,
        isBefore,
        isSameDay,
        isSameMonth,
        isSameYear,
        addDays,
        addMonths,
        addYears,
        differenceInDays,
        differenceInMonths,
        differenceInYears,
        startOfDay,
        endOfDay,
        startOfMonth,
        endOfMonth,
        startOfYear,
        endOfYear,
        getRelativeTime,
        formatDuration,
        FormatOptions,
        ParseOptions_2 as ParseOptions,
        RelativeTimeOptions,
        FormatDurationOptions
    }
}

// @public
function timeout(ms: number, message?: string): Promise<never>;

// @public
function timer(label?: string): {
    stop: () => number;
};

// @public
function toArray<T>(value: T | T[] | null | undefined): T[];

// @public
function toBoolean(value: unknown): boolean;

// @public
function toDate(value: unknown): Date;

// @public
function toFixed(number: number, precision?: number, roundingMode?: 'round' | 'floor' | 'ceil'): string;

// @public
function toInteger(value: unknown): number;

// @public
function toLowerCase(str: string): string;

// @public
function toNumber(value: unknown): number;

// @public
function toObject(value: unknown): Record<string, unknown>;

// @public
function toString(value: unknown): string;

// @public
function toUpperCase(str: string): string;

// @public
function transform<T, R>(object: Record<string, any>, iteratee: (result: R, value: any, key: string, object: Record<string, any>) => void, accumulator: R): R;

// @public
function trim(str: string, chars?: string): string;

// @public
function truncate(str: string, options?: {
    length?: number;
    omission?: string;
    separator?: RegExp | string;
}): string;

// @public
function tryParse<T = any>(jsonString: string, options?: ParseOptions): [T | undefined, Error | undefined];

// @public
function typeGuard<T>(typeName: string): (value: unknown) => value is T;

// @public
function unary<T extends (...args: any[]) => any>(func: T): (arg: any) => ReturnType<T>;

// @public
function unescape_2(str: string): string;

// @public
function union<T>(...arrays: T[][]): T[];

// @public
function unique<T>(array: T[], iteratee?: ((item: T) => any) | string): T[];

// @public
function useContext<T extends Record<string, any>>(context: Context<T>): UseContextReturn<T>;

// @public
interface UseContextReturn<T extends Record<string, any>> {
    // (undocumented)
    clear: () => void;
    // (undocumented)
    get: <K extends keyof T>(key: K) => T[K];
    // (undocumented)
    getState: () => T;
    // (undocumented)
    has: (key: keyof T) => boolean;
    // (undocumented)
    remove: (key: keyof T) => void;
    // (undocumented)
    set: <K extends keyof T>(key: K, value: T[K]) => void;
    // (undocumented)
    subscribe: <K extends keyof T>(key: K, handler: (value: T[K], oldValue: T[K]) => void) => () => void;
}

// @public
function validate(value: any, rules: ValidationRule[]): ValidationResult;

// @public
function validateAll(values: Record<string, any>, rulesMap: Record<string, ValidationRule[]>): Record<string, ValidationResult>;

// @public
function validateObject(obj: Record<string, any>, rulesMap: Record<string, ValidationRule[]>): ValidationResult;

// Warning: (ae-forgotten-export) The symbol "JSONValidationResult" needs to be exported by the entry point index.d.ts
//
// @public
function validateWithSchema<T>(schema: JSONSchemaType<T>, data: unknown): JSONValidationResult<T>;

// @public
interface ValidationResult {
    errors: string[];
    valid: boolean;
}

// @public
interface ValidationRule {
    args?: any[];
    message: string;
    // Warning: (ae-forgotten-export) The symbol "ValidatorFn" needs to be exported by the entry point index.d.ts
    validator: ValidatorFn;
}

// @public
function values<T extends object>(object: T): Array<T[keyof T]>;

// @public
function waterfall<T = any>(tasks: Array<(arg?: any) => Promise<any>>): Promise<T>;

// @public
function withContext<T, C extends Record<string, any>>(context: Context<C>, fn: (ctx: ReturnType<typeof useContext<C>>) => T): T;

// @public
function withTimeout<T>(promise: Promise<T>, ms: number, message?: string): Promise<T>;

```
