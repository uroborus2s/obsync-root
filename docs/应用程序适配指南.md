# 应用程序适配指南

## 概述
由于MySQL 5兼容性修改，某些timestamp字段从`NOT NULL`改为`NULL DEFAULT NULL`，应用程序需要相应调整以正确处理这些字段。

## 主要变化

### 1. Timestamp字段变化
以下字段从`NOT NULL`改为`NULL DEFAULT NULL`：
- `completed_tasks.updated_at`
- `completed_tasks.completed_at`
- `icalink_attendance_records.updated_at`
- `icalink_leave_applications.updated_at`
- `icalink_schedule_mapping.updated_at`
- `icalink_sync_config.updated_at`
- `cookies.mtime`
- `information_lessons.mtime`

### 2. 保持不变的字段
以下字段仍然使用`DEFAULT CURRENT_TIMESTAMP`：
- 所有表的`created_at`字段
- `cookies.ctime`
- `information_lessons.ctime`

## 应用程序适配方案

### 方案1: 在INSERT时显式设置时间
```sql
-- 插入新记录时显式设置时间
INSERT INTO completed_tasks (
    id, name, task_type, status, 
    created_at, updated_at, completed_at
) VALUES (
    UUID(), '任务名称', 'sync', 'completed',
    NOW(), NOW(), NOW()
);
```

### 方案2: 使用触发器自动设置时间
```sql
-- 为completed_tasks表创建触发器
DELIMITER $$
CREATE TRIGGER tr_completed_tasks_insert 
BEFORE INSERT ON completed_tasks
FOR EACH ROW
BEGIN
    IF NEW.updated_at IS NULL THEN
        SET NEW.updated_at = NOW();
    END IF;
    IF NEW.completed_at IS NULL THEN
        SET NEW.completed_at = NOW();
    END IF;
END$$
DELIMITER ;
```

### 方案3: 在应用程序代码中处理

#### Node.js示例
```javascript
// 插入记录时自动设置时间字段
const insertCompletedTask = async (taskData) => {
    const now = new Date();
    const task = {
        ...taskData,
        created_at: now,
        updated_at: now,
        completed_at: taskData.completed_at || now
    };
    
    return await db.query(
        'INSERT INTO completed_tasks SET ?', 
        task
    );
};

// 更新记录时自动设置updated_at
const updateTask = async (id, updateData) => {
    const data = {
        ...updateData,
        updated_at: new Date()
    };
    
    return await db.query(
        'UPDATE completed_tasks SET ? WHERE id = ?', 
        [data, id]
    );
};
```

#### Python示例
```python
from datetime import datetime
import mysql.connector

def insert_completed_task(cursor, task_data):
    now = datetime.now()
    task_data.update({
        'created_at': now,
        'updated_at': now,
        'completed_at': task_data.get('completed_at', now)
    })
    
    columns = ', '.join(task_data.keys())
    placeholders = ', '.join(['%s'] * len(task_data))
    query = f"INSERT INTO completed_tasks ({columns}) VALUES ({placeholders})"
    
    cursor.execute(query, list(task_data.values()))

def update_task(cursor, task_id, update_data):
    update_data['updated_at'] = datetime.now()
    
    set_clause = ', '.join([f"{k} = %s" for k in update_data.keys()])
    query = f"UPDATE completed_tasks SET {set_clause} WHERE id = %s"
    
    cursor.execute(query, list(update_data.values()) + [task_id])
```

## 查询时的注意事项

### 1. 处理NULL值
```sql
-- 查询时处理可能的NULL值
SELECT 
    id,
    name,
    created_at,
    COALESCE(updated_at, created_at) as updated_at,
    COALESCE(completed_at, created_at) as completed_at
FROM completed_tasks;
```

### 2. 排序和过滤
```sql
-- 按更新时间排序，NULL值排在最后
SELECT * FROM completed_tasks 
ORDER BY updated_at IS NULL, updated_at DESC;

-- 过滤最近更新的记录
SELECT * FROM completed_tasks 
WHERE updated_at IS NOT NULL 
  AND updated_at > DATE_SUB(NOW(), INTERVAL 1 DAY);
```

## 数据迁移建议

### 1. 现有数据的时间字段更新
```sql
-- 为现有的NULL时间字段设置默认值
UPDATE completed_tasks 
SET updated_at = created_at 
WHERE updated_at IS NULL;

UPDATE completed_tasks 
SET completed_at = created_at 
WHERE completed_at IS NULL;
```

### 2. 批量数据处理
```sql
-- 批量更新，避免锁表时间过长
UPDATE completed_tasks 
SET updated_at = COALESCE(updated_at, created_at),
    completed_at = COALESCE(completed_at, created_at)
WHERE id IN (
    SELECT id FROM (
        SELECT id FROM completed_tasks 
        WHERE updated_at IS NULL OR completed_at IS NULL
        LIMIT 1000
    ) as tmp
);
```

## 最佳实践

1. **统一时间处理**: 在应用程序的数据访问层统一处理时间字段
2. **使用事务**: 确保时间字段的一致性
3. **添加验证**: 在应用程序中验证必要的时间字段不为空
4. **监控NULL值**: 定期检查是否有意外的NULL时间值
5. **文档更新**: 更新API文档，说明时间字段的新行为

## 回滚方案

如果需要回滚到原始的MySQL 8兼容版本：
1. 备份当前数据
2. 使用原始的`sql.sql`文件重建表结构
3. 迁移数据，确保时间字段不为NULL 