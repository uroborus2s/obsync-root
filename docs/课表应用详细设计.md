# 课表同步应用详细设计方案

## 1. 项目概述

### 1.1 项目背景
本项目旨在开发一个课表同步应用，将教育机构的课表数据智能转换为WPS协作应用中的各类应用数据，包括日程、打卡和审批流程，实现教学管理的数字化转型。通过该应用，教师和学生可以在WPS协作空间中查看自己的课程安排，完成课程签到，以及处理请假申请等任务。

### 1.2 目标用户
- **教师**：需要管理课程和查看课表的教职人员
- **学生**：需要了解课程安排并完成课程签到的学生
- **教务管理人员**：负责课程统筹和管理的工作人员

### 1.3 项目目标
1. 实现课表数据与WPS协作空间的日历、日程的无缝同步
2. 开发基于课表的学生考勤打卡系统
3. 建立学生请假的审批流程
4. 提供课程考勤数据的统计与分析功能
5. 满足教师、学生和教务人员的不同需求

## 2. 系统架构

### 2.1 总体架构

系统采用现代化的微服务架构，主要包含以下几个核心模块：

```
                      ┌────────────────┐
                      │    前端应用     │
                      └────────┬───────┘
                               │
                               ▼
┌────────────────┐     ┌────────────────┐     ┌────────────────┐
│  数据采集模块   │◄────►│   API网关层    │◄────►│ WPS集成模块    │
└────────┬───────┘     └────────┬───────┘     └────────────────┘
         │                      │
         ▼                      ▼
┌────────────────┐     ┌────────────────┐     ┌────────────────┐
│  数据转换模块   │◄────►│  业务逻辑层    │◄────►│ 数据分析模块   │
└────────────────┘     └────────┬───────┘     └────────────────┘
                               │
                               ▼
                      ┌────────────────┐
                      │    数据存储层   │
                      └────────────────┘
```

### 2.2 核心模块

1. **数据采集模块**
   - 负责从源数据库读取课表数据
   - 处理数据格式标准化
   - 数据验证与清洗
   - 增量同步机制

2. **数据转换模块**
   - 课表到日程的转换逻辑
   - 课表到打卡任务的转换逻辑
   - 课表到请假审批流程的转换逻辑
   - 数据映射规则管理

3. **业务逻辑层**
   - 课程管理逻辑
   - 考勤逻辑处理
   - 请假审批流程处理
   - 用户身份验证与授权

4. **WPS集成模块**
   - WPS日历/日程API集成
   - WPS打卡应用API集成
   - WPS审批流程API集成
   - WPS消息通知集成

5. **数据分析模块**
   - 考勤数据统计分析
   - 异常学生识别算法
   - 报表生成服务
   - 预警机制实现

6. **API网关层**
   - API路由管理
   - 请求限流与熔断
   - 安全认证与授权
   - 请求日志记录

7. **前端应用**
   - 教师端界面
   - 学生端界面
   - 教务管理端界面
   - 响应式设计适配多设备

8. **数据存储层**
   - 关系型数据库存储
   - 缓存服务
   - 文件存储服务
   - 数据备份与恢复

### 2.3 技术栈选择

| 层级 | 技术选择 |
|------|---------|
| 后端框架 | Node.js + Express/NestJS |
| 数据库 | MySQL/PostgreSQL + Knex.js |
| 缓存 | Redis |
| 消息队列 | RabbitMQ |
| API文档 | Swagger |
| 前端框架 | Vue.js/React |
| UI组件库 | Element UI/Ant Design |
| 部署环境 | Docker + Kubernetes |
| CI/CD | Jenkins/GitHub Actions |
| 监控 | Prometheus + Grafana | 

## 3. 数据模型设计

### 3.1 数据表结构

#### 3.1.1 源数据表

1. **课程安排表(kcb)**
```sql
CREATE TABLE `kcb` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `kkh` varchar(60) NOT NULL COMMENT '开课号',
  `xnxq` varchar(20) NOT NULL COMMENT '学年学期',
  `jxz` int(11) NOT NULL COMMENT '教学周1-18',
  `zc` int(11) NOT NULL COMMENT '周几1-7',
  `jc` int(11) NOT NULL COMMENT '节次1-10',
  `lq` varchar(200) DEFAULT NULL COMMENT '楼群',
  `room` varchar(200) DEFAULT NULL COMMENT '房间',
  `xq` varchar(100) DEFAULT NULL COMMENT '校区',
  `ghs` varchar(255) DEFAULT NULL COMMENT '教师工号组，逗号分割',
  `xms` varchar(500) DEFAULT NULL COMMENT '教师姓名组，逗号分割',
  `lx` varchar(10) DEFAULT NULL COMMENT '类型',
  `bz` varchar(255) DEFAULT NULL COMMENT '备注',
  `lc` varchar(255) DEFAULT NULL COMMENT '楼层',
  `rq` varchar(255) DEFAULT NULL COMMENT '日期',
  `st` varchar(255) DEFAULT NULL COMMENT '开始时间',
  `ed` varchar(255) DEFAULT NULL COMMENT '结束时间',
  `sj` varchar(255) DEFAULT NULL COMMENT '状态库时间标识',
  `zt` varchar(30) DEFAULT NULL COMMENT '状态标识：add、update、delete',
  `kcmc` varchar(200) DEFAULT NULL COMMENT '课程名称',
  `sfdk` smallint(6) DEFAULT 1 COMMENT '是否打卡0-1，有些课程仅给老师占位用',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_kkh` (`kkh`),
  KEY `idx_xnxq` (`xnxq`),
  KEY `idx_jxz_zc_jc` (`jxz`, `zc`, `jc`),
  KEY `idx_ghs` (`ghs`),
  KEY `idx_rq` (`rq`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程安排表';
```

2. **学生课表(xs_kb)**
```sql
CREATE TABLE `xs_kb` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `kkh` varchar(60) NOT NULL COMMENT '开课号',
  `xh` varchar(40) NOT NULL COMMENT '学生编号',
  `xnxq` varchar(20) NOT NULL COMMENT '学年学期',
  `kcbh` varchar(40) NOT NULL COMMENT '课程编号',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_kkh_xh` (`kkh`, `xh`),
  KEY `idx_xh` (`xh`),
  KEY `idx_xnxq` (`xnxq`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生课表';
```

#### 3.1.2 系统配置表

3. **系统配置表(sys_config)**
```sql
CREATE TABLE `sys_config` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `config_key` varchar(50) NOT NULL COMMENT '配置键',
  `config_value` text COMMENT '配置值',
  `config_desc` varchar(255) DEFAULT NULL COMMENT '配置描述',
  `config_group` varchar(50) DEFAULT NULL COMMENT '配置分组',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_config_key` (`config_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='系统配置表';
```

#### 3.1.3 课程表(动态生成)

4. **课程表(xq_kkh_{nnnnyydd})**

根据课程安排表和学生课表，为每门课程动态生成独立的课程表，表名格式为`xq_kkh_{nnnnyydd}`，其中nnnnyydd表示学年学期加开课号。

```sql
CREATE TABLE `xq_kkh_{nnnnyydd}` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `jxz` int(11) NOT NULL COMMENT '教学周1-18',
  `zc` int(11) NOT NULL COMMENT '周几1-7',
  `jc` int(11) NOT NULL COMMENT '节次1-10',
  `rq` date NOT NULL COMMENT '日期',
  `st` time NOT NULL COMMENT '开始时间',
  `ed` time NOT NULL COMMENT '结束时间',
  `room` varchar(200) DEFAULT NULL COMMENT '教室',
  `xq` varchar(100) DEFAULT NULL COMMENT '校区',
  `day_group_id` varchar(50) DEFAULT NULL COMMENT '日内分组ID',
  `day_period` varchar(10) DEFAULT NULL COMMENT '半天时段:morning/afternoon/evening',
  `is_first_class_of_day` tinyint(1) DEFAULT 0 COMMENT '是否为当天第一节课',
  `is_first_in_period` tinyint(1) DEFAULT 0 COMMENT '是否为半天时段内第一节课',
  `is_notify` tinyint(1) DEFAULT 0 COMMENT '是否需要提醒',
  `is_punch` tinyint(1) DEFAULT 0 COMMENT '是否需要打卡',
  `wps_schedule_id` varchar(100) DEFAULT NULL COMMENT 'WPS日程ID',
  `sync_status` tinyint(4) DEFAULT 0 COMMENT '同步状态',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_jxz_zc_jc` (`jxz`, `zc`, `jc`),
  KEY `idx_rq` (`rq`),
  KEY `idx_day_group` (`day_group_id`),
  KEY `idx_day_period` (`day_period`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程表';
```

#### 3.1.4 考勤表(动态生成)

5. **考勤表(kq_xq_kkh_{nnnnyydd})**

根据课程表，为每门课程动态生成独立的考勤表，表名格式为`kq_xq_kkh_{nnnnyydd}`。

```sql
CREATE TABLE `kq_xq_kkh_{nnnnyydd}` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `xh` varchar(40) NOT NULL COMMENT '学生学号',
  `course_record_id` int(11) NOT NULL COMMENT '关联课程表记录ID',
  `day_group_id` varchar(50) DEFAULT NULL COMMENT '日内分组ID',
  `punch_status` tinyint(4) DEFAULT 0 COMMENT '打卡状态：0-未打卡 1-已打卡 2-请假',
  `punch_time` datetime DEFAULT NULL COMMENT '打卡时间',
  `punch_location` varchar(255) DEFAULT NULL COMMENT '打卡位置',
  `is_first_class` tinyint(1) DEFAULT 0 COMMENT '是否为分组内第一节课',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_xh_course_record` (`xh`, `course_record_id`),
  KEY `idx_xh` (`xh`),
  KEY `idx_punch_status` (`punch_status`),
  KEY `idx_day_group` (`day_group_id`),
  KEY `fk_course_record` (`course_record_id`),
  CONSTRAINT `fk_course_record` FOREIGN KEY (`course_record_id`) REFERENCES `xq_kkh_{nnnnyydd}` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='考勤表';
```

#### 3.1.5 考勤聚合表

6. **考勤聚合表(attendance_summary)**
```sql
CREATE TABLE `attendance_summary` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `xh` varchar(40) NOT NULL COMMENT '学生学号',
  `kkh` varchar(60) NOT NULL COMMENT '开课号',
  `xnxq` varchar(20) NOT NULL COMMENT '学年学期',
  `zc` int(11) NOT NULL COMMENT '周几',
  `jc` int(11) NOT NULL COMMENT '节次',
  `jxz_list` varchar(255) NOT NULL COMMENT '教学周列表，逗号分隔',
  `punch_status_list` varchar(255) NOT NULL COMMENT '打卡状态列表，对应jxz_list',
  `total_classes` int(11) DEFAULT 0 COMMENT '总课程数',
  `punched_count` int(11) DEFAULT 0 COMMENT '已打卡次数',
  `leave_count` int(11) DEFAULT 0 COMMENT '请假次数',
  `absent_count` int(11) DEFAULT 0 COMMENT '缺勤次数',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_unique_summary` (`xh`, `kkh`, `xnxq`, `zc`, `jc`),
  KEY `idx_xh_kkh` (`xh`, `kkh`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='考勤聚合表';
```

#### 3.1.6 课程日内分组表

7. **课程日内分组表(course_day_group)**
```sql
CREATE TABLE `course_day_group` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `kkh` varchar(60) NOT NULL COMMENT '开课号',
  `xnxq` varchar(20) NOT NULL COMMENT '学年学期',
  `rq` date NOT NULL COMMENT '日期',
  `day_group_id` varchar(50) NOT NULL COMMENT '日内分组ID',
  `day_period` varchar(10) NOT NULL COMMENT '半天时段:morning/afternoon/evening',
  `jc_list` varchar(255) NOT NULL COMMENT '节次列表，逗号分隔',
  `jxz` int(11) NOT NULL COMMENT '教学周',
  `zc` int(11) NOT NULL COMMENT '周几',
  `first_jc` int(11) NOT NULL COMMENT '分组中第一节课',
  `first_course_record_id` int(11) DEFAULT NULL COMMENT '半天时段第一节课的课程记录ID',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_day_group` (`kkh`, `xnxq`, `rq`, `day_period`),
  KEY `idx_kkh_date` (`kkh`, `rq`),
  KEY `idx_day_period` (`day_period`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程日内分组表';
```

#### 3.1.7 请假记录表

8. **请假记录表(leave_record)**
```sql
CREATE TABLE `leave_record` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `xh` varchar(40) NOT NULL COMMENT '学生学号',
  `kkh` varchar(60) NOT NULL COMMENT '开课号',
  `xnxq` varchar(20) NOT NULL COMMENT '学年学期',
  `leave_type` tinyint(4) NOT NULL COMMENT '请假类型：1-病假 2-事假 3-其他',
  `start_time` datetime NOT NULL COMMENT '请假开始时间',
  `end_time` datetime NOT NULL COMMENT '请假结束时间',
  `reason` text NOT NULL COMMENT '请假原因',
  `attachment_url` varchar(255) DEFAULT NULL COMMENT '附件URL',
  `approval_status` tinyint(4) DEFAULT 0 COMMENT '审批状态：0-待审批 1-已批准 2-已拒绝',
  `approval_time` datetime DEFAULT NULL COMMENT '审批时间',
  `approval_comment` text DEFAULT NULL COMMENT '审批意见',
  `approver_id` varchar(60) DEFAULT NULL COMMENT '审批人ID',
  `wps_approval_id` varchar(100) DEFAULT NULL COMMENT 'WPS审批流程ID',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_xh` (`xh`),
  KEY `idx_kkh` (`kkh`),
  KEY `idx_approval_status` (`approval_status`),
  KEY `idx_time_range` (`start_time`, `end_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='请假记录表';
```

9. **请假课程关联表(leave_course_relation)**
```sql
CREATE TABLE `leave_course_relation` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `leave_id` int(11) NOT NULL COMMENT '请假记录ID',
  `kkh` varchar(60) NOT NULL COMMENT '开课号',
  `xnxq` varchar(20) NOT NULL COMMENT '学年学期',
  `course_record_id` int(11) NOT NULL COMMENT '关联课程表记录ID',
  `day_group_id` varchar(50) DEFAULT NULL COMMENT '日内分组ID',
  `is_first_class` tinyint(1) DEFAULT 0 COMMENT '是否为分组内第一节课',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_leave_id` (`leave_id`),
  KEY `idx_course_record` (`course_record_id`),
  KEY `idx_day_group` (`day_group_id`),
  CONSTRAINT `fk_course_record_leave` FOREIGN KEY (`course_record_id`) REFERENCES `xq_kkh_{nnnnyydd}` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='请假课程关联表';
```

#### 3.1.8 日程同步记录表

10. **日程同步记录表(schedule_sync_log)**
```sql
CREATE TABLE `schedule_sync_log` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `sync_type` varchar(20) NOT NULL COMMENT '同步类型：teacher/student',
  `target_id` varchar(60) NOT NULL COMMENT '目标ID：教师工号/学生学号',
  `kkh` varchar(60) NOT NULL COMMENT '开课号',
  `xnxq` varchar(20) NOT NULL COMMENT '学年学期',
  `jxz` int(11) NOT NULL COMMENT '教学周',
  `zc` int(11) NOT NULL COMMENT '周几',
  `jc` int(11) NOT NULL COMMENT '节次',
  `day_group_id` varchar(50) DEFAULT NULL COMMENT '日内分组ID',
  `wps_schedule_id` varchar(100) DEFAULT NULL COMMENT 'WPS日程ID',
  `sync_status` tinyint(4) DEFAULT 0 COMMENT '同步状态：0-未同步 1-同步成功 2-同步失败',
  `error_msg` text DEFAULT NULL COMMENT '错误信息',
  `retry_count` int(11) DEFAULT 0 COMMENT '重试次数',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_unique_schedule` (`sync_type`, `target_id`, `kkh`, `xnxq`, `jxz`, `zc`, `jc`),
  KEY `idx_target_id` (`target_id`),
  KEY `idx_sync_status` (`sync_status`),
  KEY `idx_day_group` (`day_group_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='日程同步记录表';
```

#### 3.1.9 用户相关表

11. **用户表(user)**
```sql
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` varchar(60) NOT NULL COMMENT '用户ID：教师工号/学生学号',
  `user_type` varchar(20) NOT NULL COMMENT '用户类型：teacher/student/admin',
  `user_name` varchar(100) NOT NULL COMMENT '用户姓名',
  `wps_user_id` varchar(100) DEFAULT NULL COMMENT 'WPS用户ID',
  `email` varchar(100) DEFAULT NULL COMMENT '邮箱',
  `phone` varchar(20) DEFAULT NULL COMMENT '手机号',
  `department` varchar(100) DEFAULT NULL COMMENT '部门/院系',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_user_id_type` (`user_id`, `user_type`),
  KEY `idx_wps_user_id` (`wps_user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

### 3.2 数据表结构说明

#### 3.2.1 表设计思路

1. **课程表独立化**:
   - 每门课程创建一个独立的表，表名格式为`xq_kkh_{nnnnyydd}`
   - 通过 xnxq + kkh 两个字段确定表名
   - 这种设计提高了单课程数据查询效率
   - 避免大表性能问题

2. **考勤表独立化**:
   - 每门课程创建一个独立的考勤表，表名格式为`kq_xq_kkh_{nnnnyydd}`
   - 关联对应的课程表
   - 预制本学期所有需要打卡的信息
   - 设计默认未打卡状态，支持打卡和请假状态更新

3. **日内分组机制**:
   - 通过`course_day_group`表管理同一天内连续课程的分组
   - 使用`day_group_id`字段关联同组课程
   - 标记组内第一节课，只有第一节课需要打卡和日程提醒

4. **聚合表设计**:
   - `attendance_summary`表用于统计和分析需求
   - 预聚合减轻查询压力
   - 支持多维度统计分析

### 3.3 核心业务逻辑

#### 3.3.1 课程表与考勤表生成流程

1. **课程表生成逻辑**:
   ```
   对于每个 xnxq + kkh 组合:
     1. 创建课程表 xq_kkh_{nnnnyydd}
     2. 从源表 kcb 中提取该课程数据
     3. 设置日内分组信息:
        - 对同一天连续节次课程进行分组
        - 标记每个分组的第一节课
     4. 将处理后的数据插入课程表
   ```

2. **考勤表生成逻辑**:
   ```
   对于每个课程表 xq_kkh_{nnnnyydd}:
     1. 创建考勤表 kq_xq_kkh_{nnnnyydd}
     2. 从学生课表 xs_kb 获取该课程的学生名单
     3. 对每个学生:
        - 提取课程表中所有记录
        - 为每节课创建考勤记录(默认未打卡)
        - 标记分组内第一节课
     4. 将生成的考勤记录插入考勤表
   ```

#### 3.3.2 日内分组逻辑

1. **半天分组规则**:
   ```
   对于每个 kkh, xnxq, rq:
     1. 获取当天所有课程记录，按jc排序
     2. 按照半天时段进行分组:
        - 上午时段: 例如1-4节
        - 下午时段: 例如5-8节
        - 晚上时段: 例如9-12节
     3. 对每个半天时段内的课程:
        - 生成独立的day_group_id，格式为"{kkh}_{rq}_{am/pm/night}"
        - 记录每个半天分组的第一节课
        - 将分组信息写入course_day_group表
   ```

2. **课程打卡与提醒处理**:
   ```
   根据半天分组规则:
     1. 同一门课程在同一半天内只打一次卡:
        - 每个半天时段内的第一节课设置为需要打卡(is_punch=1)
        - 同一半天内的其他课程不需要单独打卡(is_punch=0)
     
     2. 日程提醒同样采用半天分组:
        - 每个半天时段内的第一节课设置提醒(is_notify=1)
        - 同一半天内的其他课程不设置提醒(is_notify=0)
     
     3. 处理特殊情况:
        - 如果半天内只有一节课，则该课设置为需要打卡和提醒
        - 如果同一门课在不同半天都有课程，则每个半天的第一节课都需要打卡和提醒
   ```

3. **半天时段配置**:
   ```
   在系统配置表(sys_config)中设置半天划分配置:
   
   INSERT INTO `sys_config` (`config_key`, `config_value`, `config_desc`, `config_group`) VALUES
   ('morning_periods', '1,2,3,4', '上午课节范围', 'period_group'),
   ('afternoon_periods', '5,6,7,8', '下午课节范围', 'period_group'),
   ('evening_periods', '9,10,11,12', '晚上课节范围', 'period_group');
   ```

#### 3.3.3 打卡与请假处理

1. **打卡处理逻辑**:
   ```
   接收打卡请求(kkh, xnxq, jxz, zc, jc, xh):
     1. 定位到对应的课程表 xq_kkh_{nnnnyydd} 和课程记录id
     2. 在考勤表 kq_xq_kkh_{nnnnyydd} 中查询该学生对应课程记录的考勤信息
     3. 获取课程的day_group_id，确定所属半天分组
     4. 验证该课程是否为当前半天分组的第一节课:
        - 如果是分组内第一节课(is_first_class=1):
          · 更新该条记录的punch_status为已打卡(1)
          · 查询同一day_group_id(同一半天同一门课)的所有考勤记录
          · 将这些记录的punch_status也更新为已打卡(1)
        - 如果不是分组内第一节课(is_first_class=0):
          · 查找同一半天分组的第一节课打卡状态
          · 如果第一节课已打卡，则更新当前记录为已打卡
          · 如果第一节课未打卡，则提示用户需要先为第一节课打卡
   ```

2. **请假处理逻辑**:
   ```
   接收请假请求(学生信息, 课程信息, 请假时间段, 请假原因):
     1. 创建请假记录，写入leave_record表
     2. 根据请假时间段，查找对应时间内的课程表记录
     3. 按半天分组处理请假申请:
        - 对所有涉及的课程按照day_group_id(半天分组)进行归类
        - 对于每个半天分组:
          · 记录该分组的所有课程信息
          · 特别标记该半天分组的第一节课
     4. 将请假课程信息写入leave_course_relation表:
        - 记录所有涉及的课程记录ID
        - 标记每条记录所属的半天分组ID
        - 标记每条记录是否为半天分组的第一节课
     5. 更新考勤表:
        - 对于每个半天分组，找到该分组内所有课程的考勤记录
        - 将这些考勤记录的状态更新为请假状态(2)
     6. 发起WPS审批流程
     7. 审批通过或拒绝时，统一处理整个半天分组的所有课程:
        - 审批通过: 确认所有涉及课程的考勤状态为请假(2)
        - 审批拒绝: 将所有涉及课程的考勤状态恢复为未打卡(0)
   ```

#### 3.3.4 统计分析处理

1. **考勤数据聚合**:
   ```
   定期执行聚合任务:
     1. 对于每个 xh, kkh, xnxq 组合:
        - 从课程表和考勤表中联合查询所有记录
        - 按课程表中的jxz, zc, jc字段分组
        - 汇总每个分组的打卡状态
        - 计算总课程数、已打卡次数、请假次数、缺勤次数
        - 将结果更新到attendance_summary表
   ```

   聚合SQL示例:
   ```sql
   INSERT INTO attendance_summary (xh, kkh, xnxq, zc, jc, jxz_list, punch_status_list, 
                                 total_classes, punched_count, leave_count, absent_count)
   SELECT 
     a.xh, 
     '{kkh}' AS kkh, 
     '{xnxq}' AS xnxq,
     b.zc,
     b.jc,
     GROUP_CONCAT(b.jxz ORDER BY b.jxz) AS jxz_list,
     GROUP_CONCAT(a.punch_status ORDER BY b.jxz) AS punch_status_list,
     COUNT(*) AS total_classes,
     SUM(CASE WHEN a.punch_status = 1 THEN 1 ELSE 0 END) AS punched_count,
     SUM(CASE WHEN a.punch_status = 2 THEN 1 ELSE 0 END) AS leave_count,
     SUM(CASE WHEN a.punch_status = 0 THEN 1 ELSE 0 END) AS absent_count
   FROM 
     `kq_xq_kkh_{nnnnyydd}` a
   JOIN 
     `xq_kkh_{nnnnyydd}` b ON a.course_record_id = b.id
   GROUP BY 
     a.xh, b.zc, b.jc
   ON DUPLICATE KEY UPDATE
     jxz_list = VALUES(jxz_list),
     punch_status_list = VALUES(punch_status_list),
     total_classes = VALUES(total_classes),
     punched_count = VALUES(punched_count),
     leave_count = VALUES(leave_count),
     absent_count = VALUES(absent_count);
   ```

2. **多维度统计查询**:
   ```
   1. 课程维度统计:
      - 某门课程的总出勤率
      - 某门课程各节课的出勤情况对比
      - 不同半天时段（上午/下午/晚上）的出勤率对比
   
   2. 学生维度统计:
      - 学生在所有课程的出勤率
      - 学生的请假次数和缺勤次数
      - 学生在不同半天时段的出勤情况分析
   
   3. 教师维度统计:
      - 教师所授课程的学生出勤情况
      - 各课程出勤率对比
      - 不同半天时段的学生出勤率对比

   4. 时段维度统计:
      - 按半天时段（上午/下午/晚上）统计整体出勤情况
      - 各半天时段请假率对比
      - 半天时段与课程性质关联分析
   ```

   统计SQL示例(按半天时段统计):
   ```sql
   SELECT
     b.day_period,
     COUNT(*) AS total_records,
     SUM(CASE WHEN a.punch_status = 1 THEN 1 ELSE 0 END) AS punched_count,
     SUM(CASE WHEN a.punch_status = 2 THEN 1 ELSE 0 END) AS leave_count,
     SUM(CASE WHEN a.punch_status = 0 THEN 1 ELSE 0 END) AS absent_count,
     ROUND(SUM(CASE WHEN a.punch_status = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) AS attendance_rate
   FROM
     `kq_xq_kkh_{nnnnyydd}` a
   JOIN
     `xq_kkh_{nnnnyydd}` b ON a.course_record_id = b.id
   GROUP BY
     b.day_period
   ORDER BY
     CASE
       WHEN b.day_period = 'morning' THEN 1
       WHEN b.day_period = 'afternoon' THEN 2
       WHEN b.day_period = 'evening' THEN 3
     END;
   ```

### 3.4 日程同步与WPS协作空间集成

1. **日程同步规则**:
   ```
   对于每个课程的日内分组:
     1. 将分组转换为一个WPS日程
     2. 日程标题使用课程名称
     3. 日程时间从第一节课开始时间到最后一节课结束时间
     4. 只为分组内第一节课设置提醒
     5. 记录日程同步状态到schedule_sync_log表
   ```

2. **提醒机制**:
   ```
   对于需要提醒的课程(is_notify=1):
     1. 根据配置的提前时间生成提醒设置
     2. 使用WPS消息通知API发送提醒
     3. 提醒内容包含课程名称、教室、教师等信息
   ```

### 3.5 数据更新与同步机制

1. **源数据变更处理**:
   ```
   监控源表(kcb, xs_kb)变更:
     1. 对于新增记录(zt=add):
        - 判断是否需要创建新的课程表
        - 如果是新课程，创建对应的课程表和考勤表
        - 更新已有课程表
        - 为涉及的学生生成考勤记录
     
     2. 对于更新记录(zt=update):
        - 更新对应课程表数据
        - 同步更新相关的日内分组信息
        - 对于考勤表，如果课程记录ID变更：
          · 获取原课程记录关联的所有考勤记录
          · 更新这些考勤记录关联到新的课程记录ID
     
     3. 对于删除记录(zt=delete):
        - 标记对应课程表记录为无效或直接删除
        - 关联的考勤记录会通过外键约束自动处理
   ```

2. **考勤记录新增处理**:
   ```
   新增学生选课记录(xs_kb):
     1. 对于每个新增的学生选课记录：
        - 获取对应课程表(xq_kkh_{nnnnyydd})中所有课程记录
        - 为每条课程记录创建对应的考勤记录
        - 设置考勤状态为默认未打卡
        - 记录日内分组信息和是否为分组首节课
   ```

3. **同步日志与监控**:
   ```
   记录所有同步操作:
     1. 源数据同步日志
     2. 考勤数据更新日志
     3. WPS日程同步日志
     4. 同步错误和异常记录
   
   监控同步状态:
     1. 跟踪未完成同步的记录
     2. 自动重试失败的同步任务
     3. 异常情况报警
   ```

## 4. 核心模块设计

### 4.1 数据采集模块

数据采集模块负责从源数据库中获取课表数据，处理数据格式标准化，进行数据验证与清洗，并实现增量同步机制。

#### 4.1.1 功能设计

1. **数据源接入**
   - 支持多种数据库类型的接入(MySQL, PostgreSQL等)
   - 支持API方式获取数据
   - 支持文件导入方式获取数据

2. **数据拉取策略**
   - 全量数据同步：用于系统初始化或数据重建
   - 增量数据同步：根据状态标识(zt)和时间标识(sj)获取变更数据
   - 定时同步：根据配置的时间间隔自动同步数据
   - 手动触发同步：管理员可手动触发数据同步

3. **数据验证与清洗**
   - 数据完整性验证：检查必填字段是否完整
   - 数据一致性验证：检查数据是否符合业务规则
   - 数据格式验证：检查日期、时间等格式是否正确
   - 数据清洗：处理异常字符、去除冗余空格等
   - 错误处理：记录验证失败的数据，生成错误报告

#### 4.1.2 核心接口设计

```javascript
/**
 * 数据采集服务接口
 */
interface IDataCollectionService {
  /**
   * 全量同步数据
   * @param options 同步选项
   * @returns 同步结果
   */
  syncAllData(options: SyncOptions): Promise<SyncResult>;
  
  /**
   * 增量同步数据
   * @param lastSyncTime 上次同步时间
   * @param options 同步选项
   * @returns 同步结果
   */
  syncIncrementalData(lastSyncTime: Date, options: SyncOptions): Promise<SyncResult>;
  
  /**
   * 验证数据有效性
   * @param data 待验证数据
   * @returns 验证结果
   */
  validateData(data: any[]): ValidationResult;
  
  /**
   * 清洗数据
   * @param data 原始数据
   * @returns 清洗后的数据
   */
  cleanData(data: any[]): any[];
  
  /**
   * 获取同步状态
   * @returns 同步状态信息
   */
  getSyncStatus(): Promise<SyncStatus>;
}

/**
 * 同步选项接口
 */
interface SyncOptions {
  targetTables: string[]; // 目标表，如['kcb', 'xs_kb']
  batchSize: number; // 批处理大小
  syncForTeacher: boolean; // 是否同步教师数据
  syncForStudent: boolean; // 是否同步学生数据
  xnxq?: string; // 可选的学年学期筛选
}

/**
 * 同步结果接口
 */
interface SyncResult {
  success: boolean; // 是否成功
  totalRecords: number; // 总记录数
  processedRecords: number; // 已处理记录数
  failedRecords: number; // 失败记录数
  errorDetails: any[]; // 错误详情
  startTime: Date; // 开始时间
  endTime: Date; // 结束时间
  elapsedTime: number; // 耗时(毫秒)
}
```

#### 4.1.3 数据同步流程

```
┌────────────────┐    ┌────────────────┐    ┌────────────────┐
│ 同步任务调度    │───>│  读取源数据     │───>│  数据验证      │
└────────────────┘    └────────────────┘    └───────┬────────┘
                                                    │
┌────────────────┐    ┌────────────────┐    ┌───────▼────────┐
│  结果记录       │<───│  数据存储       │<───│  数据清洗      │
└────────────────┘    └────────────────┘    └────────────────┘
```

### 4.2 数据转换模块

数据转换模块负责将课表数据转换为WPS协作空间中的日程、打卡和审批流程数据，实现数据格式的转换和映射。

#### 4.2.1 功能设计

1. **课表到日程的转换器**
   - 将课程信息转换为日程标准格式
   - 处理重复课程的日程规则
   - 设置日程提醒和通知
   - 处理日程的更新和删除

2. **课表到打卡任务的转换器**
   - 根据课表生成打卡任务
   - 设置打卡的有效时间范围
   - 处理连续课程的打卡规则
   - 管理打卡任务的状态和生命周期

3. **课表到审批流的转换器**
   - 创建请假审批流程模板
   - 设置审批流程的参与者和流转规则
   - 关联请假记录和课程信息
   - 处理审批结果的反馈

4. **数据映射规则管理**
   - 定义字段映射规则
   - 支持自定义转换逻辑
   - 管理转换规则的版本和更新

#### 4.2.2 核心接口设计

```javascript
/**
 * 数据转换服务接口
 */
interface IDataTransformService {
  /**
   * 课表转日程
   * @param courseData 课表数据
   * @param targetUser 目标用户
   * @returns 日程数据
   */
  transformToSchedule(courseData: any[], targetUser: UserInfo): Promise<ScheduleData[]>;
  
  /**
   * 课表转打卡任务
   * @param courseData 课表数据
   * @returns 打卡任务数据
   */
  transformToPunchTask(courseData: any[]): Promise<PunchTaskData[]>;
  
  /**
   * 课表转审批流程
   * @param courseData 课表数据
   * @returns 审批流程数据
   */
  transformToApprovalFlow(courseData: any[]): Promise<ApprovalFlowData[]>;
  
  /**
   * 获取字段映射规则
   * @param transformType 转换类型
   * @returns 映射规则
   */
  getMappingRules(transformType: string): Promise<MappingRule[]>;
  
  /**
   * 更新字段映射规则
   * @param transformType 转换类型
   * @param rules 映射规则
   * @returns 更新结果
   */
  updateMappingRules(transformType: string, rules: MappingRule[]): Promise<boolean>;
}
```

#### 4.2.3 转换规则设计

1. **课表到日程的转换规则**

```javascript
const courseToScheduleMapping = {
  // 日程标题
  title: (course) => `${course.kcmc}`,
  
  // 日程开始时间
  startTime: (course) => {
    // 根据jc(节次)和st(开始时间)计算具体开始时间
    return calculateStartTime(course.jxz, course.zc, course.jc, course.st);
  },
  
  // 日程结束时间
  endTime: (course) => {
    // 根据jc(节次)和ed(结束时间)计算具体结束时间
    return calculateEndTime(course.jxz, course.zc, course.jc, course.ed);
  },
  
  // 日程地点
  location: (course) => `${course.xq || ''} ${course.lq || ''} ${course.room || ''}`.trim(),
  
  // 日程描述
  description: (course) => {
    return `课程：${course.kcmc}\n` +
           `教师：${course.xms}\n` +
           `地点：${course.xq || ''} ${course.lq || ''} ${course.room || ''}\n` +
           `节次：第${course.jc}节\n` +
           `周次：第${course.jxz}周`;
  },
  
  // 重复规则
  repeatRule: (course) => {
    // 每周重复的规则
    return {
      frequency: 'weekly',
      interval: 1,
      dayOfWeek: [course.zc], // 1-7对应周一到周日
      startDate: calculateDateByWeek(course.jxz, course.zc),
      count: 1 // 只重复一次，因为每个教学周都会单独创建
    };
  },
  
  // 提醒设置
  reminders: (course) => {
    return [
      { minutes: 30 }, // 提前30分钟提醒
      { minutes: 5 }   // 提前5分钟提醒
    ];
  }
};
```

2. **课表到打卡任务的转换规则**

```javascript
const courseToPunchTaskMapping = {
  // 打卡任务名称
  taskName: (course) => `${course.kcmc}上课打卡`,
  
  // 打卡开始时间
  punchStartTime: (course) => {
    // 课前10分钟开始允许打卡
    const startTime = calculateStartTime(course.jxz, course.zc, course.jc, course.st);
    return subtractMinutes(startTime, 10);
  },
  
  // 打卡结束时间
  punchEndTime: (course) => {
    // 课后10分钟结束打卡
    const startTime = calculateStartTime(course.jxz, course.zc, course.jc, course.st);
    return addMinutes(startTime, 10);
  },
  
  // 是否要求位置打卡
  requireLocation: (course) => true,
  
  // 打卡参与人员
  participants: async (course) => {
    // 获取该课程的所有学生
    return await getStudentsByCourse(course.kkh, course.xnxq);
  },
  
  // 打卡说明
  description: (course) => {
    return `课程：${course.kcmc}\n` +
           `教师：${course.xms}\n` +
           `地点：${course.xq || ''} ${course.lq || ''} ${course.room || ''}\n` +
           `时间：${formatTime(course.st)} - ${formatTime(course.ed)}`;
  }
};
```

3. **请假审批流程转换规则**

```javascript
const leaveApprovalFlowMapping = {
  // 审批流程名称
  flowName: (course) => `${course.kcmc}请假审批`,
  
  // 审批流程描述
  description: (course) => `${course.kcmc}课程请假审批流程`,
  
  // 审批节点设计
  nodes: (course) => {
    return [
      {
        nodeName: '教师审批',
        approvers: course.ghs.split(',').map(gh => ({ type: 'teacher', id: gh })),
        approvalType: 'ANY', // 任一教师审批即可
        timeLimit: 24 // 24小时审批时限
      }
    ];
  },
  
  // 表单设计
  formDesign: (course) => {
    return {
      fields: [
        {
          fieldName: 'leaveType',
          fieldLabel: '请假类型',
          fieldType: 'select',
          options: [
            { label: '事假', value: 1 },
            { label: '病假', value: 2 },
            { label: '其他', value: 3 }
          ],
          required: true
        },
        {
          fieldName: 'startTime',
          fieldLabel: '开始时间',
          fieldType: 'datetime',
          required: true
        },
        {
          fieldName: 'endTime',
          fieldLabel: '结束时间',
          fieldType: 'datetime',
          required: true
        },
        {
          fieldName: 'reason',
          fieldLabel: '请假原因',
          fieldType: 'textarea',
          required: true
        },
        {
          fieldName: 'attachment',
          fieldLabel: '附件',
          fieldType: 'file',
          required: false
        }
      ]
    };
  }
};
``` 

## 5. WPS集成与业务逻辑层

### 5.1 WPS集成模块

WPS集成模块负责与WPS协作空间的API进行交互，包括日历/日程、打卡、审批流程和消息通知等功能的集成。

#### 5.1.1 功能设计

1. **WPS日历/日程API集成**
   - 创建和管理日历
   - 创建、更新和删除日程
   - 设置日程提醒和重复规则
   - 管理日历访问权限

2. **WPS打卡应用API集成**
   - 创建打卡任务
   - 管理打卡任务状态
   - 获取打卡记录
   - 生成打卡统计数据

3. **WPS审批流程API集成**
   - 创建审批流程模板
   - 发起审批流程
   - 获取审批状态和结果
   - 管理审批流程回调

4. **WPS消息通知集成**
   - 发送课程提醒通知
   - 发送打卡提醒通知
   - 发送审批流程通知
   - 接收消息回调

#### 5.1.2 核心接口设计

```javascript
/**
 * WPS日历服务接口
 */
interface IWpsCalendarService {
  /**
   * 创建日历
   * @param calendarData 日历数据
   * @returns 创建结果
   */
  createCalendar(calendarData: CalendarData): Promise<WpsCalendarResult>;
  
  /**
   * 创建日程
   * @param scheduleData 日程数据
   * @returns 创建结果
   */
  createSchedule(scheduleData: ScheduleData): Promise<WpsScheduleResult>;
  
  /**
   * 更新日程
   * @param scheduleId 日程ID
   * @param scheduleData 日程数据
   * @returns 更新结果
   */
  updateSchedule(scheduleId: string, scheduleData: ScheduleData): Promise<WpsScheduleResult>;
  
  /**
   * 删除日程
   * @param scheduleId 日程ID
   * @returns 删除结果
   */
  deleteSchedule(scheduleId: string): Promise<boolean>;
  
  /**
   * 批量创建日程
   * @param schedulesData 日程数据数组
   * @returns 批量创建结果
   */
  batchCreateSchedules(schedulesData: ScheduleData[]): Promise<WpsBatchResult>;
}

/**
 * WPS打卡服务接口
 */
interface IWpsPunchService {
  /**
   * 创建打卡任务
   * @param punchTaskData 打卡任务数据
   * @returns 创建结果
   */
  createPunchTask(punchTaskData: PunchTaskData): Promise<WpsPunchTaskResult>;
  
  /**
   * 更新打卡任务
   * @param taskId 任务ID
   * @param punchTaskData 打卡任务数据
   * @returns 更新结果
   */
  updatePunchTask(taskId: string, punchTaskData: PunchTaskData): Promise<WpsPunchTaskResult>;
  
  /**
   * 获取打卡记录
   * @param taskId 任务ID
   * @returns 打卡记录
   */
  getPunchRecords(taskId: string): Promise<PunchRecord[]>;
  
  /**
   * 手动修改打卡状态
   * @param userId 用户ID
   * @param taskId 任务ID
   * @param status 打卡状态
   * @returns 修改结果
   */
  modifyPunchStatus(userId: string, taskId: string, status: number): Promise<boolean>;
}

/**
 * WPS审批流程服务接口
 */
interface IWpsApprovalService {
  /**
   * 创建审批流程模板
   * @param templateData 模板数据
   * @returns 创建结果
   */
  createApprovalTemplate(templateData: ApprovalTemplateData): Promise<WpsTemplateResult>;
  
  /**
   * 发起审批流程
   * @param approvalData 审批数据
   * @returns 发起结果
   */
  createApprovalInstance(approvalData: ApprovalData): Promise<WpsApprovalResult>;
  
  /**
   * 获取审批状态
   * @param approvalId 审批ID
   * @returns 审批状态
   */
  getApprovalStatus(approvalId: string): Promise<ApprovalStatus>;
  
  /**
   * 审批流程回调处理
   * @param callbackData 回调数据
   * @returns 处理结果
   */
  handleApprovalCallback(callbackData: any): Promise<boolean>;
}

/**
 * WPS消息通知服务接口
 */
interface IWpsNotificationService {
  /**
   * 发送消息通知
   * @param targetUsers 目标用户
   * @param message 消息内容
   * @returns 发送结果
   */
  sendNotification(targetUsers: string[], message: NotificationMessage): Promise<WpsNotificationResult>;
  
  /**
   * 发送课程提醒
   * @param scheduleData 日程数据
   * @param targetUsers 目标用户
   * @returns 发送结果
   */
  sendScheduleReminder(scheduleData: ScheduleData, targetUsers: string[]): Promise<WpsNotificationResult>;
  
  /**
   * 发送打卡提醒
   * @param punchTaskData 打卡任务数据
   * @param targetUsers 目标用户
   * @returns 发送结果
   */
  sendPunchReminder(punchTaskData: PunchTaskData, targetUsers: string[]): Promise<WpsNotificationResult>;
}
```

#### 5.1.3 WPS API调用流程

1. **日程同步流程**

```
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│ 获取课表数据  │───>│ 转换为日程数据 │───>│ 检查日程是否 │
└──────┬───────┘    └──────┬───────┘    │  已存在      │
       │                   │            └──────┬───────┘
       │                   │                   │
       │            ┌──────▼───────┐    ┌──────▼───────┐
       └────────────│ 创建/更新日程 │<───│ 存在则更新   │
                    └──────┬───────┘    │ 不存在则创建 │
                           │            └──────────────┘
                           │
                    ┌──────▼───────┐
                    │ 记录同步状态  │
                    └──────────────┘
```

2. **打卡任务创建流程**

```
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│ 获取课表数据  │───>│转换为打卡任务 │───>│检查是否连续课│
└──────┬───────┘    └──────┬───────┘    └──────┬───────┘
       │                   │                   │
       │            ┌──────▼───────┐    ┌──────▼───────┐
       └────────────│创建打卡任务   │<───│若连续课仅创建│
                    └──────┬───────┘    │第一节打卡任务│
                           │            └──────────────┘
                           │
                    ┌──────▼───────┐
                    │记录任务状态   │
                    └──────────────┘
```

3. **请假审批流程**

```
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│ 学生发起请假  │───>│ 创建审批实例  │───>│ 通知相关教师 │
└──────┬───────┘    └──────┬───────┘    └──────┬───────┘
       │                   │                   │
       │            ┌──────▼───────┐    ┌──────▼───────┐
       └────────────│ 教师审批     │───>│ 更新请假状态 │
                    └──────┬───────┘    └──────┬───────┘
                           │                   │
                    ┌──────▼───────┐    ┌──────▼───────┐
                    │ 更新打卡记录  │───>│ 通知学生结果 │
                    └──────────────┘    └──────────────┘
```

### 5.2 业务逻辑层

业务逻辑层负责处理业务规则和流程，包括课程管理、考勤管理、请假管理和用户管理等。

#### 5.2.1 课程管理服务

```javascript
/**
 * 课程管理服务接口
 */
interface ICourseService {
  /**
   * 获取课程列表
   * @param query 查询条件
   * @returns 课程列表
   */
  getCourseList(query: CourseQuery): Promise<PaginatedResult<CourseInfo>>;
  
  /**
   * 获取课程详情
   * @param kkh 开课号
   * @returns 课程详情
   */
  getCourseDetail(kkh: string): Promise<CourseDetail>;
  
  /**
   * 获取教师课程
   * @param teacherId 教师ID
   * @param query 查询条件
   * @returns 课程列表
   */
  getTeacherCourses(teacherId: string, query: CourseQuery): Promise<PaginatedResult<CourseInfo>>;
  
  /**
   * 获取学生课程
   * @param studentId 学生ID
   * @param query 查询条件
   * @returns 课程列表
   */
  getStudentCourses(studentId: string, query: CourseQuery): Promise<PaginatedResult<CourseInfo>>;
  
  /**
   * 获取课程学生列表
   * @param kkh 开课号
   * @returns 学生列表
   */
  getCourseStudents(kkh: string): Promise<StudentInfo[]>;
  
  /**
   * 获取课程教师列表
   * @param kkh 开课号
   * @returns 教师列表
   */
  getCourseTeachers(kkh: string): Promise<TeacherInfo[]>;
}
```

#### 5.2.2 考勤管理服务

```javascript
/**
 * 考勤管理服务接口
 */
interface IAttendanceService {
  /**
   * 创建打卡任务
   * @param courseData 课程数据
   * @returns 创建结果
   */
  createPunchTask(courseData: CourseData): Promise<TaskResult>;
  
  /**
   * 学生打卡
   * @param punchData 打卡数据
   * @returns 打卡结果
   */
  studentPunch(punchData: StudentPunchData): Promise<PunchResult>;
  
  /**
   * 获取打卡记录
   * @param query 查询条件
   * @returns 打卡记录
   */
  getPunchRecords(query: PunchQuery): Promise<PaginatedResult<PunchRecord>>;
  
  /**
   * 获取考勤统计
   * @param kkh 开课号
   * @param xnxq 学年学期
   * @returns 考勤统计数据
   */
  getAttendanceStatistics(kkh: string, xnxq: string): Promise<AttendanceStatistics>;
  
  /**
   * 更新打卡状态
   * @param recordId 记录ID
   * @param status 状态
   * @param operator 操作人
   * @returns 更新结果
   */
  updatePunchStatus(recordId: string, status: number, operator: string): Promise<boolean>;
  
  /**
   * 获取异常学生名单
   * @param query 查询条件
   * @returns 异常学生列表
   */
  getAbnormalStudents(query: AbnormalQuery): Promise<PaginatedResult<AbnormalStudent>>;
  
  /**
   * 执行考勤数据分表操作
   * @param date 日期，用于确定分表的表名
   * @returns 分表结果
   */
  shardAttendanceData(date: Date): Promise<ShardingResult>;
  
  /**
   * 聚合考勤数据
   * @param aggregationParams 聚合参数
   * @returns 聚合结果
   */
  aggregateAttendanceData(aggregationParams: AggregationParams): Promise<AggregationResult>;
  
  /**
   * 读取考勤数据（支持跨表查询）
   * @param studentId 学生ID
   * @param dateRange 日期范围
   * @returns 考勤记录列表
   */
  getAttendanceRecordsAcrossTables(studentId: string, dateRange: DateRange): Promise<AttendanceRecord[]>;
  
  /**
   * 根据日期范围获取表名列表
   * @param dateRange 日期范围
   * @returns 表名列表
   */
  getTableNamesByDateRange(dateRange: DateRange): Promise<string[]>;
}
```

#### 5.2.2.1 考勤数据分表与聚合实现

```javascript
/**
 * 考勤管理服务实现
 */
class AttendanceService implements IAttendanceService {
  private readonly db: DatabaseManager;
  private readonly cacheManager: CacheManager;
  
  constructor(db: DatabaseManager, cacheManager: CacheManager) {
    this.db = db;
    this.cacheManager = cacheManager;
  }
  
  // 其他方法实现...
  
  /**
   * 执行考勤数据分表操作
   * @param date 日期，用于确定分表的表名
   * @returns 分表结果
   */
  async shardAttendanceData(date: Date): Promise<ShardingResult> {
    try {
      const tableName = `punch_record_${format(date, 'yyyyMM')}`;
      
      // 检查表是否存在，不存在则创建
      const tableExists = await this.db.tableExists(tableName);
      if (!tableExists) {
        await this.db.master.query(`
          CREATE TABLE ${tableName} LIKE punch_record;
        `);
      }
      
      return { success: true, tableName };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  
  /**
   * 聚合考勤数据到汇总表
   * @param aggregationParams 聚合参数
   * @returns 聚合结果
   */
  async aggregateAttendanceData(aggregationParams: AggregationParams): Promise<AggregationResult> {
    const { startDate, endDate, batchSize = 1000 } = aggregationParams;
    
    try {
      // 获取相关的分表
      const tables = this.getTableNamesByDateRange({ startDate, endDate });
      
      // 构建UNION ALL查询
      const tableQueries = tables.map(table => `SELECT * FROM ${table}`);
      const unionQuery = tableQueries.join(' UNION ALL ');
      
      // 执行聚合操作
      const result = await this.db.master.query(`
        INSERT INTO punch_summary (xh, kkh, xnxq, zc, jc, jxz_list, punch_status_list, 
                                  total_classes, punched_count, leave_count, absent_count)
        SELECT 
          xh, kkh, xnxq, zc, jc,
          GROUP_CONCAT(jxz ORDER BY jxz) AS jxz_list,
          GROUP_CONCAT(punch_status ORDER BY jxz) AS punch_status_list,
          COUNT(*) AS total_classes,
          SUM(CASE WHEN punch_status = 1 THEN 1 ELSE 0 END) AS punched_count,
          SUM(CASE WHEN punch_status = 2 THEN 1 ELSE 0 END) AS leave_count,
          SUM(CASE WHEN punch_status = 0 THEN 1 ELSE 0 END) AS absent_count
        FROM (${unionQuery}) AS all_records
        GROUP BY xh, kkh, xnxq, zc, jc
        ON DUPLICATE KEY UPDATE
          jxz_list = VALUES(jxz_list),
          punch_status_list = VALUES(punch_status_list),
          total_classes = VALUES(total_classes),
          punched_count = VALUES(punched_count),
          leave_count = VALUES(leave_count),
          absent_count = VALUES(absent_count);
      `);
      
      // 更新缓存
      await this.updateAggregationCache();
      
      return { 
        success: true, 
        processedTables: tables, 
        aggregatedRecords: result.affectedRows 
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  
  /**
   * 更新聚合缓存
   */
  private async updateAggregationCache(): Promise<void> {
    // 清除相关缓存
    const keys = await this.cacheManager.keys('punch:summary:*');
    for (const key of keys) {
      await this.cacheManager.del(key);
    }
  }
  
  /**
   * 读取考勤数据（支持跨表查询）
   * @param studentId 学生ID
   * @param dateRange 日期范围
   * @returns 考勤记录列表
   */
  async getAttendanceRecordsAcrossTables(
    studentId: string, 
    dateRange: DateRange
  ): Promise<AttendanceRecord[]> {
    // 先尝试从缓存获取
    const cacheKey = `punch:student:${studentId}:${dateRange.startDate}-${dateRange.endDate}`;
    const cachedData = await this.cacheManager.get(cacheKey);
    
    if (cachedData) {
      return JSON.parse(cachedData);
    }
    
    // 获取相关的表名
    const tables = this.getTableNamesByDateRange(dateRange);
    const results = [];
    
    // 从各个分表读取数据
    for (const table of tables) {
      // 使用从库读取数据
      const data = await this.db.slave.query(
        `SELECT * FROM ${table} WHERE xh = ? AND rq BETWEEN ? AND ?`,
        [studentId, dateRange.startDate, dateRange.endDate]
      );
      results.push(...data);
    }
    
    // 将结果写入缓存（设置合理的过期时间）
    await this.cacheManager.set(cacheKey, JSON.stringify(results), 3600); // 1小时过期
    
    return results;
  }
  
  /**
   * 根据日期范围获取表名列表
   * @param dateRange 日期范围
   * @returns 表名列表
   */
  getTableNamesByDateRange(dateRange: DateRange): string[] {
    const { startDate, endDate } = dateRange;
    const start = new Date(startDate);
    const end = new Date(endDate);
    const tables = [];
    
    let current = new Date(start);
    current.setDate(1); // 设置为月初
    
    while (current <= end) {
      const tableName = `punch_record_${format(current, 'yyyyMM')}`;
      tables.push(tableName);
      
      // 移动到下个月
      current.setMonth(current.getMonth() + 1);
    }
    
    return tables;
  }
}
```

#### 5.2.3 请假管理服务

```javascript
/**
 * 请假管理服务接口
 */
interface ILeaveService {
  /**
   * 创建请假申请
   * @param leaveData 请假数据
   * @returns 创建结果
   */
  createLeaveApplication(leaveData: LeaveData): Promise<LeaveResult>;
  
  /**
   * 获取请假记录
   * @param query 查询条件
   * @returns 请假记录
   */
  getLeaveRecords(query: LeaveQuery): Promise<PaginatedResult<LeaveRecord>>;
  
  /**
   * 处理请假审批
   * @param leaveId 请假ID
   * @param approvalData 审批数据
   * @returns 审批结果
   */
  processLeaveApproval(leaveId: string, approvalData: ApprovalData): Promise<ApprovalResult>;
  
  /**
   * 检查请假次数
   * @param studentId 学生ID
   * @param kkh 开课号
   * @returns 请假情况
   */
  checkLeaveQuota(studentId: string, kkh: string): Promise<LeaveQuotaInfo>;
  
  /**
   * 更新请假状态
   * @param leaveId 请假ID
   * @param status 状态
   * @returns 更新结果
   */
  updateLeaveStatus(leaveId: string, status: number): Promise<boolean>;
}
```

#### 5.2.4 用户管理服务

```javascript
/**
 * 用户管理服务接口
 */
interface IUserService {
  /**
   * 获取用户信息
   * @param userId 用户ID
   * @param userType 用户类型
   * @returns 用户信息
   */
  getUserInfo(userId: string, userType: string): Promise<UserInfo>;
  
  /**
   * 创建或更新用户
   * @param userData 用户数据
   * @returns 创建/更新结果
   */
  createOrUpdateUser(userData: UserData): Promise<UserResult>;
  
  /**
   * 绑定WPS用户
   * @param userId 用户ID
   * @param wpsUserId WPS用户ID
   * @returns 绑定结果
   */
  bindWpsUser(userId: string, wpsUserId: string): Promise<boolean>;
  
  /**
   * 获取用户列表
   * @param query 查询条件
   * @returns 用户列表
   */
  getUserList(query: UserQuery): Promise<PaginatedResult<UserInfo>>;
}
```

#### 5.2.5 统计分析服务

```javascript
/**
 * 统计分析服务接口
 */
interface IStatisticsService {
  /**
   * 获取课程考勤统计
   * @param kkh 开课号
   * @returns 考勤统计
   */
  getCourseAttendanceStatistics(kkh: string): Promise<CourseAttendanceStatistics>;
  
  /**
   * 获取学生考勤统计
   * @param studentId 学生ID
   * @returns 考勤统计
   */
  getStudentAttendanceStatistics(studentId: string): Promise<StudentAttendanceStatistics>;
  
  /**
   * 获取异常学生统计
   * @param query 查询条件
   * @returns 异常统计
   */
  getAbnormalStatistics(query: StatisticsQuery): Promise<AbnormalStatistics>;
  
  /**
   * 生成统计报表
   * @param reportType 报表类型
   * @param params 参数
   * @returns 报表数据
   */
  generateReport(reportType: string, params: any): Promise<ReportData>;
}
``` 

## 6. API设计与系统配置

### 6.1 RESTful API设计

本系统提供标准的RESTful API，用于前端与后端的交互，以及与第三方系统的集成。

#### 6.1.1 API规范

1. **基本规范**
   - 使用HTTPS协议
   - API版本控制：在URL中包含版本号，如`/api/v1/`
   - 使用JSON作为数据交换格式
   - 使用标准HTTP方法（GET, POST, PUT, DELETE等）
   - 使用HTTP状态码表示请求结果

2. **认证与安全**
   - 采用JWT(JSON Web Token)进行身份验证
   - 所有API请求需在Header中携带`Authorization: Bearer {token}`
   - 敏感数据加密传输
   - 使用CORS(跨域资源共享)控制资源访问

3. **响应格式**
```json
{
  "success": true,  // 请求是否成功
  "code": 200,      // 业务状态码
  "message": "操作成功", // 消息提示
  "data": {},       // 响应数据
  "timestamp": 1648512345678 // 时间戳
}
```

#### 6.1.2 核心API列表

1. **用户认证相关API**

| 接口 | 请求方法 | 说明 |
|------|---------|------|
| `/api/v1/auth/login` | POST | 用户登录 |
| `/api/v1/auth/refresh` | POST | 刷新令牌 |
| `/api/v1/auth/logout` | POST | 用户登出 |

2. **课程管理API**

| 接口 | 请求方法 | 说明 |
|------|---------|------|
| `/api/v1/courses` | GET | 获取课程列表 |
| `/api/v1/courses/{kkh}` | GET | 获取课程详情 |
| `/api/v1/teachers/{teacherId}/courses` | GET | 获取教师课程 |
| `/api/v1/students/{studentId}/courses` | GET | 获取学生课程 |
| `/api/v1/courses/{kkh}/students` | GET | 获取课程学生列表 |
| `/api/v1/courses/{kkh}/teachers` | GET | 获取课程教师列表 |

3. **日程同步API**

| 接口 | 请求方法 | 说明 |
|------|---------|------|
| `/api/v1/schedules/sync` | POST | 触发日程同步 |
| `/api/v1/schedules/sync/status` | GET | 获取同步状态 |
| `/api/v1/users/{userId}/schedules` | GET | 获取用户日程列表 |
| `/api/v1/courses/{kkh}/schedules` | GET | 获取课程日程列表 |

4. **打卡管理API**

| 接口 | 请求方法 | 说明 |
|------|---------|------|
| `/api/v1/punch/tasks` | GET | 获取打卡任务列表 |
| `/api/v1/punch/tasks/{taskId}` | GET | 获取打卡任务详情 |
| `/api/v1/punch/tasks/{taskId}/records` | GET | 获取打卡记录 |
| `/api/v1/punch/student` | POST | 学生打卡 |
| `/api/v1/punch/records/{recordId}/status` | PUT | 更新打卡状态 |
| `/api/v1/punch/statistics/{kkh}` | GET | 获取课程打卡统计 |

5. **请假管理API**

| 接口 | 请求方法 | 说明 |
|------|---------|------|
| `/api/v1/leaves` | POST | 创建请假申请 |
| `/api/v1/leaves` | GET | 获取请假记录列表 |
| `/api/v1/leaves/{leaveId}` | GET | 获取请假详情 |
| `/api/v1/leaves/{leaveId}/approval` | POST | 处理请假审批 |
| `/api/v1/students/{studentId}/leaves/quota/{kkh}` | GET | 检查请假配额 |
| `/api/v1/leaves/{leaveId}/status` | PUT | 更新请假状态 |

6. **统计分析API**

| 接口 | 请求方法 | 说明 |
|------|---------|------|
| `/api/v1/statistics/course/{kkh}/attendance` | GET | 获取课程考勤统计 |
| `/api/v1/statistics/student/{studentId}/attendance` | GET | 获取学生考勤统计 |
| `/api/v1/statistics/abnormal` | GET | 获取异常学生统计 |
| `/api/v1/statistics/reports/{reportType}` | GET | 生成统计报表 |

7. **系统管理API**

| 接口 | 请求方法 | 说明 |
|------|---------|------|
| `/api/v1/system/configs` | GET | 获取系统配置列表 |
| `/api/v1/system/configs/{configKey}` | GET | 获取指定配置 |
| `/api/v1/system/configs/{configKey}` | PUT | 更新系统配置 |
| `/api/v1/system/logs` | GET | 获取系统日志 |
| `/api/v1/system/health` | GET | 系统健康检查 |

### 6.2 系统配置设计

系统配置主要通过两种方式管理：环境变量和数据库配置表。

#### 6.2.1 环境变量配置

环境变量主要用于配置系统运行环境、外部服务连接参数等不常变更的配置项。

```dotenv
# 基础配置
NODE_ENV=production
PORT=3000
API_VERSION=v1
LOG_LEVEL=info

# 数据库配置
DB_HOST=localhost
DB_PORT=3306
DB_USERNAME=root
DB_PASSWORD=password
DB_DATABASE=course_sync
DB_POOL_MIN=5
DB_POOL_MAX=20

# Redis配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=password
REDIS_DB=0

# JWT配置
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRES_IN=24h
JWT_REFRESH_EXPIRES_IN=7d

# WPS API配置
WPS_API_BASE_URL=https://api.wps.cn
WPS_API_KEY=your_wps_api_key
WPS_API_SECRET=your_wps_api_secret
WPS_TENANT_ID=your_tenant_id

# 消息队列配置
MQ_HOST=localhost
MQ_PORT=5672
MQ_USERNAME=guest
MQ_PASSWORD=guest
MQ_VHOST=/

# 定时任务配置
SYNC_CRON_EXPRESSION=0 0 * * *
REMINDER_CRON_EXPRESSION=*/10 * * * *
STATISTICS_CRON_EXPRESSION=0 2 * * *
ATTENDANCE_SHARD_CRON_EXPRESSION=0 3 28-31 * *
ATTENDANCE_AGGREGATION_CRON_EXPRESSION=30 2 * * *
ATTENDANCE_ARCHIVE_CRON_EXPRESSION=0 4 1 * *

# 考勤表分表配置
ATTENDANCE_SHARD_BY_MONTH=true
ATTENDANCE_READ_REPLICA_COUNT=2
ATTENDANCE_TABLE_PREFIX=punch_record_
ATTENDANCE_ARCHIVE_MONTHS=6
ATTENDANCE_CACHE_TTL=3600
```

#### 6.2.2 数据库配置表

数据库配置表主要用于存储业务相关的可动态调整的配置项，可通过管理界面修改。

1. **打卡相关配置**

| 配置键 | 默认值 | 说明 |
|-------|-------|------|
| `punch_advance_minutes` | 10 | 提前打卡时间(分钟) |
| `punch_delay_minutes` | 10 | 延迟打卡时间(分钟) |
| `enable_location_check` | true | 是否启用位置检查 |
| `continuous_class_threshold` | 15 | 连续上课时间阈值(分钟) |
| `enable_teacher_punch` | true | 是否启用教师打卡 |
| `enable_student_punch` | true | 是否启用学生打卡 |

**考勤表拆分相关配置**

| 配置键 | 默认值 | 说明 |
|-------|-------|------|
| `attendance_shard_enabled` | true | 是否启用考勤表拆分 |
| `attendance_shard_by_month` | true | 是否按月份拆分 |
| `attendance_read_from_replica` | true | 是否从从库读取 |
| `attendance_aggregation_batch_size` | 10000 | 聚合批处理大小 |
| `attendance_aggregation_timeout` | 3600 | 聚合超时时间(秒) |
| `attendance_archive_threshold_months` | 6 | 归档阈值(月) |
| `attendance_cache_enabled` | true | 是否启用缓存 |

2. **请假相关配置**

| 配置键 | 默认值 | 说明 |
|-------|-------|------|
| `default_leave_quota` | 3 | 默认请假次数 |
| `default_advance_hours` | 24 | 默认提前请假小时数 |
| `enable_leave_approval` | true | 是否启用请假审批 |
| `leave_attachment_required` | false | 请假是否必须上传附件 |
| `leave_approval_timeout_hours` | 24 | 请假审批超时时间(小时) |

3. **日程相关配置**

| 配置键 | 默认值 | 说明 |
|-------|-------|------|
| `notification_advance_minutes` | 30 | 提前通知时间(分钟) |
| `enable_schedule_notification` | true | 是否启用日程通知 |
| `teacher_calendar_name` | "教师课表" | 教师日历名称 |
| `student_calendar_name` | "学生课表" | 学生日历名称 |
| `calendar_color` | "#4285F4" | 日历颜色 |

4. **同步相关配置**

| 配置键 | 默认值 | 说明 |
|-------|-------|------|
| `sync_batch_size` | 1000 | 同步批次大小 |
| `sync_retry_count` | 3 | 同步失败重试次数 |
| `sync_retry_interval` | 5 | 重试间隔(分钟) |
| `sync_timeout` | 30 | 同步超时时间(分钟) |
| `sync_priority_teacher` | 1 | 教师同步优先级 |
| `sync_priority_student` | 2 | 学生同步优先级 |

### 6.3 系统任务设计

系统需要定期执行一些后台任务，如数据同步、消息推送、统计分析等。

#### 6.3.1 定时任务设计

1. **课表数据同步任务**
   - 任务说明：从源数据库同步课表数据到系统
   - 执行频率：每天1次，或根据配置调整
   - 执行时间：凌晨0点（低峰时段）
   - 实现方式：基于cron表达式的定时任务

2. **日程同步任务**
   - 任务说明：将课表数据同步到WPS日历
   - 执行频率：每小时1次
   - 实现方式：增量同步，只处理新增或变更的课程

4. **考勤统计任务**
   - 任务说明：生成考勤统计数据
   - 执行频率：每天1次
   - 执行时间：凌晨2点
   - 实现方式：汇总统计当日或当周的考勤数据

5. **考勤数据分表任务**
   - 任务说明：根据日期创建新的考勤分表
   - 执行频率：每月1次
   - 执行时间：每月最后一天的凌晨3点
   - 实现方式：自动创建下个月的考勤分表结构

6. **考勤数据聚合任务**
   - 任务说明：将分表数据聚合到汇总表
   - 执行频率：每天1次
   - 执行时间：凌晨2:30点
   - 实现方式：按学生、课程、时间维度聚合数据
   - 配置项：`ATTENDANCE_AGGREGATION_CRON=30 2 * * *`

7. **考勤数据归档任务**
   - 任务说明：将历史考勤数据归档
   - 执行频率：每月1次
   - 执行时间：每月1日凌晨4点
   - 实现方式：将超过6个月的考勤数据移至归档表

8. **异常用户识别任务**
   - 任务说明：识别出勤异常的学生
   - 执行频率：每天1次
   - 执行时间：凌晨3点
   - 实现方式：根据考勤记录分析识别异常学生

#### 6.3.2 消息队列任务设计

1. **日程创建队列**
   - 队列名称：`schedule_creation_queue`
   - 处理内容：批量创建日程的请求
   - 消费方式：多个消费者并行处理

2. **打卡任务创建队列**
   - 队列名称：`punch_task_creation_queue`
   - 处理内容：创建打卡任务的请求
   - 消费方式：单一消费者，避免重复创建

3. **通知发送队列**
   - 队列名称：`notification_queue`
   - 处理内容：各类通知消息的发送
   - 消费方式：多个消费者并行处理

4. **数据同步队列**
   - 队列名称：`data_sync_queue`
   - 处理内容：数据同步任务
   - 消费方式：根据任务类型，可能是单一消费者或多消费者

5. **统计报表队列**
   - 队列名称：`report_generation_queue`
   - 处理内容：生成统计报表的请求
   - 消费方式：单一消费者顺序处理 

6. **考勤数据聚合队列**
   - 队列名称：`attendance_aggregation_queue`
   - 处理内容：大批量考勤数据聚合任务
   - 消费方式：多个消费者并行处理，按分区键分配
   - 特点：支持重试机制和手动触发

7. **考勤数据归档队列**
   - 队列名称：`attendance_archive_queue`
   - 处理内容：历史考勤数据归档任务
   - 消费方式：单一消费者顺序处理
   - 特点：低优先级，在系统负载低时执行

## 7. 系统实现与部署

### 7.1 项目结构设计

本项目采用模块化结构，遵循领域驱动设计(DDD)的思想，将系统分为多个核心模块。

```
项目结构
├── src/
│   ├── config/                 # 配置文件
│   ├── api/                    # API层
│   │   ├── controllers/        # 控制器
│   │   ├── middlewares/        # 中间件
│   │   ├── routes/             # 路由定义
│   │   └── validators/         # 请求验证
│   ├── services/               # 服务层
│   │   ├── course/             # 课程服务
│   │   ├── schedule/           # 日程服务
│   │   ├── punch/              # 打卡服务
│   │   ├── leave/              # 请假服务
│   │   ├── statistics/         # 统计服务
│   │   └── system/             # 系统服务
│   ├── integrations/           # 外部集成
│   │   ├── wps/                # WPS集成
│   │   └── database/           # 数据库集成
│   ├── models/                 # 数据模型
│   ├── repositories/           # 数据仓库
│   ├── utils/                  # 工具类
│   ├── tasks/                  # 定时任务
│   │   ├── sync/               # 同步任务
│   │   ├── notification/       # 通知任务
│   │   └── statistics/         # 统计任务
│   ├── queues/                 # 消息队列
│   ├── events/                 # 事件处理
│   ├── types/                  # 类型定义
│   └── app.ts                  # 应用入口
├── test/                       # 测试目录
├── migrations/                 # 数据库迁移
├── scripts/                    # 脚本工具
├── logs/                       # 日志目录
├── public/                     # 静态资源
├── .env                        # 环境变量
├── package.json                # 项目配置
├── tsconfig.json               # TypeScript配置
├── knexfile.js                 # Knex配置
└── docker-compose.yml          # Docker配置
```

### 7.2 技术栈详细设计

#### 7.2.1 后端技术栈

1. **核心框架**
   - Node.js：JavaScript运行时环境
   - Express.js：Web应用框架
   - TypeScript：提供静态类型检查

2. **数据存储**
   - MySQL：主要关系型数据库
   - Knex.js：SQL查询构建器和数据库迁移工具
   - Redis：缓存和会话存储

3. **消息队列**
   - RabbitMQ：高可靠消息队列系统
   - amqplib：AMQP协议客户端库

4. **任务调度**
   - node-cron：定时任务调度
   - agenda：高级任务调度库

5. **API文档**
   - Swagger/OpenAPI：API文档自动生成
   - express-validator：请求验证

6. **日志与监控**
   - Winston：日志记录
   - Prometheus：系统监控
   - Grafana：可视化监控面板

7. **安全与认证**
   - JWT：身份认证
   - helmet：安全中间件
   - bcrypt：密码加密

8. **测试工具**
   - Jest：单元测试和集成测试
   - Supertest：API测试

#### 7.2.2 前端技术栈

1. **核心框架**
   - Vue.js 3：前端框架
   - TypeScript：类型系统

2. **UI组件库**
   - Element Plus：UI组件库
   - TailwindCSS：原子化CSS框架

3. **状态管理**
   - Pinia：新一代Vue状态管理库

4. **路由管理**
   - Vue Router：官方路由管理器

5. **HTTP客户端**
   - Axios：HTTP请求库

6. **图表可视化**
   - ECharts：图表库
   - Vue-ECharts：Vue封装的ECharts

7. **工具链**
   - Vite：前端构建工具
   - ESLint：代码检查
   - Prettier：代码格式化

### 7.3 部署架构设计

系统采用容器化部署方案，使用Docker和Kubernetes进行服务编排。

#### 7.3.1 Docker容器设计

1. **应用容器**
   - Node.js应用容器
   - Nginx前端容器

2. **数据库容器**
   - MySQL数据库容器
   - Redis缓存容器

3. **消息队列容器**
   - RabbitMQ容器

4. **监控容器**
   - Prometheus容器
   - Grafana容器

5. **日志容器**
   - ELK Stack（Elasticsearch, Logstash, Kibana）

#### 7.3.2 Kubernetes部署架构

```
                                   ┌─────────────┐
                                   │   Ingress   │
                                   └──────┬──────┘
                                          │
         ┌───────────────────────────────┼───────────────────────────────┐
         │                               │                               │
┌────────▼───────┐              ┌────────▼───────┐              ┌────────▼───────┐
│   API Service   │              │  前端Service   │              │  监控Service   │
│  (多个副本)     │              │  (多个副本)     │              │                │
└────────┬───────┘              └────────┬───────┘              └────────┬───────┘
         │                               │                               │
         │                               │                               │
┌────────▼───────┐              ┌────────▼───────┐              ┌────────▼───────┐
│  任务调度Pod    │              │    静态资源     │              │  Prometheus    │
│  (Deployment)   │              │    (ConfigMap)  │              │   Grafana      │
└────────┬───────┘              └─────────────────┘              └─────────────────┘
         │
         │
┌────────▼───────┐              ┌─────────────────┐              ┌─────────────────┐
│  消息队列Service │              │  数据库Service   │              │  缓存Service    │
│   (RabbitMQ)    │              │    (MySQL)      │              │    (Redis)      │
└─────────────────┘              └─────────────────┘              └─────────────────┘

                       持久化存储 (PersistentVolume)
```

#### 7.3.3 部署策略

1. **环境分离**
   - 开发环境：用于日常开发和功能测试
   - 测试环境：用于集成测试和性能测试
   - 预发布环境：与生产环境配置一致，用于最终验证
   - 生产环境：最终用户使用的环境

2. **CI/CD流程**
   - 代码提交触发自动化测试
   - 测试通过后自动构建Docker镜像
   - 镜像推送到镜像仓库
   - 自动部署到测试环境
   - 手动确认后部署到生产环境

3. **灰度发布策略**
   - 支持A/B测试
   - 支持金丝雀发布
   - 支持蓝绿部署

4. **数据备份策略**
   - 数据库定时全量备份
   - Binlog增量备份
   - 跨区域备份存储

### 7.4 安全设计

#### 7.4.1 数据安全

1. **敏感数据加密**
   - 用户密码采用bcrypt加密存储
   - 传输过程中使用HTTPS协议
   - API接口采用JWT认证

2. **数据隔离**
   - 不同用户数据严格隔离
   - 根据角色进行权限控制
   - 数据访问日志记录

3. **数据备份与恢复**
   - 定期数据备份
   - 灾难恢复机制
   - 数据删除保护机制

#### 7.4.2 应用安全

1. **API安全**
   - 请求参数验证
   - SQL注入防护
   - XSS攻击防护
   - CSRF防护
   - 请求频率限制

2. **身份认证与授权**
   - 多因素认证
   - 基于角色的访问控制
   - 会话超时管理
   - 异常登录检测

3. **网络安全**
   - WAF网络防火墙
   - DDoS防护
   - API网关流量控制
   - 网络访问白名单

## 8. 总结与展望

### 8.1 方案总结

本设计方案详细描述了课表同步应用的系统架构、核心模块、数据模型、API设计和部署策略。系统通过将教育机构的课表数据与WPS协作空间集成，实现了日程同步、打卡考勤和请假审批等功能，为教师和学生提供便捷的教学管理工具。

主要特点包括：

1. **模块化设计**：系统分为数据采集、数据转换、WPS集成和业务逻辑等核心模块，职责明确，便于维护和扩展

2. **完善的数据模型**：精心设计的数据库结构，支持课表数据的存储、转换和关联查询

3. **丰富的业务功能**：支持日程同步、打卡考勤、请假审批和统计分析等核心功能

4. **安全性考虑**：涵盖数据安全、应用安全和网络安全的多层次保护机制

5. **可扩展架构**：基于微服务理念，支持系统功能的灵活扩展和升级

6. **高可用部署**：采用容器化和云原生技术，实现系统的高可用性和可靠性

### 8.2 未来展望

随着系统的发展和用户需求的变化，以下方向可以考虑进一步完善和扩展：

1. **智能化分析**：引入机器学习算法，实现考勤异常预测、学习行为分析等智能化功能

2. **多数据源集成**：扩展支持更多的教育管理系统数据源，如教务系统、学生管理系统等

3. **移动端应用**：开发配套的移动端应用，提供更便捷的打卡、请假和日程查看功能

4. **个性化配置**：支持更丰富的个性化配置，满足不同教育机构的特定需求

5. **开放API平台**：建设开放API平台，支持第三方应用与系统集成，形成教育应用生态

6. **多语言支持**：增加多语言支持，适应国际化教育环境

7. **教学资源集成**：与课程相关的教学资源（如课件、作业等）集成到课程日程中

通过持续迭代和优化，课表同步应用将不断提升用户体验，为教育机构的数字化转型提供有力支持。