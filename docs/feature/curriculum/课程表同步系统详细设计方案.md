# 课程表同步系统详细设计方案

## 目录

- [课程表同步系统详细设计方案](#课程表同步系统详细设计方案)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 项目背景](#11-项目背景)
    - [1.2 系统目标](#12-系统目标)
  - [2. 系统架构设计](#2-系统架构设计)
    - [2.1 总体架构](#21-总体架构)
    - [2.2 核心服务详解](#22-核心服务详解)
      - [2.2.1 数据同步服务](#221-数据同步服务)
      - [2.2.2 用户服务](#222-用户服务)
      - [2.2.3 打卡请假服务](#223-打卡请假服务)
      - [2.2.4 统计服务](#224-统计服务)
    - [2.3 技术栈选型](#23-技术栈选型)
  - [3. 系统模块设计](#3-系统模块设计)
    - [3.1 项目目录结构](#31-项目目录结构)
    - [3.2 核心模块功能详解](#32-核心模块功能详解)
      - [3.2.1 数据同步服务模块](#321-数据同步服务模块)
        - [数据拉取模块](#数据拉取模块)
        - [数据处理模块](#数据处理模块)
        - [WPS API集成模块](#wps-api集成模块)
        - [完整同步流程详解](#完整同步流程详解)
        - [WPS接口调用失败处理机制](#wps接口调用失败处理机制)
        - [故障恢复机制](#故障恢复机制)
      - [3.2.2 打卡请假服务模块](#322-打卡请假服务模块)
        - [打卡管理模块](#打卡管理模块)
        - [请假管理模块](#请假管理模块)
  - [4. 完整的数据模型设计](#4-完整的数据模型设计)
    - [4.1 数据库选型与分层](#41-数据库选型与分层)
    - [4.2 数据库表设计](#42-数据库表设计)
      - [4.2.1 用户相关表](#421-用户相关表)
        - [用户表 (users)](#用户表-users)
        - [用户配置表 (user\_configs)](#用户配置表-user_configs)
      - [4.2.2 课程相关表](#422-课程相关表)
        - [课程表 (courses)](#课程表-courses)
        - [课程安排表 (course\_arrangements)](#课程安排表-course_arrangements)
        - [学生课程关系表 (student\_courses)](#学生课程关系表-student_courses)
      - [4.2.3 日程相关表](#423-日程相关表)
        - [日程表 (schedules)](#日程表-schedules)
      - [4.2.4 打卡相关表](#424-打卡相关表)
        - [打卡记录表 (checkin\_records)](#打卡记录表-checkin_records)
        - [打卡设置表 (checkin\_settings)](#打卡设置表-checkin_settings)
      - [4.2.5 请假相关表](#425-请假相关表)
        - [请假记录表 (leave\_records)](#请假记录表-leave_records)
      - [4.2.6 统计相关表](#426-统计相关表)
        - [出勤统计表 (attendance\_stats)](#出勤统计表-attendance_stats)
      - [4.2.7 系统相关表](#427-系统相关表)
        - [系统配置表 (system\_configs)](#系统配置表-system_configs)
        - [同步记录表 (sync\_logs)](#同步记录表-sync_logs)
        - [同步失败记录表 (sync\_failure\_records)](#同步失败记录表-sync_failure_records)
    - [4.3 Redis缓存设计](#43-redis缓存设计)
      - [4.3.1 缓存键设计](#431-缓存键设计)
      - [4.3.2 缓存使用策略](#432-缓存使用策略)
    - [4.4 消息队列设计](#44-消息队列设计)
      - [4.4.1 Kafka主题设计](#441-kafka主题设计)
      - [4.4.2 消息格式设计](#442-消息格式设计)
      - [4.4.3 消费者组设计](#443-消费者组设计)
    - [4.5 数据模型的作用与完备性分析](#45-数据模型的作用与完备性分析)
      - [4.5.1 核心数据模型作用](#451-核心数据模型作用)
      - [4.5.2 数据模型的完备性分析](#452-数据模型的完备性分析)
      - [4.5.3 特殊业务场景支持](#453-特殊业务场景支持)
      - [4.5.4 并行同步与数据一致性保障](#454-并行同步与数据一致性保障)
    - [4.6 考勤表设计与处理流程](#46-考勤表设计与处理流程)
      - [4.6.1 考勤预置表设计](#461-考勤预置表设计)
      - [4.6.2 考勤表自动预置流程](#462-考勤表自动预置流程)
      - [4.6.3 考勤数据实时处理流程](#463-考勤数据实时处理流程)
      - [4.6.4 考勤统计计算流程](#464-考勤统计计算流程)
      - [4.6.5 考勤数据查询优化](#465-考勤数据查询优化)
    - [4.7 大数据量处理策略与分片分表设计](#47-大数据量处理策略与分片分表设计)
      - [4.7.1 数据量分析与挑战](#471-数据量分析与挑战)
      - [4.7.2 首次大规模同步优化策略](#472-首次大规模同步优化策略)
      - [4.7.3 百万级日程数据查询优化](#473-百万级日程数据查询优化)
      - [4.7.4 多维度查询优化](#474-多维度查询优化)
      - [4.7.5 海量数据性能优化措施](#475-海量数据性能优化措施)
  - [5. 接口方案设计](#5-接口方案设计)
    - [5.1 接口设计原则](#51-接口设计原则)
    - [5.2 RESTful API设计](#52-restful-api设计)
      - [5.2.1 接口规范](#521-接口规范)
      - [5.2.2 核心接口示例](#522-核心接口示例)
        - [课程同步接口](#课程同步接口)
        - [打卡接口](#打卡接口)
        - [请假接口](#请假接口)
    - [5.3 GraphQL API设计](#53-graphql-api设计)
      - [5.3.1 GraphQL Schema示例](#531-graphql-schema示例)
      - [5.3.2 GraphQL查询示例](#532-graphql查询示例)
    - [5.4 WebSocket接口设计](#54-websocket接口设计)
    - [5.5 接口安全设计](#55-接口安全设计)
      - [5.5.1 认证机制](#551-认证机制)
      - [5.5.2 权限控制](#552-权限控制)
      - [5.5.3 数据加密](#553-数据加密)
    - [5.6 API文档与测试](#56-api文档与测试)
  - [6. 异常处理方案](#6-异常处理方案)
    - [6.1 异常分类与处理策略](#61-异常分类与处理策略)
      - [6.1.1 异常分类体系](#611-异常分类体系)
      - [6.1.2 异常处理策略](#612-异常处理策略)
    - [6.2 WPS API异常处理机制](#62-wps-api异常处理机制)
      - [6.2.1 WPS API错误码分类](#621-wps-api错误码分类)
      - [6.2.2 API调用异常处理流程](#622-api调用异常处理流程)
      - [6.2.3 API调用重试策略](#623-api调用重试策略)
    - [6.3 数据同步异常处理](#63-数据同步异常处理)
      - [6.3.1 同步过程中断恢复机制](#631-同步过程中断恢复机制)
      - [6.3.2 数据一致性检验与修复](#632-数据一致性检验与修复)
    - [6.4 打卡和请假业务异常处理](#64-打卡和请假业务异常处理)
      - [6.4.1 打卡异常处理](#641-打卡异常处理)
      - [6.4.2 请假异常处理](#642-请假异常处理)
    - [6.5 异常监控与告警](#65-异常监控与告警)
      - [6.5.1 异常监控维度](#651-异常监控维度)
      - [6.5.2 告警等级与处理流程](#652-告警等级与处理流程)
      - [6.5.3 告警触发与升级机制](#653-告警触发与升级机制)
    - [6.6 异常恢复与后处理](#66-异常恢复与后处理)
      - [6.6.1 自动恢复机制](#661-自动恢复机制)
      - [6.6.2 异常分析与优化](#662-异常分析与优化)
      - [6.6.3 异常事件闭环管理](#663-异常事件闭环管理)
    - [6.7 异常处理最佳实践](#67-异常处理最佳实践)
      - [6.7.1 开发阶段最佳实践](#671-开发阶段最佳实践)
      - [6.7.2 运维阶段最佳实践](#672-运维阶段最佳实践)
      - [6.7.3 用户体验优化](#673-用户体验优化)
  - [7. 高负载高可用方案设计](#7-高负载高可用方案设计)
    - [7.1 整体架构高可用设计](#71-整体架构高可用设计)
      - [7.1.1 多层次高可用架构](#711-多层次高可用架构)
      - [7.1.2 关键组件冗余设计](#712-关键组件冗余设计)
    - [7.2 打卡模块高可用方案](#72-打卡模块高可用方案)
      - [7.2.1 高并发打卡架构](#721-高并发打卡架构)
      - [7.2.2 打卡流程设计](#722-打卡流程设计)
      - [7.2.3 打卡服务扩缩容策略](#723-打卡服务扩缩容策略)
      - [7.2.4 打卡异常处理流程](#724-打卡异常处理流程)
    - [7.3 请假模块高可用方案](#73-请假模块高可用方案)
      - [7.3.1 请假流程高可用设计](#731-请假流程高可用设计)
      - [7.3.2 请假服务可靠性保障](#732-请假服务可靠性保障)
    - [7.4 数据一致性保障](#74-数据一致性保障)
      - [7.4.1 最终一致性策略](#741-最终一致性策略)
      - [7.4.2 强一致性保障](#742-强一致性保障)
      - [7.4.3 数据同步故障恢复](#743-数据同步故障恢复)
    - [7.5 系统监控与应急预案](#75-系统监控与应急预案)
      - [7.5.1 全方位监控体系](#751-全方位监控体系)
      - [7.5.2 应急预案](#752-应急预案)
  - [8. 总结](#8-总结)
    - [8.1 设计原则回顾](#81-设计原则回顾)
    - [8.2 实施建议](#82-实施建议)
      - [8.2.1 技术栈优化](#821-技术栈优化)
    - [8.3 风险与应对](#83-风险与应对)
  - [9. 业务流程与技术实现连接](#9-业务流程与技术实现连接)
    - [9.1 主要业务流程梳理](#91-主要业务流程梳理)
      - [9.1.1 课程表同步业务流程](#911-课程表同步业务流程)
      - [9.1.2 考勤打卡业务流程](#912-考勤打卡业务流程)
      - [9.1.3 请假管理业务流程](#913-请假管理业务流程)
    - [9.2 技术与业务的映射关系](#92-技术与业务的映射关系)
    - [9.3 性能与业务需求的平衡](#93-性能与业务需求的平衡)

## 1. 概述

### 1.1 项目背景
本项目旨在开发一个大学课程表同步应用程序，将原始课程数据库中的课程信息同步到WPS协作平台的日历和日程应用中，并提供打卡、请假等功能，以及出勤率统计和管理功能。通过此系统，可以实现教师和学生课程信息的统一管理和查看，提高教学管理效率。

### 1.2 系统目标
- 实现课程数据从原始数据库到WPS协作平台的自动同步
- 为教师和学生提供个性化的课程日历和日程
- 开发课程打卡和请假功能，支持高并发场景
- 提供课程出勤率统计和管理功能
- 建立同步管理后台，便于运维人员监控和管理同步过程
- 确保系统在异常情况下的可靠性和数据一致性

## 2. 系统架构设计

### 2.1 总体架构

课程表同步系统采用微服务架构，主要包含以下核心组件：

```
┌─────────────────────────────────────────────────────────────┐
│                      客户端应用层                             │
│  ┌─────────────────┐  ┌─────────────────┐ ┌─────────────┐   │
│  │    wps协作app     │  │    教师端Web     │ │ 管理员端Web  │   │
│  └─────────────────┘  └─────────────────┘ └─────────────┘   │
└───────────────────────────────┬─────────────────────────────┘
                                │
┌───────────────────────────────┼─────────────────────────────┐
│                      API网关层                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │   API网关 (Express Gateway) - 路由/认证/限流/监控      │    │
│  └─────────────────────────────────────────────────────┘    │
└───────────────────────────────┬─────────────────────────────┘
                                │
┌───────────────────────────────┼─────────────────────────────┐
│                     微服务业务层                              │
│  ┌─────────────┐ ┌──────────┐ ┌─────────────┐ ┌──────────┐  │
│  │ 数据同步服务  │ │ 用户服务  │ │ 打卡请假服务  │ │ 统计服务  │  │
│  └─────────────┘ └──────────┘ └─────────────┘ └──────────┘  │
└───────────────────────────────┬─────────────────────────────┘
                                │
┌───────────────────────────────┼─────────────────────────────┐
│                     数据存储层                                │
│  ┌─────────────┐ ┌──────────┐ ┌─────────────┐ ┌──────────┐  │
│  │   MySQL     │ │  Redis   │ │  MongoDB    │ │ 日志存储   │  │
│  └─────────────┘ └──────────┘ └─────────────┘ └──────────┘  │
└───────────────────────────────┬─────────────────────────────┘
                                │
┌───────────────────────────────┼─────────────────────────────┐
│                     外部服务集成层                            │
│  ┌─────────────────────┐    ┌──────────────────────────┐    │
│  │  原始课程数据库接口    │    │     WPS协作平台API        │    │
│  └─────────────────────┘    └──────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心服务详解

#### 2.2.1 数据同步服务
- **功能职责**：从原始数据库获取课程数据，处理后同步到WPS协作平台
- **关键模块**：
  - 数据拉取模块：从原始数据库获取课程安排和学生选课数据
  - 数据处理模块：转换数据格式，处理增量变化
  - WPS日历同步模块：创建和管理WPS日历
  - WPS日程同步模块：创建和管理WPS日程
  - 同步状态管理：记录同步进度和状态
  - 错误处理和重试：处理同步过程中的异常情况

#### 2.2.2 用户服务
- **功能职责**：管理用户信息、认证授权、用户配置
- **关键模块**：
  - 账号映射：管理原始系统与WPS账号的映射关系
  - 认证授权：用户登录认证和权限控制
  - 用户配置：管理用户个性化设置
  - 用户通知：向用户推送消息和通知

#### 2.2.3 打卡请假服务
- **功能职责**：处理学生打卡和请假相关业务逻辑
- **关键模块**：
  - 打卡管理：处理学生打卡请求，验证位置和时间有效性
  - 请假管理：处理学生请假申请，创建和跟踪审批流程
  - 状态管理：维护课程的出勤状态
  - 高并发处理：采用消息队列和异步处理机制处理高峰期请求

#### 2.2.4 统计服务
- **功能职责**：汇总和计算出勤数据，生成统计报表
- **关键模块**：
  - 数据聚合：按各维度聚合出勤数据
  - 报表生成：生成各类统计报表
  - 数据查询：提供多维度数据查询接口
  - 数据导出：支持统计数据的导出功能

### 2.3 技术栈选型

| 层级 | 技术选型 | 说明 |
|------|---------|------|
| 前端框架 | React + Next.js | 服务端渲染支持，提升首屏加载速度 |
| UI组件库 | Ant Design | 企业级UI组件库，组件丰富 |
| 状态管理 | Redux + Redux Toolkit | 全局状态管理，简化异步操作 |
| 后端框架 | Node.js + Express | 高性能异步I/O，适合I/O密集型应用 |
| 数据库 | MySQL | 关系型数据库，强一致性保证 |
| 缓存 | Redis | 高性能缓存，支持多种数据结构 |
| 消息队列 | Kafka | 高吞吐量消息队列，适合高并发场景 |
| 日志系统 | ELK Stack | 日志收集、存储和分析 |
| 监控系统 | Prometheus + Grafana | 系统指标监控和可视化 |
| 容器化 | Docker + Kubernetes | 容器化部署和编排管理 |
| CI/CD | Jenkins | 持续集成和部署 |

## 3. 系统模块设计

### 3.1 项目目录结构

```
obsync-root/
├── packages/                      # 多包管理
│   ├── api-gateway/               # API网关服务
│   │   ├── src/
│   │   │   ├── config/            # 网关配置
│   │   │   ├── middleware/        # 中间件
│   │   │   ├── routes/            # 路由定义
│   │   │   └── index.js           # 入口文件
│   │   └── package.json           # 依赖管理
│   │
│   ├── sync-service/              # 数据同步服务
│   │   ├── src/
│   │   │   ├── config/            # 服务配置
│   │   │   ├── controllers/       # 控制器
│   │   │   ├── models/            # 数据模型
│   │   │   ├── services/          # 业务逻辑
│   │   │   │   ├── datasource/    # 数据源接入
│   │   │   │   ├── processor/     # 数据处理
│   │   │   │   └── wps/           # WPS API集成
│   │   │   ├── utils/             # 工具函数
│   │   │   └── index.js           # 入口文件
│   │   └── package.json           # 依赖管理
│   │
│   ├── user-service/              # 用户服务
│   │   ├── src/
│   │   │   ├── config/            # 服务配置
│   │   │   ├── controllers/       # 控制器
│   │   │   ├── models/            # 数据模型
│   │   │   ├── services/          # 业务逻辑
│   │   │   ├── utils/             # 工具函数
│   │   │   └── index.js           # 入口文件
│   │   └── package.json           # 依赖管理
│   │
│   ├── checkin-service/           # 打卡请假服务
│   │   ├── src/
│   │   │   ├── config/            # 服务配置
│   │   │   ├── controllers/       # 控制器
│   │   │   ├── models/            # 数据模型
│   │   │   ├── services/          # 业务逻辑
│   │   │   │   ├── checkin/       # 打卡业务
│   │   │   │   ├── leave/         # 请假业务
│   │   │   │   └── approval/      # 审批业务
│   │   │   ├── utils/             # 工具函数
│   │   │   └── index.js           # 入口文件
│   │   └── package.json           # 依赖管理
│   │
│   ├── stats-service/             # 统计服务
│   │   ├── src/
│   │   │   ├── config/            # 服务配置
│   │   │   ├── controllers/       # 控制器
│   │   │   ├── models/            # 数据模型
│   │   │   ├── services/          # 业务逻辑
│   │   │   ├── utils/             # 工具函数
│   │   │   └── index.js           # 入口文件
│   │   └── package.json           # 依赖管理
│   │
│   └── common/                    # 公共模块
│       ├── src/
│       │   ├── config/            # 公共配置
│       │   ├── database/          # 数据库连接
│       │   ├── logger/            # 日志模块
│       │   ├── middleware/        # 公共中间件
│       │   ├── utils/             # 公共工具
│       │   └── index.js           # 入口文件
│       └── package.json           # 依赖管理
│
├── web/                           # 前端应用
│   ├── public/                    # 静态资源
│   ├── src/
│   │   ├── api/                   # API调用
│   │   ├── components/            # 组件
│   │   ├── config/                # 前端配置
│   │   ├── layouts/               # 布局组件
│   │   ├── pages/                 # 页面
│   │   │   ├── admin/             # 管理员页面
│   │   │   ├── student/           # 学生页面
│   │   │   └── teacher/           # 教师页面
│   │   ├── redux/                 # 状态管理
│   │   ├── styles/                # 样式文件
│   │   ├── utils/                 # 工具函数
│   │   └── App.jsx                # 应用入口
│   └── package.json               # 依赖管理
│
├── scripts/                       # 部署脚本
├── docker/                        # Docker配置
├── docker-compose.yml             # 容器编排配置
├── package.json                   # 项目依赖
└── README.md                      # 项目说明

```

### 3.2 核心模块功能详解

#### 3.2.1 数据同步服务模块

##### 数据拉取模块
- **功能**: 定期从原始数据库获取课程安排和学生选课数据
- **关键类**:
  - `DataSourceConnector`: 数据源连接管理
  - `CourseDataFetcher`: 课程安排数据获取
  - `StudentCourseDataFetcher`: 学生选课数据获取
  - `IncrementalDataFetcher`: 增量数据获取

```javascript
// src/services/datasource/CourseDataFetcher.js
class CourseDataFetcher {
  constructor(dbConfig) {
    this.dbConnector = new DataSourceConnector(dbConfig);
  }
  
  async fetchCourseArrangements(params) {
    try {
      const connection = await this.dbConnector.getConnection();
      // 根据zt字段获取变更数据
      const query = "SELECT * FROM course_arrangements WHERE zt IN (?, ?, ?) AND xnxq = ?";
      const result = await connection.query(query, ['add', 'update', 'delete', params.xnxq]);
      return result;
    } catch (error) {
      logger.error('Failed to fetch course arrangements:', error);
      throw new SyncError('DATA_FETCH_ERROR', error.message);
    }
  }
  
  // 其他数据获取方法...
}
```

##### 数据处理模块
- **功能**: 转换数据格式，处理增量变化
- **关键类**:
  - `CourseDataProcessor`: 课程数据处理
  - `TeacherScheduleGenerator`: 教师日程生成
  - `StudentScheduleGenerator`: 学生日程生成
  - `DeltaProcessor`: 变更数据处理

```javascript
// src/services/processor/CourseDataProcessor.js
class CourseDataProcessor {
  processCoursesData(coursesData) {
    try {
      const processed = coursesData.map(course => ({
        kkh: course.kkh,
        courseName: course.kcmc,
        semester: course.xnxq,
        teacherCodes: course.ghs ? course.ghs.split(',') : [],
        teacherNames: course.Xms ? course.Xms.split(',') : [],
        location: {
          campus: course.xq,
          building: course.lq,
          room: course.room,
          floor: course.lc
        },
        time: {
          week: course.jxz,
          dayOfWeek: course.zc,
          period: course.jc,
          startTime: course.st,
          endTime: course.ed,
          date: course.rq
        },
        needCheckin: course.sfdk === 1,
        status: course.zt,
        remark: course.bz
      }));
      return processed;
    } catch (error) {
      logger.error('Failed to process courses data:', error);
      throw new SyncError('DATA_PROCESSING_ERROR', error.message);
    }
  }
  
  // 其他数据处理方法...
}
```

##### WPS API集成模块
- **功能**: 与WPS协作平台交互，管理日历和日程
- **关键类**:
  - `WPSApiClient`: WPS API客户端
  - `CalendarManager`: 日历管理
  - `EventManager`: 日程管理
  - `ApprovalManager`: 审批流管理

```javascript
// src/services/wps/WPSApiClient.js
class WPSApiClient {
  constructor(config) {
    this.baseUrl = config.baseUrl;
    this.appId = config.appId;
    this.appSecret = config.appSecret;
    this.tokenCache = new TokenCache(config.tokenExpiration);
  }
  
  async getAccessToken() {
    try {
      // 从缓存获取token，如不存在则请求新token
      let token = this.tokenCache.getToken();
      if (!token) {
        const response = await axios.post(`${this.baseUrl}/oauth2/token`, {
          app_id: this.appId,
          app_secret: this.appSecret,
          grant_type: 'client_credentials'
        });
        token = response.data.access_token;
        this.tokenCache.setToken(token, response.data.expires_in);
      }
      return token;
    } catch (error) {
      logger.error('Failed to get WPS access token:', error);
      throw new WPSApiError('AUTH_ERROR', error.message);
    }
  }
  
  async request(method, endpoint, data = null) {
    try {
      const token = await this.getAccessToken();
      const response = await axios({
        method,
        url: `${this.baseUrl}${endpoint}`,
        data,
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      return response.data;
    } catch (error) {
      logger.error(`WPS API request failed: ${method} ${endpoint}`, error);
      // 处理特定错误码
      this.handleApiError(error);
      throw new WPSApiError('API_REQUEST_ERROR', error.message);
    }
  }
  
  handleApiError(error) {
    // 根据错误码进行处理
    if (error.response && error.response.data) {
      const errorCode = error.response.data.error_code;
      // Token过期
      if (errorCode === 'token_expired') {
        this.tokenCache.clearToken();
      }
      // 请求过于频繁
      if (errorCode === 'rate_limit_exceeded') {
        // 触发限流保护
        RequestLimiter.triggerBackoff();
      }
    }
  }
}
```

##### 完整同步流程详解

系统实现了全面的同步流程，确保课程数据从源系统到WPS平台的可靠同步：

1. **数据同步策略**:
   - **全量同步**: 学期初或系统初始化时执行，同步所有课程数据
   - **增量同步**: 定时执行(默认每小时)，只同步变更数据
   - **手动触发同步**: 管理员可手动触发特定范围的同步

2. **同步流程详细步骤**:

```
┌─────────────────────┐
│  同步任务初始化      │
│  生成唯一batch_id    │
└──────────┬──────────┘
           ▼
┌─────────────────────┐
│  记录同步开始状态    │
│  创建同步检查点      │
└──────────┬──────────┘
           ▼
┌─────────────────────┐
│  从源系统获取数据    │
│  (增量或全量)        │
└──────────┬──────────┘
           ▼
┌─────────────────────┐
│  数据转换与处理      │
│  计算变更差异        │
└──────────┬──────────┘
           ▼
┌─────────────────────┐            ┌─────────────────┐
│  按用户分组数据      │──新日历──▶│  创建WPS日历     │
└──────────┬──────────┘            └─────────┬───────┘
           │                                  │
           ▼                                  ▼
┌─────────────────────┐            ┌─────────────────┐
│  遍历处理每个变更    │            │  记录日历映射   │
└──────────┬──────────┘            └─────────────────┘
           │
           ▼
┌─────────────────────┐
│  根据操作类型处理    │
└──────────┬──────────┘
           │
           ├─────────┬─────────┬─────────┐
           ▼         ▼         ▼         ▼
┌─────────────┐ ┌─────────┐ ┌───────┐ ┌───────────┐
│  创建日程   │ │ 更新日程 │ │ 删除  │ │ 批量操作  │
└──────┬──────┘ └────┬────┘ └───┬───┘ └─────┬─────┘
       │             │          │           │
       └─────────────┴──────────┴───────────┘
                      │
                      ▼
┌─────────────────────────────┐
│  记录同步结果与失败项       │
└───────────────┬─────────────┘
                ▼
┌─────────────────────────────┐
│  处理失败项(重试/标记)       │
└───────────────┬─────────────┘
                ▼
┌─────────────────────────────┐
│  更新同步状态与检查点       │
└───────────────┬─────────────┘
                ▼
┌─────────────────────────────┐
│  生成同步报告               │
└─────────────────────────────┘
```

3. **事务与原子性保证**:
   - 每个同步批次使用唯一的`batch_id`标识
   - 采用原子性更新机制，确保同步状态一致
   - 同步过程中的每个关键节点都记录检查点(Checkpoint)

4. **增量同步逻辑**:
   - 基于时间戳比对: 使用`updated_at`字段识别变更记录
   - 基于状态标记: 使用`zt`(状态)字段标记新增/更新/删除记录
   - 批量处理: 将变更数据分批处理，优化性能

5. **同步冲突处理**:
   - 乐观锁机制: 使用版本号检测冲突
   - 后写入优先: 冲突时以最后写入为准
   - 冲突记录: 记录所有冲突，供后续分析

##### WPS接口调用失败处理机制

为确保WPS API调用的可靠性，系统实现了完善的失败处理机制：

1. **错误分类与处理策略**:

| 错误类型 | 错误码范围 | 处理策略 | 重试策略 |
|---------|------------|---------|---------|
| 身份验证错误 | 401-403 | 刷新Token后重试 | 最多3次，间隔递增 |
| 资源不存在 | 404 | 重新创建资源 | 1次重试 |
| 请求限制 | 429 | 启动限流保护 | 指数退避算法 |
| 服务器错误 | 500-599 | 延迟重试 | 最多5次，间隔递增 |
| 网络错误 | N/A | 网络重连后重试 | 最多3次，间隔递增 |
| 超时错误 | N/A | 降低批量大小重试 | 最多3次，分批处理 |

2. **重试机制实现**:

```javascript
// src/services/wps/RetryManager.js
class RetryManager {
  constructor(maxRetries = 3) {
    this.maxRetries = maxRetries;
  }
  
  async executeWithRetry(operation, errorHandler) {
    let attempts = 0;
    let lastError = null;
    
    while (attempts < this.maxRetries) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        attempts++;
        
        // 获取重试策略
        const retryStrategy = errorHandler(error, attempts);
        if (!retryStrategy.shouldRetry) {
          break;
        }
        
        // 等待指定时间后重试
        await new Promise(resolve => setTimeout(resolve, retryStrategy.delayMs));
        
        // 记录重试日志
        logger.info(`Retrying operation, attempt ${attempts}/${this.maxRetries}`);
      }
    }
    
    // 所有重试失败，记录同步失败
    this.recordFailure(lastError, operation);
    throw lastError;
  }
  
  recordFailure(error, operation) {
    // 记录失败操作到同步失败记录表
    // 包括操作类型、资源ID、错误信息等
  }
}
```

3. **可恢复与不可恢复错误处理**:
   - **可恢复错误**: 自动进入重试机制，如临时网络问题、API限流等
   - **不可恢复错误**: 标记为失败，记录详细信息，等待手动处理，如资源冲突、权限问题等

4. **降级处理**:
   - 当WPS API持续不可用时，系统会进入降级模式
   - 本地记录所有同步请求，待API恢复后再批量处理
   - 提供本地数据查询功能，降低对WPS API的依赖

5. **批量操作优化**:
   - 失败时自动拆分: 批量请求失败时，自动拆分为小批量重试
   - 批次大小动态调整: 根据API响应时间动态调整批量大小

##### 故障恢复机制

针对系统非正常中断(如断电、服务崩溃等)，实现了完善的故障恢复机制：

1. **同步检查点(Checkpoint)系统**:
   - 同步过程中定期记录检查点，包含当前处理位置、状态等信息
   - 检查点以持久化方式存储到数据库，确保系统重启后可恢复
   - 检查点颗粒度: 大批量同步每1000条记录设置一个检查点
2. **断点续传机制**:

```javascript
// src/services/sync/CheckpointManager.js
class CheckpointManager {
  constructor(batchId) {
    this.batchId = batchId;
  }
  
  async saveCheckpoint(position, metadata) {
    try {
      // 保存检查点到数据库
      await db.syncCheckpoints.upsert({
        batch_id: this.batchId,
        position,
        metadata: JSON.stringify(metadata),
        created_at: new Date()
      });
    } catch (error) {
      logger.error(`Failed to save checkpoint for batch ${this.batchId}:`, error);
      // 检查点保存失败不应中断同步流程，只记录警告
    }
  }
  
  async getLastCheckpoint() {
    try {
      // 获取最后一个检查点
      const checkpoint = await db.syncCheckpoints.findOne({
        where: { batch_id: this.batchId },
        order: [['position', 'DESC']]
      });
      
      return checkpoint ? {
        position: checkpoint.position,
        metadata: JSON.parse(checkpoint.metadata)
      } : null;
    } catch (error) {
      logger.error(`Failed to get last checkpoint for batch ${this.batchId}:`, error);
      return null;
    }
  }
  
  async resumeFromLastCheckpoint(processor) {
    const checkpoint = await this.getLastCheckpoint();
    if (!checkpoint) {
      logger.info(`No checkpoint found for batch ${this.batchId}, starting from beginning`);
      return false;
    }
    
    logger.info(`Resuming sync from checkpoint: position=${checkpoint.position}`);
    
    // 调用处理器从检查点继续处理
    await processor.resumeFromPosition(checkpoint.position, checkpoint.metadata);
    return true;
  }
}
```

3. **自动故障检测与恢复**:
   - 系统启动时自动检查未完成的同步任务
   - 分析最后一个检查点状态，确定恢复策略
   - 对于中断的同步任务，自动从最后检查点恢复

4. **数据一致性验证**:
   - 恢复后执行一致性校验，比对源数据和目标数据
   - 发现不一致时，采取修复策略(如重新同步不一致项)
   - 记录所有一致性问题，生成修复报告

5. **定期完整性扫描**:
   - 每日执行轻量级完整性扫描，验证关键数据一致性
   - 每周执行全面完整性扫描，深度验证所有数据
   - 自动修复常见一致性问题，复杂问题生成修复建议

6. **手动修复工具**:
   - 提供管理界面，展示所有同步失败和一致性问题
   - 支持批量或单个手动修复
   - 修复历史记录和审计日志

#### 3.2.2 打卡请假服务模块

##### 打卡管理模块
- **功能**: 处理学生打卡请求，验证位置和时间有效性
- **关键类**:
  - `CheckinController`: 打卡控制器
  - `CheckinService`: 打卡业务逻辑
  - `LocationValidator`: 位置验证
  - `TimeValidator`: 时间验证

```javascript
// src/services/checkin/CheckinService.js
class CheckinService {
  constructor(dependencies) {
    this.scheduleRepository = dependencies.scheduleRepository;
    this.checkinRepository = dependencies.checkinRepository;
    this.locationValidator = new LocationValidator();
    this.timeValidator = new TimeValidator();
    this.kafkaProducer = dependencies.kafkaProducer;
  }
  
  async processCheckin(userId, scheduleId, checkinData) {
    try {
      // 1. 获取日程信息
      const schedule = await this.scheduleRepository.findById(scheduleId);
      if (!schedule) {
        throw new BusinessError('SCHEDULE_NOT_FOUND', '找不到对应的课程日程');
      }
      
      // 2. 验证时间有效性
      const timeValidation = this.timeValidator.validate(schedule, checkinData.timestamp);
      if (!timeValidation.valid) {
        throw new BusinessError('INVALID_CHECKIN_TIME', timeValidation.message);
      }
      
      // 3. 验证位置有效性
      const locationValidation = await this.locationValidator.validate(
        schedule.location,
        checkinData.coordinates
      );
      if (!locationValidation.valid) {
        throw new BusinessError('INVALID_LOCATION', locationValidation.message);
      }
      
      // 4. 创建打卡记录
      const checkinRecord = {
        userId,
        scheduleId,
        timestamp: checkinData.timestamp,
        location: JSON.stringify(checkinData.coordinates),
        status: timeValidation.status, // 正常、迟到或早退
        device: checkinData.device
      };
      
      // 5. 保存打卡记录(通过消息队列异步处理)
      await this.kafkaProducer.send('checkin-events', {
        eventType: 'CHECKIN_CREATED',
        payload: checkinRecord
      });
      
      // 6. 立即返回用户反馈
      return {
        success: true,
        status: timeValidation.status,
        message: `打卡${timeValidation.status === 'NORMAL' ? '成功' : '已记录，但' + timeValidation.message}`
      };
    } catch (error) {
      logger.error('Checkin process failed:', error);
      if (error instanceof BusinessError) {
        throw error;
      }
      throw new SystemError('CHECKIN_SYSTEM_ERROR', '打卡系统异常，请稍后再试');
    }
  }
}
```

##### 请假管理模块
- **功能**: 处理学生请假申请，创建和跟踪审批流程
- **关键类**:
  - `LeaveController`: 请假控制器
  - `LeaveService`: 请假业务逻辑
  - `LeaveApprovalService`: 请假审批业务
  - `WPSApprovalIntegration`: WPS审批流集成


```javascript
// src/services/leave/LeaveService.js
class LeaveService {
  constructor(dependencies) {
    this.scheduleRepository = dependencies.scheduleRepository;
    this.leaveRepository = dependencies.leaveRepository;
    this.userRepository = dependencies.userRepository;
    this.wpsApprovalIntegration = dependencies.wpsApprovalIntegration;
  }
  
  async createLeaveApplication(userId, leaveData) {
    try {
      // 1. 验证课程信息
      const schedule = await this.scheduleRepository.findById(leaveData.scheduleId);
      if (!schedule) {
        throw new BusinessError('SCHEDULE_NOT_FOUND', '找不到对应的课程');
      }
      
      // 2. 验证请假时间(必须在课程开始前)
      const now = new Date();
      const courseStartTime = new Date(schedule.startTime);
      if (now >= courseStartTime) {
        throw new BusinessError('LEAVE_TIME_INVALID', '课程已开始，无法请假');
      }
      
      // 3. 获取教师信息(审批人)
      const teacherIds = schedule.teacherIds.split(',');
      const approver = await this.userRepository.findByCode(teacherIds[0]);
      if (!approver) {
        throw new BusinessError('APPROVER_NOT_FOUND', '找不到对应的审批教师');
      }
      
      // 4. 创建WPS审批流
      const wpsApprovalData = {
        title: `请假申请: ${schedule.courseName}`,
        applicant: userId,
        approver: approver.wpsAccount,
        content: leaveData.reason,
        startTime: schedule.startTime,
        endTime: schedule.endTime
      };
      
      const approvalResult = await this.wpsApprovalIntegration.createApproval(wpsApprovalData);
      
      // 5. 保存请假记录
      const leaveRecord = {
        userId,
        scheduleId: leaveData.scheduleId,
        reason: leaveData.reason,
        applyTime: now,
        wpsApprovalId: approvalResult.approvalId,
        status: 'PENDING',
        createdAt: now
      };
      
      const savedLeave = await this.leaveRepository.save(leaveRecord);
      
      return {
        success: true,
        leaveId: savedLeave.id,
        status: 'PENDING',
        message: '请假申请已提交，等待教师审批'
      };
    } catch (error) {
      logger.error('Leave application failed:', error);
      if (error instanceof BusinessError) {
        throw error;
      }
      throw new SystemError('LEAVE_SYSTEM_ERROR', '请假系统异常，请稍后再试');
    }
  }
  
  // 其他请假相关方法...
}
``` 

## 4. 完整的数据模型设计

### 4.1 数据库选型与分层

本系统采用多层数据存储架构：
- **MySQL**: 主数据库，存储核心业务数据，确保数据一致性和事务性
- **Redis**: 缓存层，加速查询，减轻数据库压力
- **MongoDB**: 文档存储，用于存储日志和非结构化数据
- **Kafka**: 消息队列，处理异步事件和高并发场景下的数据写入

### 4.2 数据库表设计

#### 4.2.1 用户相关表

##### 用户表 (users)
```sql
CREATE TABLE users (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_code VARCHAR(60) NOT NULL COMMENT '用户编号(学号/工号)',
  user_name VARCHAR(100) NOT NULL COMMENT '用户姓名',
  user_type ENUM('STUDENT', 'TEACHER', 'ADMIN') NOT NULL COMMENT '用户类型',
  wps_account VARCHAR(100) NOT NULL COMMENT 'WPS账号',
  wps_calendar_id VARCHAR(100) COMMENT '日历ID',
  avatar VARCHAR(255) COMMENT '头像URL',
  email VARCHAR(100) COMMENT '邮箱',
  phone VARCHAR(20) COMMENT '手机号',
  status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE' COMMENT '状态',
  last_login DATETIME COMMENT '最后登录时间',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY idx_user_code (user_code),
  UNIQUE KEY idx_wps_account (wps_account)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

##### 用户配置表 (user_configs)
```sql
CREATE TABLE user_configs (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL COMMENT '用户ID',
  config_key VARCHAR(50) NOT NULL COMMENT '配置键',
  config_value TEXT COMMENT '配置值',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY idx_user_config (user_id, config_key),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户配置表';
```

#### 4.2.2 课程相关表

##### 课程表 (courses)
```sql
CREATE TABLE courses (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  kkh VARCHAR(60) NOT NULL COMMENT '开课号',
  kcbh VARCHAR(40) COMMENT '课程编号',
  kcmc VARCHAR(200) NOT NULL COMMENT '课程名称',
  xnxq VARCHAR(20) NOT NULL COMMENT '学年学期',
  need_checkin TINYINT(1) DEFAULT 0 COMMENT '是否需要打卡',
  status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE' COMMENT '状态',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY idx_kkh_xnxq (kkh, xnxq)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程表';
```

##### 课程安排表 (course_arrangements)
```sql
CREATE TABLE course_arrangements (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  course_id BIGINT NOT NULL COMMENT '课程ID',
  jxz INT NOT NULL COMMENT '教学周1-18',
  zc INT NOT NULL COMMENT '周几1-7',
  jc INT NOT NULL COMMENT '节次1-10',
  campus VARCHAR(100) COMMENT '校区',
  building VARCHAR(200) COMMENT '楼群',
  room VARCHAR(200) COMMENT '房间',
  floor VARCHAR(50) COMMENT '楼层',
  teacher_codes VARCHAR(255) COMMENT '教师工号,逗号分隔',
  teacher_names VARCHAR(500) COMMENT '教师姓名,逗号分隔',
  start_time DATETIME NOT NULL COMMENT '开始时间',
  end_time DATETIME NOT NULL COMMENT '结束时间',
  date_str VARCHAR(20) COMMENT '日期字符串',
  original_id VARCHAR(100) COMMENT '原系统ID',
  remarks VARCHAR(255) COMMENT '备注',
  status ENUM('ACTIVE', 'INACTIVE', 'CANCELLED') DEFAULT 'ACTIVE' COMMENT '状态',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (course_id) REFERENCES courses(id),
  UNIQUE KEY idx_course_time (course_id, jxz, zc, jc),
  KEY idx_arrangement_time (start_time, end_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程安排表';
```

##### 学生课程关系表 (student_courses)
```sql
CREATE TABLE student_courses (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  student_id BIGINT NOT NULL COMMENT '学生ID',
  course_id BIGINT NOT NULL COMMENT '课程ID',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY idx_student_course (student_id, course_id),
  FOREIGN KEY (student_id) REFERENCES users(id),
  FOREIGN KEY (course_id) REFERENCES courses(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生课程关系表';
```
#### 4.2.3 日程相关表

##### 日程表 (schedules)
```sql
CREATE TABLE schedules (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL COMMENT '用户ID',
  course_arrangement_id BIGINT NOT NULL COMMENT '课程安排ID',
  wps_event_id VARCHAR(100) NOT NULL COMMENT 'WPS日程ID',
  is_first_class_of_day TINYINT(1) DEFAULT 0 COMMENT '是否当天第一节课',
  status ENUM('ACTIVE', 'UPDATED', 'CANCELLED') DEFAULT 'ACTIVE' COMMENT '状态',
  sync_status ENUM('SYNCED', 'PENDING', 'FAILED') DEFAULT 'SYNCED' COMMENT '同步状态',
  last_sync_time DATETIME COMMENT '最后同步时间',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY idx_user_arrangement (user_id, course_arrangement_id),
  UNIQUE KEY idx_wps_event (wps_event_id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (course_arrangement_id) REFERENCES course_arrangements(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='日程表';
```

#### 4.2.4 打卡相关表

##### 打卡记录表 (checkin_records)
```sql
CREATE TABLE checkin_records (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL COMMENT '用户ID',
  schedule_id BIGINT NOT NULL COMMENT '日程ID',
  checkin_time DATETIME NOT NULL COMMENT '打卡时间',
  location_longitude DECIMAL(10,7) COMMENT '经度',
  location_latitude DECIMAL(10,7) COMMENT '纬度',
  location_accuracy FLOAT COMMENT '位置精度',
  device_info VARCHAR(255) COMMENT '设备信息',
  status ENUM('NORMAL', 'LATE', 'EARLY', 'ABNORMAL') DEFAULT 'NORMAL' COMMENT '状态(正常/迟到/早退/异常)',
  remarks VARCHAR(255) COMMENT '备注',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY idx_user_schedule (user_id, schedule_id),
  KEY idx_checkin_time (checkin_time),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (schedule_id) REFERENCES schedules(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='打卡记录表';
```

##### 打卡设置表 (checkin_settings)
```sql
CREATE TABLE checkin_settings (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  course_id BIGINT COMMENT '课程ID,为空表示全局设置',
  early_minutes INT NOT NULL DEFAULT 15 COMMENT '提前打卡分钟数',
  late_minutes INT NOT NULL DEFAULT 15 COMMENT '延后打卡分钟数',
  location_required TINYINT(1) DEFAULT 1 COMMENT '是否要求位置验证',
  valid_distance INT DEFAULT 200 COMMENT '有效打卡距离(米)',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY idx_course_setting (course_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='打卡设置表';
```

#### 4.2.5 请假相关表

##### 请假记录表 (leave_records)
```sql
CREATE TABLE leave_records (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL COMMENT '用户ID',
  schedule_id BIGINT NOT NULL COMMENT '日程ID',
  reason TEXT NOT NULL COMMENT '请假原因',
  apply_time DATETIME NOT NULL COMMENT '申请时间',
  wps_approval_id VARCHAR(100) NOT NULL COMMENT 'WPS审批流ID',
  status ENUM('PENDING', 'APPROVED', 'REJECTED', 'CANCELLED') DEFAULT 'PENDING' COMMENT '状态',
  approval_time DATETIME COMMENT '审批时间',
  approver_id BIGINT COMMENT '审批人ID',
  approver_comment VARCHAR(255) COMMENT '审批意见',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY idx_user_schedule_leave (user_id, schedule_id),
  KEY idx_wps_approval (wps_approval_id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (schedule_id) REFERENCES schedules(id),
  FOREIGN KEY (approver_id) REFERENCES users(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='请假记录表';
```

#### 4.2.6 统计相关表

##### 出勤统计表 (attendance_stats)
```sql
CREATE TABLE attendance_stats (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT COMMENT '用户ID,为空表示课程统计',
  course_id BIGINT COMMENT '课程ID,为空表示用户统计',
  xnxq VARCHAR(20) NOT NULL COMMENT '学年学期',
  total_classes INT NOT NULL DEFAULT 0 COMMENT '总课程数',
  attended_classes INT NOT NULL DEFAULT 0 COMMENT '出勤数',
  absence_classes INT NOT NULL DEFAULT 0 COMMENT '缺勤数',
  leave_classes INT NOT NULL DEFAULT 0 COMMENT '请假数',
  late_classes INT NOT NULL DEFAULT 0 COMMENT '迟到数',
  early_leave_classes INT NOT NULL DEFAULT 0 COMMENT '早退数',
  attendance_rate DECIMAL(5,2) NOT NULL DEFAULT 0 COMMENT '出勤率',
  last_updated DATETIME NOT NULL COMMENT '最后更新时间',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY idx_stats_scope (user_id, course_id, xnxq)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='出勤统计表';
```

#### 4.2.7 系统相关表

##### 系统配置表 (system_configs)
```sql
CREATE TABLE system_configs (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  config_key VARCHAR(50) NOT NULL COMMENT '配置键',
  config_value TEXT COMMENT '配置值',
  description VARCHAR(255) COMMENT '描述',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY idx_config_key (config_key)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='系统配置表';
```

##### 同步记录表 (sync_logs)
```sql
CREATE TABLE sync_logs (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  sync_type ENUM('COURSE', 'STUDENT', 'CALENDAR', 'EVENT', 'ALL') NOT NULL COMMENT '同步类型',
  batch_id VARCHAR(50) NOT NULL COMMENT '批次ID',
  start_time DATETIME NOT NULL COMMENT '开始时间',
  end_time DATETIME COMMENT '结束时间',
  status ENUM('RUNNING', 'COMPLETED', 'FAILED', 'PARTIALLY_COMPLETED') NOT NULL COMMENT '状态',
  total_count INT NOT NULL DEFAULT 0 COMMENT '总记录数',
  success_count INT NOT NULL DEFAULT 0 COMMENT '成功数',
  fail_count INT NOT NULL DEFAULT 0 COMMENT '失败数',
  error_message TEXT COMMENT '错误信息',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  KEY idx_sync_batch (batch_id),
  KEY idx_sync_time (start_time, end_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='同步记录表';
```

##### 同步失败记录表 (sync_failure_records)
```sql
CREATE TABLE sync_failure_records (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  sync_log_id BIGINT NOT NULL COMMENT '同步日志ID',
  record_type VARCHAR(50) NOT NULL COMMENT '记录类型',
  record_id VARCHAR(100) NOT NULL COMMENT '记录ID',
  error_code VARCHAR(50) COMMENT '错误码',
  error_message TEXT COMMENT '错误信息',
  retry_count INT NOT NULL DEFAULT 0 COMMENT '重试次数',
  last_retry_time DATETIME COMMENT '最后重试时间',
  status ENUM('PENDING', 'RETRYING', 'RESOLVED', 'FAILED') DEFAULT 'PENDING' COMMENT '状态',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (sync_log_id) REFERENCES sync_logs(id),
  KEY idx_record_info (record_type, record_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='同步失败记录表';
```

### 4.3 Redis缓存设计

#### 4.3.1 缓存键设计

| 缓存键模式 | 用途 | 过期时间 | 示例 |
|-----------|-----|---------|------|
| `token:wps:{app_id}` | WPS API访问令牌 | 7200秒 | `token:wps:app123456` |
| `user:profile:{user_id}` | 用户信息缓存 | 1800秒 | `user:profile:1001` |
| `course:detail:{course_id}` | 课程详情缓存 | 3600秒 | `course:detail:2001` |
| `schedule:user:{user_id}:{date}` | 用户某天日程 | 1800秒 | `schedule:user:1001:2023-09-01` |
| `checkin:status:{schedule_id}` | 打卡状态缓存 | 600秒 | `checkin:status:3001` |
| `stats:course:{course_id}` | 课程统计缓存 | 3600秒 | `stats:course:2001` |
| `stats:user:{user_id}` | 用户统计缓存 | 3600秒 | `stats:user:1001` |
| `config:system:{key}` | 系统配置缓存 | 7200秒 | `config:system:sync_interval` |
| `lock:{resource_id}` | 分布式锁 | 30秒 | `lock:checkin:3001` |
| `rate:limit:{ip}:{api}` | API限流计数器 | 60秒 | `rate:limit:192.168.1.1:/api/checkin` |

#### 4.3.2 缓存使用策略

1. **读写策略**:
   - 读操作: Cache-Aside模式，先查缓存，缓存不存在则查数据库并更新缓存
   - 写操作: Write-Through模式，同时更新数据库和缓存

2. **缓存失效策略**:
   - 主动过期: 设置合理的TTL，避免缓存长期不一致
   - 主动更新: 数据变更时主动更新或删除相关缓存
   - 事件驱动: 通过消息队列触发缓存更新

3. **缓存预热**:
   - 系统启动时预加载热点数据
   - 定时任务维护热点缓存

4. **缓存穿透防护**:
   - 对不存在的数据设置空值缓存
   - 使用布隆过滤器快速判断ID是否存在

### 4.4 消息队列设计

#### 4.4.1 Kafka主题设计

| 主题名称 | 用途 | 分区数 | 副本数 | 消息格式 |
|---------|-----|-------|-------|---------|
| `obsync-course-events` | 课程数据变更事件 | 6 | 3 | JSON |
| `obsync-schedule-events` | 日程变更事件 | 6 | 3 | JSON |
| `obsync-checkin-events` | 打卡事件 | 12 | 3 | JSON |
| `obsync-leave-events` | 请假事件 | 6 | 3 | JSON |
| `obsync-sync-events` | 同步事件 | 3 | 3 | JSON |
| `obsync-stats-events` | 统计事件 | 3 | 3 | JSON |
| `obsync-notification-events` | 通知事件 | 6 | 3 | JSON |
| `obsync-dlq` | 死信队列 | 3 | 3 | JSON |

#### 4.4.2 消息格式设计

```json
{
  "id": "msg-uuid-123456",
  "type": "EVENT_TYPE",
  "source": "SERVICE_NAME",
  "timestamp": "2023-09-01T12:00:00Z",
  "correlationId": "correlation-id-123456",
  "payload": {
    // 事件特定数据
  },
  "metadata": {
    "version": "1.0",
    "retry_count": 0
  }
}
```

#### 4.4.3 消费者组设计

| 消费者组 | 订阅主题 | 消费者数量 | 用途 |
|---------|---------|-----------|-----|
| `sync-service-group` | `obsync-course-events` | 3 | 同步服务处理课程变更 |
| `schedule-processor-group` | `obsync-schedule-events` | 3 | 处理日程变更 |
| `checkin-processor-group` | `obsync-checkin-events` | 6 | 处理打卡事件 |
| `leave-processor-group` | `obsync-leave-events` | 3 | 处理请假事件 |
| `stats-calculator-group` | `obsync-checkin-events`, `obsync-leave-events` | 3 | 计算统计数据 |
| `notification-sender-group` | `obsync-notification-events` | 3 | 发送通知 |
| `dlq-processor-group` | `obsync-dlq` | 2 | 处理死信队列 | 

### 4.5 数据模型的作用与完备性分析

本系统设计的数据模型旨在支持完整的课程表同步、打卡和请假业务流程。以下是各主要模型的作用分析：

#### 4.5.1 核心数据模型作用

| 数据模型 | 主要作用 | 关键字段 | 如何满足业务需求 |
|---------|---------|---------|----------------|
| 用户表(users) | 存储用户基本信息 | user_code, wps_account | 建立源系统与WPS账号映射关系，支持身份认证和权限管理 |
| 课程表(courses) | 存储课程基本信息 | kkh, kcmc, xnxq | 作为课程主体信息，与安排表一起支持课程数据同步 |
| 课程安排表(course_arrangements) | 存储课程具体时间地点安排 | jxz, zc, jc, start_time | 提供课程具体安排信息，是生成日程的数据源 |
| 学生课程关系表(student_courses) | 维护学生与课程的多对多关系 | student_id, course_id | 确定哪些学生需要同步哪些课程日程 |
| 日程表(schedules) | 记录同步到WPS的日程信息 | user_id, course_arrangement_id, wps_event_id | 维护本地日程与WPS日程的映射关系，是同步状态的关键 |
| 打卡记录表(checkin_records) | 存储学生打卡数据 | user_id, schedule_id, checkin_time | 记录所有打卡行为，支持考勤统计 |
| 请假记录表(leave_records) | 存储请假申请和审批数据 | user_id, schedule_id, wps_approval_id | 记录请假流程，与打卡记录共同支持考勤统计 |
| 出勤统计表(attendance_stats) | 汇总统计考勤数据 | user_id, course_id, xnxq | 提供预计算的统计数据，提高查询效率 |
| 同步记录表(sync_logs) | 记录同步过程和结果 | sync_type, batch_id, status | 支持同步监控和故障恢复 |
| 同步检查点表(sync_checkpoints) | 记录同步过程中的检查点 | batch_id, position | 支持断点续传和故障恢复 |
| 同步失败记录表(sync_failure_records) | 记录同步失败的具体项 | sync_log_id, record_type, record_id | 支持失败项的重试和手动修复 |

#### 4.5.2 数据模型的完备性分析

系统数据模型设计考虑了以下维度，确保能满足所有业务需求：

1. **实体关系完备性**:
   - 用户-课程-日程: 完整映射关系链
   - 源数据-目标数据: 建立源系统与WPS平台的映射关系
   - 业务状态追踪: 记录所有业务状态变更

2. **业务流程支持**:
   - 同步流程: 支持增量/全量同步，记录同步状态和结果
   - 打卡流程: 支持位置验证、时间验证，记录打卡结果
   - 请假流程: 支持申请、审批、状态追踪
   - 统计分析: 支持多维度统计和报表生成

3. **扩展性考虑**:
   - 预留扩展字段: 如`metadata`字段存储JSON格式的扩展数据
   - 状态字段枚举预留: 状态枚举预留未来可能的状态值
   - 版本化设计: 支持数据模型未来版本升级

4. **同步场景支持**:
   - 新增课程/安排: 通过状态字段识别并处理
   - 更新课程/安排: 通过对比检测变更并同步
   - 取消课程/安排: 支持软删除和状态变更
   - 恢复课程/安排: 支持状态恢复和重新激活

5. **数据同步一致性保障**:
   - 事务记录: 记录所有同步操作，支持回滚
   - 版本控制: 使用版本号控制并发更新
   - 双向验证: 支持源数据和目标数据的双向验证

#### 4.5.3 特殊业务场景支持

数据模型设计特别考虑了以下特殊业务场景：

1. **课程变更场景**:
   - 课程时间变更: 通过course_arrangements表的状态和更新时间跟踪
   - 课程地点变更: 同样通过变更记录处理
   - 课程取消/恢复: 通过状态字段管理

2. **大规模数据处理**:
   - 学期初全量同步: 通过batch_id和检查点机制支持
   - 日常增量同步: 通过时间戳和状态标记支持
   - 紧急修复同步: 通过优先级和选择性同步支持

3. **特殊考勤场景**:
   - 代课情况: 通过记录原教师和实际教师支持
   - 临时调课: 通过日程特殊标记支持
   - 补课安排: 通过额外日程创建支持

4. **数据迁移与归档**:
   - 学期结束数据归档: 支持按学期归档历史数据
   - 历史数据查询: 支持从归档表查询历史数据
   - 数据导出与备份: 支持结构化导出统计数据

以上数据模型设计确保了系统能够满足课程表同步和考勤管理的各种业务场景，同时为未来的功能扩展和优化预留了空间。

#### 4.5.4 并行同步与数据一致性保障

数据模型设计特别考虑了同步过程中的并行处理场景和数据一致性保障：

1. **全量同步与增量同步并行处理**:

   学期初全量同步耗时较长（可能长达数小时），在此期间有可能发生课程数据变更，系统需要确保这些增量变更能够被正确处理而不会丢失。针对"学期初全量同步未完成但有增量数据到达"的场景，系统采用以下策略：

   ```
   ┌────────────────────┐                      ┌────────────────────┐
   │  全量同步进行中    │◀────────同步状态──────┤  增量数据到达      │
   └─────────┬──────────┘                      └──────────┬─────────┘
             │                                            │
             ▼                                            ▼
   ┌────────────────────┐                      ┌────────────────────┐
   │ 记录当前同步进度   │                      │ 将数据写入缓冲队列  │
   └─────────┬──────────┘                      └──────────┬─────────┘
             │                                            │
             ▼                                            │
   ┌────────────────────┐                                 │
   │ 全量同步继续进行   │                                 │
   └─────────┬──────────┘                                 │
             │                                            │
             ▼                                            ▼
   ┌────────────────────┐                      ┌────────────────────┐
   │ 检查全量同步范围   │───────────────────────┤ 记录数据变更时间戳 │
   └─────────┬──────────┘                      └──────────┬─────────┘
             │                                            │
             ▼                                            ▼
   ┌────────────────────┐                      ┌────────────────────┐
   │ 完成全量同步       │                      │ 缓冲队列等待处理   │
   └─────────┬──────────┘                      └──────────┬─────────┘
             │                                            │
             └─────────────────┬──────────────────────────┘
                               ▼
                     ┌────────────────────┐
                     │ 处理增量数据队列   │
                     └─────────┬──────────┘
                               ▼
                     ┌────────────────────┐
                     │ 对比时间戳与全量   │
                     │ 同步完成时间       │
                     └─────────┬──────────┘
                               ▼
                     ┌────────────────────┐
                     │ 应用未覆盖的变更   │
                     └────────────────────┘
   ```

2. **增量数据处理策略**:

   - **增量数据缓冲**: 全量同步期间收到的增量数据存入专用的缓冲队列
   - **时间戳记录**: 为每条增量数据记录接收时间戳
   - **全量同步范围追踪**: 记录全量同步的数据范围和截止时间
   - **后处理机制**: 全量同步完成后，处理缓冲队列中的数据：
     - 对比增量数据时间戳与全量同步的截止时间
     - 只应用全量同步截止时间之后的变更，避免重复更新
     - 冲突时优先采用时间戳更新的数据

3. **同步状态管理**:

   - **同步进度表**: 记录各类同步任务的执行状态和进度
   ```sql
   CREATE TABLE sync_execution_state (
     id BIGINT PRIMARY KEY AUTO_INCREMENT,
     sync_type ENUM('FULL', 'INCREMENTAL', 'MANUAL') NOT NULL,
     entity_type VARCHAR(50) NOT NULL COMMENT '同步实体类型',
     batch_id VARCHAR(50) NOT NULL COMMENT '批次ID',
     start_timestamp DATETIME NOT NULL COMMENT '开始时间',
     end_timestamp DATETIME COMMENT '结束时间',
     status ENUM('RUNNING', 'COMPLETED', 'FAILED', 'PAUSED') NOT NULL,
     progress FLOAT NOT NULL DEFAULT 0 COMMENT '进度百分比',
     current_position VARCHAR(255) COMMENT '当前同步位置标识',
     affected_records INT DEFAULT 0 COMMENT '已处理记录数',
     data_range JSON COMMENT '数据范围描述',
     created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
     updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
     UNIQUE KEY idx_batch_id (batch_id),
     KEY idx_status_type (status, sync_type)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='同步执行状态表';
   ```
   
   - **变更队列管理**: 使用专用队列存储和管理增量变更
   ```sql
   CREATE TABLE data_change_buffer (
     id BIGINT PRIMARY KEY AUTO_INCREMENT,
     entity_type VARCHAR(50) NOT NULL COMMENT '实体类型',
     entity_id VARCHAR(100) NOT NULL COMMENT '实体ID',
     operation_type ENUM('CREATE', 'UPDATE', 'DELETE') NOT NULL,
     payload JSON NOT NULL COMMENT '变更数据',
     received_at DATETIME NOT NULL COMMENT '接收时间戳',
     priority INT DEFAULT 0 COMMENT '处理优先级',
     attempts INT DEFAULT 0 COMMENT '处理尝试次数',
     status ENUM('PENDING', 'PROCESSING', 'APPLIED', 'FAILED') DEFAULT 'PENDING',
     created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
     updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
     KEY idx_status_priority (status, priority),
     KEY idx_entity (entity_type, entity_id)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='数据变更缓冲表';
   ```

4. **并发控制机制**:

   - **锁机制**: 使用分布式锁确保同一实体只被一个进程同步
   - **版本控制**: 使用乐观锁和版本号防止并发更新冲突
   - **事务边界**: 明确定义事务边界，保证关联操作的一致性

5. **数据一致性校验**:

   - **定期校验**: 全量同步完成后执行数据一致性校验
   - **差异修复**: 发现不一致时自动触发修复流程
   - **人工干预**: 复杂冲突提供人工干预界面

通过以上机制，系统能够确保在学期初全量同步期间也不会丢失增量变更，同时保障数据的一致性和完整性。

### 4.6 考勤表设计与处理流程

针对考勤场景的大数据量处理需求，本系统设计了一套完整的考勤数据处理机制。

#### 4.6.1 考勤预置表设计

为提高考勤数据处理效率，系统引入考勤预置表结构：

```sql
CREATE TABLE attendance_roster (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  schedule_id BIGINT NOT NULL COMMENT '日程ID',
  course_id BIGINT NOT NULL COMMENT '课程ID',
  course_date DATE NOT NULL COMMENT '课程日期',
  jxz INT NOT NULL COMMENT '教学周',
  zc INT NOT NULL COMMENT '星期几',
  jc INT NOT NULL COMMENT '节次',
  total_students INT NOT NULL DEFAULT 0 COMMENT '应到人数',
  attended_count INT NOT NULL DEFAULT 0 COMMENT '实到人数',
  absent_count INT NOT NULL DEFAULT 0 COMMENT '未到人数',
  leave_count INT NOT NULL DEFAULT 0 COMMENT '请假人数',
  late_count INT NOT NULL DEFAULT 0 COMMENT '迟到人数',
  early_count INT NOT NULL DEFAULT 0 COMMENT '早退人数',
  status ENUM('PENDING', 'IN_PROGRESS', 'COMPLETED') DEFAULT 'PENDING' COMMENT '考勤状态',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY idx_schedule_date (schedule_id, course_date),
  KEY idx_course_date (course_id, course_date),
  KEY idx_date_status (course_date, status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='考勤花名册主表';

CREATE TABLE attendance_roster_detail (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  roster_id BIGINT NOT NULL COMMENT '花名册ID',
  user_id BIGINT NOT NULL COMMENT '学生ID',
  status ENUM('PENDING', 'ATTENDED', 'ABSENT', 'LEAVE', 'LATE', 'EARLY') DEFAULT 'PENDING' COMMENT '出勤状态',
  checkin_id BIGINT COMMENT '打卡记录ID',
  leave_id BIGINT COMMENT '请假记录ID',
  remark VARCHAR(255) COMMENT '备注',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY idx_roster_user (roster_id, user_id),
  KEY idx_user_status (user_id, status),
  FOREIGN KEY (roster_id) REFERENCES attendance_roster(id),
  FOREIGN KEY (user_id) REFERENCES users(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='考勤花名册明细表';
```

#### 4.6.2 考勤表自动预置流程

系统会在课程创建或变更时，自动预置考勤表数据：

1. **触发时机**:
   - 学期初全量课表导入完成后
   - 新增课程或课程安排时
   - 课程变更(如调课)时

2. **预置流程**:

```javascript
// src/services/attendance/RosterGenerator.js
class RosterGenerator {
  async generateCourseRosters(courseId, semester) {
    // 1. 获取课程信息和学生名单
    const course = await this.courseRepository.findById(courseId);
    const arrangements = await this.arrangementRepository.findByCourseId(courseId);
    const students = await this.studentRepository.findByCourseId(courseId);
    
    // 2. 为每个课程安排生成考勤名册
    const rosterPromises = arrangements.map(async arrangement => {
      // 计算课程具体日期
      const courseDate = this.calculateCourseDate(arrangement, semester);
      
      // 创建考勤名册主表
      const roster = await this.rosterRepository.create({
        schedule_id: arrangement.id,
        course_id: courseId,
        course_date: courseDate,
        jxz: arrangement.jxz,
        zc: arrangement.zc,
        jc: arrangement.jc,
        total_students: students.length,
        status: 'PENDING'
      });
      
      // 创建考勤名册明细
      const detailPromises = students.map(student => 
        this.rosterDetailRepository.create({
          roster_id: roster.id,
          user_id: student.id,
          status: 'PENDING'
        })
      );
      
      await Promise.all(detailPromises);
      return roster;
    });
    
    return Promise.all(rosterPromises);
  }
  
  // 其他辅助方法...
}
```

3. **分批处理**:
   - 大课程分批生成: 学生超过500人的大课程分批处理
   - 异步任务队列: 使用任务队列异步处理预置任务
   - 定时任务: 每天提前生成第二天的考勤表

#### 4.6.3 考勤数据实时处理流程

系统处理打卡和请假时，会实时更新考勤状态：

1. **打卡处理流程**:
   ```javascript
   // 打卡成功后更新考勤状态
   async updateAttendanceStatus(userId, scheduleId, checkinTime, status) {
     // 1. 查找对应的考勤名册
     const roster = await this.rosterRepository.findByScheduleId(scheduleId);
     if (!roster) {
       // 考勤名册不存在，自动创建
       await this.createRosterForSchedule(scheduleId);
       return this.updateAttendanceStatus(userId, scheduleId, checkinTime, status);
     }
     
     // 2. 更新学生考勤状态
     const attendanceStatus = this.mapCheckinStatusToAttendance(status);
     await this.rosterDetailRepository.update(
       { status: attendanceStatus, checkin_id: checkinId },
       { where: { roster_id: roster.id, user_id: userId } }
     );
     
     // 3. 更新考勤名册状态计数
     await this.updateRosterCounts(roster.id);
   }
   ```

2. **请假处理流程**:
   ```javascript
   // 请假审批通过后更新考勤状态
   async updateLeaveStatus(userId, scheduleId, leaveId) {
     // 1. 查找对应的考勤名册
     const roster = await this.rosterRepository.findByScheduleId(scheduleId);
     
     // 2. 更新学生考勤状态为请假
     await this.rosterDetailRepository.update(
       { status: 'LEAVE', leave_id: leaveId },
       { where: { roster_id: roster.id, user_id: userId } }
     );
     
     // 3. 更新考勤名册状态计数
     await this.updateRosterCounts(roster.id);
   }
   ```

3. **状态优先级处理**:
   - 状态冲突时的优先级: 请假 > 打卡 > 缺勤
   - 打卡状态细分优先级: 正常 > 迟到/早退 > 异常
   - 未处理状态定时更新: 系统定时将未操作的"待处理"状态更新为"缺勤"

#### 4.6.4 考勤统计计算流程

系统通过以下流程计算各类考勤人员：

1. **实时计算流程**:
   ```javascript
   // 更新花名册状态统计
   async updateRosterCounts(rosterId) {
     // 聚合查询各状态人数
     const counts = await this.rosterDetailRepository.findAll({
       attributes: ['status', [Sequelize.fn('COUNT', Sequelize.col('id')), 'count']],
       where: { roster_id: rosterId },
       group: ['status']
     });
     
     // 转换为状态计数映射
     const statusCounts = counts.reduce((acc, item) => {
       acc[item.status] = parseInt(item.get('count'));
       return acc;
     }, {
       PENDING: 0,
       ATTENDED: 0,
       ABSENT: 0,
       LEAVE: 0,
       LATE: 0,
       EARLY: 0
     });
     
     // 更新花名册主表的统计状态
     const total = Object.values(statusCounts).reduce((sum, count) => sum + count, 0);
     const allProcessed = statusCounts.PENDING === 0;
     
     await this.rosterRepository.update({
       attended_count: statusCounts.ATTENDED,
       absent_count: statusCounts.ABSENT,
       leave_count: statusCounts.LEAVE,
       late_count: statusCounts.LATE,
       early_count: statusCounts.EARLY,
       status: allProcessed ? 'COMPLETED' : 'IN_PROGRESS'
     }, { where: { id: rosterId } });
     
     // 同步更新课程和学生的汇总统计数据
     await this.syncAttendanceStats(rosterId);
   }
   ```

2. **应到/实到/未到/请假计算逻辑**:
   - **应到人数**: 关联课程的所有学生数量
   - **实到人数**: 状态为"已到"+"迟到"+"早退"的学生数量
   - **未到人数**: 状态为"缺勤"的学生数量
   - **请假人数**: 状态为"请假"的学生数量

3. **边缘情况处理**:
   - 迟到后请假: 保持"迟到"状态，记录请假信息
   - 请假后打卡: 根据配置决定是否覆盖"请假"状态
   - 取消课程: 自动将对应考勤表标记为"已取消"

#### 4.6.5 考勤数据查询优化

为支持高效的考勤数据查询，系统采用以下优化策略：

1. **多级缓存设计**:
   - L1缓存: Redis缓存热门考勤数据，TTL为10分钟
   - L2缓存: 预计算汇总表 attendance_stats 存储聚合数据
   - 写入策略: 写透策略，确保数据一致性

2. **查询优化示例**:
   ```javascript
   // 获取课程考勤统计(带缓存)
   async getCourseAttendanceStats(courseId, date) {
     // 1. 尝试从Redis缓存获取
     const cacheKey = `attendance:course:${courseId}:${date}`;
     const cached = await redisClient.get(cacheKey);
     if (cached) {
       return JSON.parse(cached);
     }
     
     // 2. 从数据库查询
     const result = await this.rosterRepository.findAll({
       attributes: [
         [Sequelize.fn('SUM', Sequelize.col('total_students')), 'total'],
         [Sequelize.fn('SUM', Sequelize.col('attended_count')), 'attended'],
         [Sequelize.fn('SUM', Sequelize.col('absent_count')), 'absent'],
         [Sequelize.fn('SUM', Sequelize.col('leave_count')), 'leave']
       ],
       where: {
         course_id: courseId,
         course_date: date
       }
     });
     
     // 3. 计算并缓存结果
     const stats = result[0].get();
     await redisClient.set(cacheKey, JSON.stringify(stats), 'EX', 600);
     
     return stats;
   }
   ```

3. **分页与条件查询优化**:
   - 索引优化: 为常用查询条件创建复合索引
   - 分页预加载: 采用"上拉加载更多"的分页模式
   - 条件筛选: 在SQL层面进行过滤，减少传输数据量

以上考勤表设计和处理流程，确保了系统能够高效处理大量的考勤数据，同时提供快速的查询响应。

### 4.7 大数据量处理策略与分片分表设计

针对系统面临的海量数据挑战，特别是考勤数据的高并发写入和多维度查询需求，系统设计了全面的数据处理策略。

#### 4.7.1 数据量分析与挑战

基于系统规模预估，本系统需要处理的数据量级如下：

| 数据类型 | 预估数量 | 增长速度 | 主要挑战 |
|---------|---------|---------|---------|
| 用户数据 | 5-10万 | 稳定，每学期小幅增长 | 用户身份同步与映射 |
| 课程数据 | 1-3万/学期 | 每学期更新 | 快速同步变更 |
| 课程安排数据 | 30-50万/学期 | 每学期更新 | 按师生筛选效率 |
| 日程数据 | 约500万 | 每学期新增约500万 | WPS API同步效率，查询响应时间 |
| 考勤数据 | 千万级/学期 | 持续累积 | 写入并发与统计查询 |

针对首次同步效率和百万级日程数据查询，系统面临以下主要挑战：
1. WPS API单次调用耗时(~200ms)在大数据量下导致同步时间过长
2. 百万级数据表查询性能下降
3. 全量数据一次性导入的资源消耗问题
4. 增量数据追踪与全量数据的一致性保证

#### 4.7.2 首次大规模同步优化策略

针对首次500万级日程数据同步，考虑到协作开放平台API不支持并行请求、必须顺序处理且单次请求耗时约150ms的限制，系统采用以下策略提升效率：

1. **数据分层与优先级策略**:
   - **仅同步本学期数据**: 根据实际需求，学期初只同步本学期的课程数据
     ```
     ┌─────────────────┐
     │ 阶段1: 近期课程 │ → 当前周和未来2周课程，立即同步(约15%)
     └────────┬────────┘
              ↓
     ┌─────────────────┐
     │ 阶段2: 中期课程 │ → 未来3-10周课程，次日凌晨同步(约40%)
     └────────┬────────┘
              ↓
     ┌─────────────────┐
     │ 阶段3: 远期课程 │ → 本学期剩余课程(11周后)，低峰期同步(约45%)
     └────────┬────────┘
              ↓
     ┌─────────────────┐
     │ 完成学期同步    │
     └─────────────────┘
     ```
   
   - **精准用户分组**: 针对本学期实际教学需求，按用户角色和课程安排优先级分组
     ```javascript
     // 用户优先级划分 - 本学期实际情况
     const USER_PRIORITY = {
       CRITICAL: 10,  // 当前周任课教师
       HIGH: 8,       // 近两周任课教师和学生
       MEDIUM: 5,     // 本学期其他在任教师
       NORMAL: 3,     // 常规使用学生
       LOW: 1         // 临时用户
     };
     
     // 计算本学期用户同步优先级
     function calculateSemesterPriority(user) {
       // 当前周是否有课
       const hasCurrentWeekCourses = hasCoursesInWeek(user.id, getCurrentWeek());
       if (hasCurrentWeekCourses && user.role === 'TEACHER') return USER_PRIORITY.CRITICAL;
       
       // 近两周是否有课
       const hasNearFutureCourses = hasCoursesInWeekRange(user.id, getCurrentWeek() + 1, getCurrentWeek() + 2);
       if (hasNearFutureCourses) return USER_PRIORITY.HIGH;
       
       // 角色和活跃度评分
       if (user.role === 'TEACHER') return USER_PRIORITY.MEDIUM;
       
       return user.isActive ? USER_PRIORITY.NORMAL : USER_PRIORITY.LOW;
     }
     ```

2. **单线程优化策略**:
   - **顺序优化处理**: 由于API必须顺序处理，针对150ms请求限制优化单线程执行效率
     ```javascript
     // 高效顺序处理器
     class EfficientSequentialProcessor {
       constructor(options = {}) {
         this.batchSize = options.batchSize || 30;
         this.requestQueue = [];
         this.isProcessing = false;
         this.stats = {
           totalProcessed: 0,
           successCount: 0,
           failureCount: 0,
           avgResponseTime: 0
         };
         this.checkpointInterval = options.checkpointInterval || 100;
         this.checkpointManager = new SyncCheckpointManager();
       }
       
       // 添加同步任务
       addTasks(tasks, priority) {
         // 按优先级包装任务
         const wrappedTasks = tasks.map(task => ({
           task,
           priority,
           addedAt: Date.now()
         }));
         
         // 添加到队列并排序
         this.requestQueue.push(...wrappedTasks);
         this.sortQueueByPriority();
         
         // 如果处理器空闲，启动处理
         if (!this.isProcessing) {
           this.startProcessing();
         }
       }
       
       // 按优先级排序队列
       sortQueueByPriority() {
         this.requestQueue.sort((a, b) => {
           // 先按优先级
           const priorityDiff = b.priority - a.priority;
           if (priorityDiff !== 0) return priorityDiff;
           
           // 同优先级按添加时间
           return a.addedAt - b.addedAt;
         });
       }
       
       // 开始处理队列
       async startProcessing() {
         if (this.isProcessing) return;
         this.isProcessing = true;
         
         try {
           while (this.requestQueue.length > 0) {
             // 提取下一批任务
             const currentBatch = this.requestQueue.splice(0, this.batchSize);
             
             // 记录批次开始时间
             const batchStartTime = Date.now();
             
             try {
               // 执行批量请求
               const result = await this.processBatch(currentBatch.map(item => item.task));
               
               // 更新统计
               this.stats.totalProcessed += currentBatch.length;
               this.stats.successCount += currentBatch.length;
               
               // 计算响应时间
               const elapsed = Date.now() - batchStartTime;
               this.updateResponseTimeStats(elapsed);
               
               // 根据响应时间微调下一批大小
               this.adjustBatchSize(elapsed, currentBatch.length);
             } catch (error) {
               // 处理失败的批次
               logger.error(`Batch processing failed: ${error.message}`);
               this.stats.failureCount += currentBatch.length;
               
               // 单个重试失败项
               this.requeueFailedItems(currentBatch);
             }
             
             // 定期保存检查点
             if (this.stats.totalProcessed % this.checkpointInterval === 0) {
               await this.saveCheckpoint();
             }
             
             // 小延迟避免CPU过度占用
             await this.delay(20);
           }
         } finally {
           this.isProcessing = false;
           await this.saveCheckpoint();
           logger.info(`Queue processing completed: ${JSON.stringify(this.stats)}`);
         }
       }
       
       // 根据响应时间优化批次大小
       adjustBatchSize(responseTime, currentBatchSize) {
         const targetResponseTime = 1000; // 目标1秒左右
         
         if (responseTime > targetResponseTime * 1.5) {
           // 响应时间过长，减小批次
           this.batchSize = Math.max(10, Math.floor(this.batchSize * 0.8));
           logger.info(`Reducing batch size to ${this.batchSize} due to slow response time`);
         } else if (responseTime < targetResponseTime * 0.7 && currentBatchSize === this.batchSize) {
           // 响应时间较短，可以增加批次
           this.batchSize = Math.min(50, Math.floor(this.batchSize * 1.2));
           logger.info(`Increasing batch size to ${this.batchSize} due to fast response time`);
         }
       }
     }
     ```

3. **多服务器协同优化**:
   - **按独立数据集拆分**: 由于API不支持并行，拆分数据到多个独立同步流程
     ```
     ┌────────────────────┐
     │ 主协调服务         │ → 分配数据集但不执行API调用
     └─────┬───┬───┬──────┘
           │   │   │
     ┌─────▼─┐ ┌─▼───┐ ┌─▼───┐
     │服务器1│ │服务器2│ │服务器3│ → 各自处理独立数据集
     └───────┘ └─────┘ └─────┘
     ```
   
   - **数据隔离原则**: 确保不同服务器处理的数据集完全独立，避免数据冲突
     ```javascript
     // 数据集划分策略
     function partitionDataSets(allData, serverCount) {
       const partitions = [];
       
       // 1. 按教学单位(学院)分组数据
       const departmentGroups = groupByDepartment(allData);
       
       // 2. 为每个服务器分配若干个完整的学院
       for (let i = 0; i < serverCount; i++) {
         partitions[i] = [];
       }
       
       // 3. 负载均衡分配，确保各服务器工作量接近
       let currentServerIndex = 0;
       const sortedDepts = sortDepartmentsBySize(departmentGroups);
       
       for (const dept of sortedDepts) {
         partitions[currentServerIndex].push(dept);
         currentServerIndex = (currentServerIndex + 1) % serverCount;
       }
       
       return partitions;
     }
     ```
   
   - **资源独占分配**: 每个服务器独占处理特定学院/班级数据，避免竞争条件

4. **缓存与预处理优化**:
   - **预计算批量数据**: 提前计算和准备批次请求数据，减少API调用期间的处理时间
     ```javascript
     // 预处理同步数据
     async function prepareDataForSync(courses, users) {
       logger.info('Starting data preparation for sync');
       
       // 1. 预先计算每个用户的日程数据
       const userSchedules = {};
       
       // 并行预处理（本地计算可以并行）
       await Promise.all(users.map(async user => {
         const userCourses = await getUserCourses(user.id);
         userSchedules[user.id] = await preprocessUserSchedules(user, userCourses);
         logger.debug(`Prepared ${userSchedules[user.id].length} schedules for user ${user.id}`);
       }));
       
       // 2. 按同步批次组织数据
       const batchedData = {};
       for (const userId in userSchedules) {
         const priority = calculateUserPriority(users.find(u => u.id === userId));
         
         if (!batchedData[priority]) {
           batchedData[priority] = [];
         }
         
         batchedData[priority].push({
           userId,
           schedules: userSchedules[userId]
         });
       }
       
       logger.info(`Data preparation completed: ${Object.keys(userSchedules).length} users processed`);
       return batchedData;
     }
     ```
   
   - **本地缓存优化**: 缓存频繁使用的数据，减少计算开销
   - **异步数据预取**: 在当前批次处理时预取下一批次数据
   - **增量队列管理**: 维护增量变更队列，在同步期间捕获数据变化

#### 4.7.3 百万级日程数据查询优化

针对500万级日程数据的查询效率问题，系统采用以下优化策略：

1. **数据库层优化**:
   - **表分区设计**:
     ```sql
     -- 按学期和用户范围分区
     CREATE TABLE schedules (
       id BIGINT PRIMARY KEY AUTO_INCREMENT,
       user_id BIGINT NOT NULL,
       semester VARCHAR(20) NOT NULL,
       -- 其他字段
       created_at DATETIME NOT NULL,
       KEY idx_user_semester (user_id, semester)
     ) ENGINE=InnoDB
     PARTITION BY RANGE COLUMNS(semester) (
       PARTITION p_2023_01 VALUES LESS THAN ('2023-02'),
       PARTITION p_2023_02 VALUES LESS THAN ('2023-08'),
       PARTITION p_2023_03 VALUES LESS THAN ('2024-02'),
       -- 可动态添加新分区
       PARTITION p_future VALUES LESS THAN (MAXVALUE)
     );
     ```
   
   - **索引优化**:
     - 复合索引覆盖常见查询条件
     - 部分索引减小索引体积
     - 自适应哈希索引加速热点查询
   
   - **定期优化**:
     - 自动化统计信息收集
     - 定期索引碎片整理
     - 执行计划监控与调整

2. **缓存策略**:
   - **多级缓存架构**:
     ```
     应用层缓存(内存) → Redis缓存(近期数据) → 数据库(全量数据)
     ```
   
   - **高效缓存设计**:
     ```javascript
     // 用户日程缓存服务
     class ScheduleCacheService {
       // 近期日程高速缓存
       async getUserRecentSchedules(userId, options = {}) {
         const cacheKey = `user:${userId}:recent_schedules:${this.buildOptionHash(options)}`;
         
         // 尝试从缓存获取
         let result = await this.cache.get(cacheKey);
         if (result) return this.deserialize(result);
         
         // 缓存未命中，从数据库获取
         result = await this.scheduleRepository.findUserRecentSchedules(userId, options);
         
         // 存入缓存，设置短过期时间（近期数据变化频繁）
         await this.cache.set(cacheKey, this.serialize(result), {
           ttl: 60 * 5 // 5分钟
         });
         
         return result;
       }
       
       // 学期课表缓存（变化较少）
       async getUserSemesterSchedules(userId, semester, options = {}) {
         const cacheKey = `user:${userId}:semester:${semester}:${this.buildOptionHash(options)}`;
         
         // 尝试从缓存获取
         let result = await this.cache.get(cacheKey);
         if (result) return this.deserialize(result);
         
         // 缓存未命中，从数据库获取
         result = await this.scheduleRepository.findUserSemesterSchedules(userId, semester, options);
         
         // 学期数据相对稳定，可以缓存更长时间
         await this.cache.set(cacheKey, this.serialize(result), {
           ttl: 60 * 60 * 12 // 12小时
         });
         
         return result;
       }
     }
     ```
   
   - **智能缓存策略**:
     - 热点数据识别与优先缓存
     - 访问频率自适应缓存时间
     - 查询结果集拆分缓存

3. **查询优化技术**:
   - **查询重写与优化**:
     - 分解复杂查询为简单查询
     - 使用查询提示(hint)优化执行计划
     - 避免关联查询，使用多次简单查询
   
   - **视图与物化视图**:
     - 预计算常用统计数据
     - 定期更新物化视图
     - 查询路由自动选择最优数据源
   
   - **流式查询处理**:
     ```javascript
     // 大数据量查询使用流式处理
     async function exportUserSchedules(userId, semester) {
       // 创建导出文件流
       const outputStream = createWriteStream(`exports/schedules_${userId}_${semester}.csv`);
       
       // 写入头部
       outputStream.write('日期,星期,节次,课程,教师,地点\n');
       
       // 使用流式查询，避免大量数据载入内存
       const queryStream = this.scheduleRepository.createQueryStream({
         userId,
         semester,
         batchSize: 1000 // 每批次处理的记录数
       });
       
       return new Promise((resolve, reject) => {
         queryStream.on('data', (schedule) => {
           // 转换并写入数据
           const line = formatScheduleToCSV(schedule);
           outputStream.write(line + '\n');
         });
         
         queryStream.on('end', () => {
           outputStream.end();
           resolve('导出完成');
         });
         
         queryStream.on('error', (err) => {
           outputStream.end();
           reject(err);
         });
       });
     }
     ```

4. **应用层优化**:
   - **查询分流与服务拆分**:
     - 读写分离，读请求路由到只读副本
     - 复杂查询和报表专用服务
     - 按用户分组的微服务拆分
   
   - **按需加载与分页优化**:
     - 基于光标(Cursor)的分页代替偏移分页
     - 虚拟滚动实现大数据集展示
     - 惰性加载和动态缓存管理
   
   - **预测加载技术**:
     - 根据用户行为预测可能的查询
     - 空闲时预加载下一页数据
     - 基于时间段的数据预取

5. **数据聚合与预计算**:
   - **实时汇总表维护**:
     - 使用触发器或变更数据捕获(CDC)
     - 增量更新统计数据
     - 定期全量校验确保准确性
   
   - **多维度统计预计算**:
     - 按学期、课程、教师维度
     - 按时间段（周/天）维度
     - 复合维度（如课程+时间）
   
   - **非规范化设计**:
     - 适度冗余减少表连接
     - 复合视图覆盖常见查询路径
     - 读写分离的数据结构设计

#### 4.7.4 多维度查询优化

在日程数据的多维度查询方面，系统实现了以下优化：

1. **自适应查询路由**:
   ```javascript
   // 查询路由器
   class QueryRouter {
     constructor(repositories, cacheServices) {
       this.repositories = repositories;
       this.cacheServices = cacheServices;
       this.queryAnalyzer = new QueryAnalyzer();
     }
     
     // 智能路由查询到最优数据源
     async routeScheduleQuery(query) {
       // 分析查询特征
       const queryFeatures = this.queryAnalyzer.analyze(query);
       
       // 简单查询且可能命中缓存
       if (queryFeatures.isCacheable && !queryFeatures.isComplex) {
         try {
           // 尝试从缓存获取
           const result = await this.cacheServices.schedule.getByQuery(query);
           if (result) return result;
         } catch (err) {
           logger.warn('Cache miss or error:', err);
         }
       }
       
       // 复杂统计查询路由到预计算服务
       if (queryFeatures.isStatistical) {
         return this.repositories.scheduleStats.query(query);
       }
       
       // 历史数据查询路由到归档存储
       if (queryFeatures.isHistorical) {
         return this.repositories.scheduleArchive.query(query);
       }
       
       // 全文搜索路由到搜索引擎
       if (queryFeatures.isFullTextSearch) {
         return this.searchService.search(query);
       }
       
       // 默认路由到主数据库
       return this.repositories.schedule.query(query);
     }
   }
   ```

2. **查询模式识别与优化**:
   - 常见查询模式预定义优化策略
   - 查询复杂度评估与自动优化
   - 查询计划缓存减少编译开销

3. **专业化查询引擎**:
   - 时间序列查询优化
   - 地理位置查询加速
   - 关键词搜索与模糊匹配优化

#### 4.7.5 海量数据性能优化措施

针对系统整体性能，采用以下关键优化措施：

1. **数据生命周期管理**:
   - 冷热数据分离存储
   - 历史数据自动归档
   - 数据重要性分级与差异化存储

2. **硬件与部署优化**:
   - 使用SSD存储高频访问数据
   - 内存优化配置(足够的缓冲池)
   - 数据库专用服务器与优化配置

3. **持续性能监控与优化**:
   - 实时性能指标监控
   - 慢查询自动识别与优化
   - 基于机器学习的性能预测与调优

通过以上策略，系统能够高效处理500万量级的日程数据，实现快速的首次同步和高性能查询，同时保持系统的可扩展性和稳定性。

## 5. 接口方案设计

本系统采用RESTful API和GraphQL双模式接口设计，为不同场景提供最优的接口体验。

### 5.1 接口设计原则

1. **一致性原则**:
   - 统一的URL结构和命名规范
   - 一致的错误码和响应格式
   - 规范化的版本控制策略
   - 统一的认证和授权机制

2. **安全性原则**:
   - 全站HTTPS加密
   - 接口访问认证(JWT/OAuth 2.0)
   - 参数验证和防注入处理
   - 敏感数据脱敏和加密传输

3. **可用性原则**:
   - 合理的请求频率限制
   - 分级缓存策略
   - 异步处理长时间操作
   - 批量处理接口优化

4. **可维护性原则**:
   - 清晰的接口文档(OpenAPI/Swagger)
   - 模块化的接口组织
   - 可扩展的接口设计
   - 完善的接口监控和日志

### 5.2 RESTful API设计

#### 5.2.1 接口规范

| 项目 | 规范 | 示例 |
|------|------|------|
| URL命名 | 小写字母，单词用连字符分隔 | `/api/v1/course-arrangements` |
| 资源命名 | 复数名词 | `/api/v1/courses`, `/api/v1/users` |
| HTTP方法 | 符合语义(GET/POST/PUT/DELETE) | `GET /api/v1/courses/{id}` |
| 查询参数 | 用于过滤、排序和分页 | `?page=1&size=20&sort=name:asc` |
| 状态码 | 标准HTTP状态码 | `200 OK`, `400 Bad Request` |
| 版本控制 | URL路径中包含版本号 | `/api/v1/...` |
| 响应格式 | 统一JSON结构 | `{"code": 200, "data": {}, "message": ""}` |

#### 5.2.2 核心接口示例

##### 课程同步接口

```
# 获取课程列表
GET /api/v1/courses
参数:
  - semester: 学期 (如 "2023-01")
  - page: 页码，默认1
  - size: 每页大小，默认20
  - updatedAfter: 更新时间筛选 (ISO8601格式)
响应:
  {
    "code": 200,
    "data": {
      "total": 1000,
      "pages": 50,
      "courses": [
        {
          "id": "course-123",
          "name": "高等数学",
          "code": "MATH101",
          "semester": "2023-01",
          "arrangements": [...],
          ...
        },
        ...
      ]
    },
    "message": "success"
  }

# 获取单个课程详情
GET /api/v1/courses/{courseId}
响应:
  {
    "code": 200,
    "data": {
      "id": "course-123",
      "name": "高等数学",
      "code": "MATH101",
      "semester": "2023-01",
      "credit": 4,
      "description": "...",
      "teachers": [...],
      "arrangements": [...],
      ...
    },
    "message": "success"
  }

# 触发课程同步
POST /api/v1/sync/courses
请求体:
  {
    "semester": "2023-01",
    "courseIds": ["course-123", ...], // 可选，为空则同步所有
    "syncType": "FULL", // FULL/INCREMENTAL
    "priority": "HIGH" // HIGH/NORMAL/LOW
  }
响应:
  {
    "code": 200,
    "data": {
      "syncId": "sync-20230901-001",
      "started": "2023-09-01T10:30:00Z",
      "estimated_completion": "2023-09-01T10:35:00Z",
      "status": "RUNNING"
    },
    "message": "同步任务已启动"
  }

# 查询同步状态
GET /api/v1/sync/{syncId}/status
响应:
  {
    "code": 200,
    "data": {
      "syncId": "sync-20230901-001",
      "status": "COMPLETED", // RUNNING/COMPLETED/FAILED/PARTIAL_COMPLETED
      "progress": 100,
      "started": "2023-09-01T10:30:00Z",
      "completed": "2023-09-01T10:34:22Z",
      "totalItems": 500,
      "successItems": 498,
      "failedItems": 2,
      "logs": [...]
    },
    "message": "success"
  }
```

##### 打卡接口

```
# 学生打卡
POST /api/v1/checkin
请求体:
  {
    "scheduleId": "schedule-456",
    "location": {
      "longitude": 116.3,
      "latitude": 39.9,
      "accuracy": 10
    },
    "device": {
      "type": "mobile",
      "info": "iPhone 13, iOS 16.1"
    },
    "timestamp": "2023-09-01T08:58:30Z"
  }
响应:
  {
    "code": 200,
    "data": {
      "checkinId": "checkin-789",
      "status": "NORMAL", // NORMAL/LATE/EARLY/ABNORMAL
      "checkinTime": "2023-09-01T08:58:30Z",
      "message": "打卡成功"
    },
    "message": "打卡成功"
  }

# 获取打卡记录
GET /api/v1/checkins
参数:
  - userId: 用户ID
  - courseId: 课程ID (可选)
  - startDate: 开始日期
  - endDate: 结束日期
  - status: 状态筛选 (可选)
  - page: 页码
  - size: 每页大小
响应:
  {
    "code": 200,
    "data": {
      "total": 42,
      "pages": 3,
      "checkins": [
        {
          "id": "checkin-789",
          "userId": "user-001",
          "scheduleId": "schedule-456",
          "courseName": "高等数学",
          "checkinTime": "2023-09-01T08:58:30Z",
          "status": "NORMAL",
          "location": {...}
        },
        ...
      ]
    },
    "message": "success"
  }
```

##### 请假接口

```
# 提交请假申请
POST /api/v1/leaves
请求体:
  {
    "userId": "user-001",
    "scheduleId": "schedule-456",
    "reason": "身体不适，需要去医院检查",
    "leaveType": "SICK", // SICK/PERSONAL/OFFICIAL
    "attachments": [
      {
        "name": "医院证明.pdf",
        "url": "https://..."
      }
    ]
  }
响应:
  {
    "code": 200,
    "data": {
      "leaveId": "leave-001",
      "status": "PENDING",
      "wpsApprovalId": "wps-approval-123",
      "approvers": [
        {
          "userId": "teacher-001",
          "name": "张教授",
          "role": "PRIMARY"
        }
      ],
      "message": "请假申请已提交，等待审批"
    },
    "message": "请假申请已提交"
  }

# 审批请假申请
PUT /api/v1/leaves/{leaveId}/approve
请求体:
  {
    "approverId": "teacher-001",
    "action": "APPROVE", // APPROVE/REJECT
    "comment": "已批准，请按医嘱休息"
  }
响应:
  {
    "code": 200,
    "data": {
      "leaveId": "leave-001",
      "status": "APPROVED",
      "updatedAt": "2023-09-01T10:15:00Z",
      "message": "请假已批准"
    },
    "message": "操作成功"
  }
```

### 5.3 GraphQL API设计

对于复杂查询和灵活数据获取场景，系统提供GraphQL接口，特别适用于统计分析和管理界面。

#### 5.3.1 GraphQL Schema示例

```graphql
type Course {
  id: ID!
  code: String!
  name: String!
  semester: String!
  credit: Float
  description: String
  teachers: [User!]!
  arrangements: [CourseArrangement!]!
  students: [User!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CourseArrangement {
  id: ID!
  course: Course!
  week: Int!
  dayOfWeek: Int!
  period: Int!
  startTime: DateTime!
  endTime: DateTime!
  location: Location
  teachers: [User!]!
  schedules: [Schedule!]!
}

type Schedule {
  id: ID!
  user: User!
  courseArrangement: CourseArrangement!
  wpsEventId: String!
  status: ScheduleStatus!
  checkins: [Checkin!]
  leave: Leave
}

type Checkin {
  id: ID!
  user: User!
  schedule: Schedule!
  time: DateTime!
  location: GeoLocation
  status: CheckinStatus!
  device: DeviceInfo
}

type Leave {
  id: ID!
  user: User!
  schedule: Schedule!
  reason: String!
  type: LeaveType!
  status: LeaveStatus!
  appliedAt: DateTime!
  approvedAt: DateTime
  approver: User
  comment: String
  attachments: [Attachment!]
}

type AttendanceStats {
  id: ID!
  user: User
  course: Course
  semester: String
  totalClasses: Int!
  attendedClasses: Int!
  absentClasses: Int!
  leaveClasses: Int!
  lateClasses: Int!
  attendanceRate: Float!
}

# 查询根类型
type Query {
  # 课程查询
  course(id: ID!): Course
  courses(semester: String, teacherId: ID, filter: CourseFilter, pagination: Pagination): [Course!]!
  
  # 用户查询
  user(id: ID!): User
  users(role: UserRole, filter: UserFilter, pagination: Pagination): [User!]!
  
  # 考勤查询
  checkins(userId: ID, scheduleId: ID, courseId: ID, dateRange: DateRange, status: CheckinStatus, pagination: Pagination): [Checkin!]!
  
  # 请假查询
  leaves(userId: ID, status: LeaveStatus, dateRange: DateRange, pagination: Pagination): [Leave!]!
  
  # 统计查询
  attendanceStats(userId: ID, courseId: ID, semester: String): AttendanceStats
  courseAttendanceReport(courseId: ID!, dateRange: DateRange): CourseAttendanceReport!
  userAttendanceReport(userId: ID!, semester: String): UserAttendanceReport!
  
  # 同步状态查询
  syncStatus(id: ID!): SyncStatus
  syncHistory(type: SyncType, dateRange: DateRange, pagination: Pagination): [SyncStatus!]!
}

# 变更根类型
type Mutation {
  # 课程同步
  syncCourses(input: SyncCoursesInput!): SyncResult!
  
  # 打卡操作
  checkin(input: CheckinInput!): CheckinResult!
  
  # 请假操作
  applyLeave(input: LeaveApplicationInput!): LeaveResult!
  approveLeave(id: ID!, input: LeaveApprovalInput!): LeaveResult!
  
  # 管理操作
  createManualCheckin(input: ManualCheckinInput!): CheckinResult!
  cancelSchedule(id: ID!, reason: String!): ScheduleResult!
  
  # 用户配置
  updateUserSettings(userId: ID!, settings: UserSettingsInput!): UserSettings!
}

# 订阅根类型 - 用于实时功能
type Subscription {
  syncProgress(syncId: ID!): SyncProgress!
  newCheckin(courseId: ID): Checkin!
  leaveStatusChanged(userId: ID): Leave!
}
```

#### 5.3.2 GraphQL查询示例

```graphql
# 教师查询课程学生出勤情况
query CourseAttendance($courseId: ID!, $date: String!) {
  course(id: $courseId) {
    id
    name
    code
    arrangements {
      id
      dayOfWeek
      period
      startTime
      endTime
      location {
        building
        room
      }
      schedules(date: $date) {
        id
        user {
          id
          name
          code
        }
        checkins {
          status
          time
        }
        leave {
          status
          reason
        }
      }
    }
  }
}

# 学生查询个人考勤统计
query StudentAttendance($userId: ID!, $semester: String!) {
  user(id: $userId) {
    id
    name
    courses(semester: $semester) {
      id
      name
      attendanceStats(userId: $userId) {
        totalClasses
        attendedClasses
        absentClasses
        leaveClasses
        lateClasses
        attendanceRate
      }
      arrangements {
        id
        dayOfWeek
        period
        schedules(userId: $userId) {
          id
          checkins {
            status
            time
          }
        }
      }
    }
  }
}

# 管理员查询同步状态与失败项
query SyncDetails($syncId: ID!) {
  syncStatus(id: $syncId) {
    id
    type
    startTime
    endTime
    status
    progress
    totalItems
    successItems
    failedItems
    failureRecords {
      id
      recordType
      recordId
      errorCode
      errorMessage
      retryCount
      lastRetryTime
      status
    }
    logs {
      time
      level
      message
    }
  }
}
```

### 5.4 WebSocket接口设计

对于需要实时通知的场景，系统提供WebSocket接口，主要应用于：

1. **实时打卡反馈**：学生打卡后立即更新教师界面
2. **同步进度监控**：管理员实时查看同步进度
3. **请假状态通知**：请假审批状态变更实时通知

WebSocket连接端点: `/ws/v1/{topic}/{id}`

主要消息主题:
- `/topic/checkin/{courseId}` - 课程打卡实时通知
- `/topic/leave/{userId}` - 用户请假状态更新
- `/topic/sync/{syncId}` - 同步任务进度更新

消息格式示例:
```json
{
  "type": "CHECKIN_EVENT",
  "timestamp": "2023-09-01T09:00:05Z",
  "data": {
    "courseId": "course-123",
    "scheduledId": "schedule-456",
    "userId": "user-001",
    "userName": "张三",
    "status": "NORMAL",
    "checkinTime": "2023-09-01T08:58:30Z"
  }
}
```

### 5.5 接口安全设计

#### 5.5.1 认证机制

系统采用多层次的认证机制：

1. **JWT认证**:
   - 登录后颁发访问令牌(Access Token)和刷新令牌(Refresh Token)
   - 访问令牌有效期短(30分钟)，刷新令牌有效期长(7天)
   - 令牌包含用户ID、角色、权限范围等信息

2. **OAuth 2.0集成**:
   - 支持与学校身份系统SSO集成
   - 支持WPS账号授权登录
   - 细粒度的API访问权限控制

3. **API密钥认证**:
   - 服务间通信使用API密钥认证
   - 后台任务和管理接口使用API密钥认证
   - 密钥定期轮转和吊销机制

#### 5.5.2 权限控制

基于RBAC(基于角色的访问控制)和ABAC(基于属性的访问控制)的混合权限模型：

| 角色 | 权限范围 | 示例 |
|------|---------|------|
| 学生 | 查看个人课程和考勤 | `/api/v1/users/{self}/courses` |
| | 申请请假 | `/api/v1/leaves` (POST) |
| | 进行打卡 | `/api/v1/checkin` (POST) |
| 教师 | 查看教授课程和学生 | `/api/v1/teachers/{self}/courses` |
| | 查看课程考勤统计 | `/api/v1/courses/{id}/attendance` |
| | 审批请假 | `/api/v1/leaves/{id}/approve` |
| | 手动考勤登记 | `/api/v1/checkin/manual` |
| 管理员 | 触发同步操作 | `/api/v1/sync/*` |
| | 查看同步状态 | `/api/v1/sync/{id}/status` |
| | 系统配置管理 | `/api/v1/configs/*` |
| | 用户管理 | `/api/v1/users/*` |

#### 5.5.3 数据加密

1. **传输层加密**:
   - 全站HTTPS/TLS 1.3
   - HTTP严格传输安全(HSTS)
   - 证书透明度监控

2. **数据加密**:
   - 敏感字段加密存储(AES-256)
   - WPS API密钥及配置信息加密存储
   - 备份数据加密
   - 文件上传内容扫描与加密

3. **防护机制**:
   - 输入验证与参数清洁
   - SQL注入防护
   - XSS防护
   - CSRF防护
   - 请求频率限制

### 5.6 API文档与测试

1. **API文档**:
   - 使用OpenAPI 3.0规范
   - Swagger UI自动生成交互式文档
   - 示例请求与响应
   - 错误码说明与处理建议

2. **接口测试**:
   - 单元测试覆盖率>90%
   - 接口契约测试
   - 性能测试(压力测试和负载测试)
   - 接口安全性测试

3. **开发者体验**:
   - 提供API客户端SDK
   - Postman集合与环境配置
   - 模拟服务器(Mock Server)
   - 沙箱环境

## 6. 异常处理方案

### 6.1 异常分类与处理策略

#### 6.1.1 异常分类体系

课程表同步系统在运行过程中可能遇到多种异常情况，我们将异常按照来源和性质进行分类，以便采取针对性的处理策略：

1. **系统级异常**
   - 服务器资源不足（CPU/内存/磁盘空间耗尽）
   - 网络连接异常（连接超时/断开）
   - 数据库异常（连接失败/查询超时）
   - 缓存服务异常（Redis连接失败/数据过期）

2. **业务逻辑异常**
   - 数据验证失败（格式错误/数据不完整）
   - 业务规则冲突（时间冲突/资源冲突）
   - 权限不足（未授权操作）
   - 状态错误（状态转换非法）

3. **外部依赖异常**
   - WPS API调用异常（超时/限流/鉴权失败）
   - 教务系统数据源异常（格式变更/接口变更）
   - 第三方服务异常（短信发送失败/推送失败）

4. **人为操作异常**
   - 误操作（错误配置/数据误删）
   - 恶意操作（攻击/滥用接口）

#### 6.1.2 异常处理策略

针对不同类型的异常，采取差异化的处理策略：

| 异常类型 | 处理策略 | 示例措施 |
|---------|---------|---------|
| 可恢复的瞬时异常 | 重试策略 | 网络抖动、临时服务不可用 |
| 可恢复的持续异常 | 降级策略 | API限流、资源短缺 |
| 不可恢复的系统异常 | 熔断策略 | 依赖服务长时间不可用 |
| 数据一致性异常 | 补偿策略 | 事务失败、数据同步中断 |
| 业务规则异常 | 拒绝策略 | 非法请求、业务规则冲突 |
| 安全风险异常 | 阻断策略 | 可疑操作、异常访问模式 |

### 6.2 WPS API异常处理机制

由于系统与WPS平台的紧密集成，WPS API调用异常是需要重点关注的问题。

#### 6.2.1 WPS API错误码分类

根据WPS API的错误码特征，将API错误分为以下几类：

| 错误类别 | 错误码范围 | 处理策略 |
|---------|-----------|---------|
| 身份验证错误 | 401, 403 | 刷新令牌并重试 |
| 请求限制错误 | 429 | 延时重试，智能退避 |
| 服务器错误 | 500-599 | 延时重试，报警通知 |
| 参数错误 | 400, 422 | 日志记录，人工介入 |
| 资源冲突 | 409 | 数据对比分析，解决冲突 |
| 资源不存在 | 404 | 检查数据同步状态，创建资源 |

#### 6.2.2 API调用异常处理流程

```
┌─────────────────┐
│  API请求开始    │
└────────┬────────┘
         ▼
┌─────────────────┐     ┌───────────────┐
│  发送API请求    │────▶│  请求成功?    │─────Yes──▶ 处理成功响应
└────────┬────────┘     └───────┬───────┘
         │ 失败              No │
         ▼                     ▼
┌─────────────────┐     ┌───────────────┐
│  分析错误类型   │────▶│ 是认证错误?   │─────Yes──▶ 刷新令牌重试
└────────┬────────┘     └───────┬───────┘
         │ 继续              No │
         ▼                     ▼
┌─────────────────┐     ┌───────────────┐
│ 是请求限制错误? │────▶│ 计算退避时间  │─────────▶ 等待后重试
└────────┬────────┘     └───────────────┘
         │ No
         ▼
┌─────────────────┐     ┌───────────────┐
│  是服务器错误?  │────▶│ 记录监控指标  │─────────▶ 延时重试
└────────┬────────┘     └───────────────┘
         │ No
         ▼
┌─────────────────┐     ┌───────────────┐
│ 是参数/资源错误?│────▶│ 记录详细日志  │─────────▶ 触发告警
└────────┬────────┘     └───────────────┘
         │ No
         ▼
┌─────────────────┐
│  未知错误处理   │────▶ 进入人工处理队列
└─────────────────┘
```

#### 6.2.3 API调用重试策略

针对不同API调用异常，采用不同的重试策略：

```javascript
// 智能重试策略实现示例
async function callWpsApiWithRetry(apiFunction, params, options = {}) {
  const {
    maxRetries = 3,
    baseDelay = 1000,
    maxDelay = 30000,
    retryStatusCodes = [429, 500, 502, 503, 504]
  } = options;
  
  let attempt = 0;
  
  while (true) {
    try {
      return await apiFunction(params);
    } catch (error) {
      attempt++;
      
      // 超过最大重试次数
      if (attempt >= maxRetries) {
        logger.error(`API调用失败，已达最大重试次数: ${attempt}`, {
          function: apiFunction.name,
          params,
          error
        });
        throw error;
      }
      
      // 判断是否需要重试
      const statusCode = error.response?.status;
      const shouldRetry = retryStatusCodes.includes(statusCode);
      
      if (!shouldRetry) {
        throw error;
      }
      
      // 计算指数退避延迟时间
      const delay = Math.min(
        baseDelay * Math.pow(2, attempt - 1) + Math.random() * 1000,
        maxDelay
      );
      
      logger.warn(`API调用失败，将在${delay}ms后重试。尝试次数: ${attempt}/${maxRetries}`, {
        function: apiFunction.name,
        statusCode,
        delay
      });
      
      // 特殊处理认证错误
      if (statusCode === 401) {
        await refreshAccessToken();
      }
      
      // 等待后重试
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

### 6.3 数据同步异常处理

#### 6.3.1 同步过程中断恢复机制

数据同步是系统的核心功能，需要具备中断恢复能力：

1. **检查点(Checkpoint)机制**:
   - 每批次同步数据后记录同步位置
   - 同步中断后从最近检查点恢复
   - 检查点信息包含时间戳、数据范围、批次ID

2. **事务边界控制**:
   - 合理设置同步批次大小，确保单个事务可控
   - 批次间保持幂等性，支持重复执行
   - 关联数据在同一批次处理，保证数据一致性

3. **状态跟踪与恢复**:
   ```javascript
   // 同步任务状态跟踪示例
   async function synchronizeWithRecovery(syncTask) {
     try {
       // 检查是否是恢复模式
       if (syncTask.status === 'INTERRUPTED') {
         logger.info(`正在从检查点恢复同步任务: ${syncTask.id}`, {
           checkpoint: syncTask.lastCheckpoint
         });
         
         // 从上次检查点恢复
         await resumeSyncFromCheckpoint(syncTask.lastCheckpoint);
       } else {
         // 新任务，从头开始
         await startNewSyncTask(syncTask);
       }
       
       // 记录成功状态
       await updateSyncTaskStatus(syncTask.id, 'COMPLETED');
       
     } catch (error) {
       // 记录中断状态和检查点
       await updateSyncTaskStatus(syncTask.id, 'INTERRUPTED', {
         error: error.message,
         checkpoint: getCurrentCheckpoint()
       });
       
       // 触发告警
       await notifyAdmins('同步任务中断', {
         taskId: syncTask.id,
         error: error.message
       });
       
       throw error;
     }
   }
   ```

#### 6.3.2 数据一致性检验与修复

1. **一致性校验机制**:
   - 定期进行源数据与目标数据的完整性校验
   - 基于哈希值或特征值快速对比数据集差异
   - 增量校验机制，只检查可能变化的数据

2. **自动修复流程**:
   - 轻微不一致自动修复（如元数据不一致）
   - 结构性不一致进入手动修复队列
   - 修复操作审计日志记录

3. **校验修复示例**:
   ```javascript
   // 数据一致性校验与修复
   async function verifyAndRepairDataConsistency(dataType, options = {}) {
     const { batchSize = 100, autoRepair = true } = options;
     
     // 获取需要校验的数据集
     const datasets = await getDatasetForVerification(dataType, batchSize);
     
     const results = {
       verified: 0,
       consistent: 0,
       autoRepaired: 0,
       manualRepairNeeded: 0,
       details: []
     };
     
     for (const dataset of datasets) {
       // 获取源数据和目标数据
       const [sourceData, targetData] = await Promise.all([
         fetchSourceData(dataset),
         fetchTargetData(dataset)
       ]);
       
       results.verified++;
       
       // 比较数据一致性
       const comparisonResult = compareData(sourceData, targetData);
       
       if (comparisonResult.isConsistent) {
         results.consistent++;
         continue;
       }
       
       // 判断是否可以自动修复
       if (autoRepair && isAutoRepairable(comparisonResult)) {
         await repairData(dataset, comparisonResult);
         results.autoRepaired++;
         results.details.push({
           datasetId: dataset.id,
           repairType: 'auto',
           differences: comparisonResult.differences
         });
       } else {
         // 创建手动修复工单
         await createManualRepairTicket(dataset, comparisonResult);
         results.manualRepairNeeded++;
         results.details.push({
           datasetId: dataset.id,
           repairType: 'manual',
           differences: comparisonResult.differences
         });
       }
     }
     
     return results;
   }
   ```

### 6.4 打卡和请假业务异常处理

#### 6.4.1 打卡异常处理

1. **打卡前置验证**:
   - 地理位置验证（确保在教室范围内）
   - 时间有效性验证（课程时间范围内）
   - 重复打卡检测与处理
   - 设备指纹验证（防止代打卡）

2. **打卡故障场景处理**:
   - 网络中断：本地缓存打卡记录，恢复连接后上传
   - 服务不可用：降级为临时打卡模式，后台异步同步
   - 数据冲突：基于时间戳和优先级规则解决冲突
   - 位置异常：启动人工审核流程，提供证明材料通道

3. **打卡异常处理流程**:
   ```
   1. 学生发起打卡请求
   2. 系统进行前置验证
      - 如果验证失败但属于可接受范围(如位置略有偏差)：
        * 记录异常标记
        * 允许打卡但进入异常队列
      - 如果验证严重失败(如位置完全不符):
        * 拒绝打卡
        * 提供申诉通道
   3. 异常打卡进入教师审核流程
      - 教师可查看异常详情
      - 决定是否确认有效
   4. 系统记录完整审计日志
   ```

#### 6.4.2 请假异常处理

1. **请假申请异常**:
   - 表单验证失败：即时反馈错误信息，指导正确填写
   - 业务规则冲突（如超出请假限额）：明确提示冲突原因
   - 附件上传失败：提供替代上传方式或临时占位符

2. **审批流程异常**:
   - 审批人不可用：自动升级或替换审批人
   - 审批超时：自动提醒或升级处理
   - 审批流中断：支持从中断点恢复
   - 审批结果冲突：优先级规则和人工干预机制

3. **与WPS集成异常**:
   - WPS审批流创建失败：本地保存请假记录，异步重试同步
   - 状态同步失败：定期对比并修复状态不一致
   - 审批结果不一致：采用最终确认机制，明确主数据源

### 6.5 异常监控与告警

#### 6.5.1 异常监控维度

建立多维度异常监控体系：

1. **系统健康监控**:
   - 服务可用性（正常/降级/不可用）
   - 资源使用率（CPU/内存/磁盘/网络）
   - 关键服务响应时间
   - 错误率和异常计数

2. **业务指标监控**:
   - 同步成功率和耗时
   - 打卡成功率和异常比例
   - 请假审批周期和积压数量
   - 数据一致性指标

3. **外部依赖监控**:
   - WPS API可用性和响应时间
   - 认证服务状态
   - 第三方服务调用成功率
   - API限流和配额使用情况

#### 6.5.2 告警等级与处理流程

根据异常的严重程度，设立不同级别的告警：

| 告警级别 | 定义 | 通知方式 | 处理时限 |
|---------|-----|---------|---------|
| P0-严重 | 核心功能不可用，大面积用户受影响 | 电话+短信+邮件+群通知 | 立即处理，全团队支持 |
| P1-高危 | 重要功能受损，部分用户受影响 | 短信+邮件+群通知 | 1小时内响应，优先处理 |
| P2-中等 | 非核心功能异常，用户体验受影响 | 邮件+群通知 | 24小时内处理 |
| P3-轻微 | 边缘功能异常，几乎不影响用户 | 系统内通知 | 计划性修复 |

#### 6.5.3 告警触发与升级机制

```javascript
// 告警处理示例
async function processSystemAlert(alert) {
  // 确定告警级别
  const alertLevel = determineAlertLevel(alert);
  
  // 记录告警
  await logAlert(alert, alertLevel);
  
  // 通知相关人员
  await notifyResponsibleTeam(alert, alertLevel);
  
  // 自动修复尝试
  if (alert.autoRemediationAvailable) {
    try {
      const remediationResult = await attemptAutoRemediation(alert);
      if (remediationResult.successful) {
        await updateAlertStatus(alert.id, 'AUTO_RESOLVED');
        return;
      }
    } catch (error) {
      logger.error('自动修复失败', { alertId: alert.id, error });
    }
  }
  
  // 告警升级机制
  const alertExpirationTime = getAlertExpirationTime(alertLevel);
  scheduleAlertEscalation(alert.id, alertExpirationTime);
}

// 告警升级
async function escalateAlert(alertId) {
  const alert = await getAlertById(alertId);
  
  // 检查告警是否已解决
  if (alert.status !== 'ACTIVE') {
    return;
  }
  
  // 更新告警级别
  const newLevel = escalateAlertLevel(alert.level);
  await updateAlertLevel(alertId, newLevel);
  
  // 通知更高级别的响应团队
  await notifyEscalationTeam(alert, newLevel);
  
  // 如果是最高级别，触发应急预案
  if (newLevel === 'P0') {
    await triggerEmergencyPlan(alert);
  }
}
```

### 6.6 异常恢复与后处理

#### 6.6.1 自动恢复机制

针对可自动恢复的异常，设计恢复机制：

1. **服务自愈**:
   - 健康检查失败自动重启服务
   - 资源耗尽自动扩容
   - 连接池异常自动重建
   - 缓存失效自动重建

2. **数据修复**:
   - 数据不一致自动同步
   - 孤立数据自动清理
   - 索引异常自动重建
   - 缓存与数据库不一致自动对齐

3. **自动降级与恢复**:
   - 依赖服务不可用时自动降级
   - 依赖服务恢复后自动切回
   - 限流触发后的自动解除
   - 熔断后的半开状态试探

#### 6.6.2 异常分析与优化

每次重大异常后，执行根因分析与系统优化：

1. **根因分析流程**:
   - 收集事件时间线与关键指标
   - 分析日志与监控数据
   - 确定直接原因与深层次原因
   - 制定修复方案与防止复发措施

2. **系统持续优化**:
   - 更新错误检测规则
   - 完善自动恢复机制
   - 优化异常处理代码
   - 增强监控与告警能力

3. **知识库建设**:
   - 构建异常处理知识库
   - 记录典型案例与解决方案
   - 更新运维手册与应急预案
   - 技术团队定期复盘和培训

#### 6.6.3 异常事件闭环管理

```
┌─────────────────┐
│  异常事件发生   │
└────────┬────────┘
         ▼
┌─────────────────┐
│  记录与分类     │
└────────┬────────┘
         ▼
┌─────────────────┐
│  响应与处理     │
└────────┬────────┘
         ▼
┌─────────────────┐     ┌───────────────┐
│  根因分析       │────▶│  知识库更新   │
└────────┬────────┘     └───────────────┘
         ▼
┌─────────────────┐     ┌───────────────┐
│  系统优化       │────▶│  测试验证     │
└────────┬────────┘     └───────┬───────┘
         │                      │
         └──────────────────────┘
                    ▼
┌─────────────────┐     ┌───────────────┐
│  复盘总结       │────▶│  团队培训     │
└─────────────────┘     └───────────────┘
```

### 6.7 异常处理最佳实践

#### 6.7.1 开发阶段最佳实践

1. **代码层面**:
   - 全面的输入验证
   - 明确的错误边界与处理
   - 合理使用try-catch与Promise错误处理
   - 详细的错误日志与上下文信息

2. **测试层面**:
   - 异常路径单元测试
   - 混沌工程测试（随机故障注入）
   - 压力测试与极限测试
   - 恢复测试（验证自动恢复能力）

3. **设计层面**:
   - 降级方案设计
   - 熔断策略设计
   - 幂等性设计（支持安全重试）
   - 异步处理机制设计

#### 6.7.2 运维阶段最佳实践

1. **监控与告警**:
   - 多维度监控指标
   - 合理的告警阈值
   - 告警抑制与聚合
   - 用户体验监控

2. **应急响应**:
   - 明确的响应流程
   - 角色与责任划分
   - 升级机制与决策树
   - 沟通机制与模板

3. **持续改进**:
   - 事后复盘机制
   - 异常处理效果评估
   - 定期演练与培训
   - 系统弱点分析与加固

#### 6.7.3 用户体验优化

即使在异常情况下，也应保持良好的用户体验：

1. **友好的错误提示**:
   - 使用用户可理解的语言
   - 提供明确的后续操作指导
   - 区分技术错误与用户操作错误
   - 适当使用幽默或同理心元素

2. **透明的状态反馈**:
   - 系统维护页面
   - 进度指示器
   - 预计恢复时间
   - 替代方案建议

3. **多渠道支持**:
   - 在线客服
   - 问题报告入口
   - 常见问题解答
   - 自助修复工具

通过以上全面的异常处理方案，课程表同步系统将具备强大的容错能力和自我恢复能力，在面对各种异常情况时能够保持业务连续性，为用户提供稳定可靠的服务。

## 7. 高负载高可用方案设计

### 7.1 整体架构高可用设计

#### 7.1.1 多层次高可用架构

```
┌───────────────────────────────────────────────────────────────┐
│                      负载均衡层 (Nginx/LB)                      │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │         多区域部署 + 故障自动转移 + 健康检查              │  │
└──┴─────────────────────────────┬───────────────────────────┴──┘
                                  │
┌───────────────────────────────────────────────────────────────┐
│                    应用服务层 (Node.js集群)                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ 无状态设计   │  │ 自动扩缩容  │  │ 服务降级与熔断保护   │  │
└──┴─────────────┴──┴─────────────┴──┴─────────────────────┴──┘
                                  │
┌───────────────────────────────────────────────────────────────┐
│                    数据存储层 (MySQL/Redis)                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ 主从复制    │  │ 数据分片    │  │ 定期备份与恢复方案   │  │
└──┴─────────────┴──┴─────────────┴──┴─────────────────────┴──┘
```

#### 7.1.2 关键组件冗余设计

- **应用服务冗余**: 每个微服务至少部署3个实例
- **数据库冗余**: 一主多从架构，自动故障转移
- **负载均衡冗余**: 双负载均衡器互为备份
- **缓存集群**: Redis集群模式，多节点部署
- **消息队列**: Kafka集群，多broker部署

### 7.2 打卡模块高可用方案

打卡功能是系统中最高并发的场景，特别是在课程开始和结束时间点，会有大量学生同时进行打卡操作。

#### 7.2.1 高并发打卡架构

```
┌─────────────────┐     ┌───────────────┐     ┌────────────────┐
│   打卡API网关    │────▶│  打卡前端缓存  │────▶│  打卡服务集群   │
└─────────────────┘     └───────────────┘     └────────────────┘
                                                       │
┌─────────────────┐     ┌───────────────┐             │
│  打卡状态查询    │◀───┤  Redis集群    │◀────────────┘
└─────────────────┘     └───────────────┘             │
                                                       ▼
                                              ┌────────────────┐
                                              │  Kafka消息队列  │
                                              └────────────────┘
                                                       │
                                                       ▼
┌─────────────────┐     ┌───────────────┐     ┌────────────────┐
│  打卡数据库写入  │◀───┤ 打卡处理服务群 │◀───┤  消费者群组     │
└─────────────────┘     └───────────────┘     └────────────────┘
```

#### 7.2.2 打卡流程设计

1. **前端优化**:
   - 客户端预校验: 在客户端进行基本校验，避免无效请求
   - 打卡按钮节流: 防止用户短时间内多次提交
   - 错峰策略: 根据课程时间预估高峰，前端随机延迟几秒提交

2. **接口层优化**:
   - API限流: 基于令牌桶算法的接口限流
   - 请求去重: 基于请求ID的去重机制
   - 快速响应: 返回打卡受理状态，异步处理实际打卡逻辑

3. **处理层优化**:
   - 消息队列缓冲: 使用Kafka缓冲打卡请求
   - 多消费者并行处理: 水平扩展消费者处理打卡请求
   - 批量写入: 聚合打卡记录批量写入数据库
   - 定时任务补偿: 定期检查未处理完成的打卡请求

4. **存储层优化**:
   - 打卡表分片: 按时间范围对打卡记录表进行分片
   - 读写分离: 打卡查询走从库，提高响应速度
   - 索引优化: 优化打卡记录表的索引结构

#### 7.2.3 打卡服务扩缩容策略

- **预测式扩容**: 根据课程表预测高峰期，提前扩容服务
- **指标触发扩容**: 设置CPU、内存、请求队列长度等指标触发自动扩容
- **定时扩缩容**: 根据历史访问模式，设置定时扩缩容规则
- **手动紧急扩容**: 提供运维接口，支持紧急手动扩容

#### 7.2.4 打卡异常处理流程

1. **客户端重试**:
   - 网络异常时客户端自动重试
   - 使用指数退避策略控制重试频率
   - 最大重试次数限制

2. **服务端补偿**:
   - 定时检查未完成的打卡请求
   - 失败请求自动重新入队
   - 超过重试阈值的请求进入人工处理队列

3. **异常监控**:
   - 实时监控打卡成功率
   - 异常阈值告警
   - 自动生成打卡异常报告

### 7.3 请假模块高可用方案

请假功能虽然并发量不如打卡，但涉及到WPS审批流程，需要保证数据一致性和服务可靠性。

#### 7.3.1 请假流程高可用设计

```
┌─────────────────┐     ┌───────────────┐     ┌────────────────┐
│   请假API服务    │────▶│  请假数据验证  │────▶│  WPS审批流创建  │
└─────────────────┘     └───────────────┘     └────────────────┘
                                                       │
┌─────────────────┐     ┌───────────────┐             │
│  请假记录创建    │◀───┤  事务保障     │◀────────────┘
└─────────────────┘     └───────────────┘             │
                                                       ▼
                                              ┌────────────────┐
                                              │  请假状态跟踪   │
                                              └────────────────┘
                                                       │
                                                       ▼
┌─────────────────┐     ┌───────────────┐     ┌────────────────┐
│  请假结果通知    │◀───┤ 状态变更处理   │◀───┤  WPS回调接收    │
└─────────────────┘     └───────────────┘     └────────────────┘
```

#### 7.3.2 请假服务可靠性保障

1. **分布式事务保障**:
   - 使用两阶段提交确保本地请假记录与WPS审批流一致
   - 引入补偿事务机制处理部分失败场景
   - 请假状态变更日志记录，支持状态回溯

2. **审批流状态同步机制**:
   - 主动轮询: 定时检查WPS审批流状态
   - 回调接收: 提供回调接口接收WPS状态变更通知
   - 双重保障: 结合主动轮询和回调接收确保状态一致

3. **请假高峰期优化**:
   - 学期初/重要节假日前请假高峰期容量规划
   - 队列优先级策略，确保临近课程的请假优先处理
   - 教师审批工作台优化，支持批量审批

### 7.4 数据一致性保障

#### 7.4.1 最终一致性策略

对于非核心实时业务，采用最终一致性策略:
- 基于事件的数据同步
- 定时对账和数据修复
- 版本号或时间戳检测冲突

#### 7.4.2 强一致性保障

对于核心业务数据，采用强一致性策略:
- 分布式事务(2PC/TCC)
- 严格的锁机制
- 操作日志与重放机制

#### 7.4.3 数据同步故障恢复

- 同步点记录: 记录每次同步的位置和状态
- 断点续传: 从上次同步点继续同步
- 增量对比: 定期进行源数据和目标数据对比
- 手动修复工具: 提供数据不一致手动修复工具

### 7.5 系统监控与应急预案

#### 7.5.1 全方位监控体系

- **基础设施监控**: 服务器、网络、存储等硬件指标
- **应用性能监控**: 接口响应时间、错误率、吞吐量等
- **业务指标监控**: 打卡成功率、同步完成率等
- **用户体验监控**: 页面加载时间、操作完成时间等
- **日志监控**: 异常日志实时告警

#### 7.5.2 应急预案

1. **服务降级预案**:
   - 核心服务保障: 保证打卡、请假等核心功能
   - 非核心功能降级: 统计分析等非核心功能可临时关闭
   - 简化流程: 启用简化版打卡流程，减少校验步骤

2. **容量扩展预案**:
   - 云资源快速扩容方案
   - 跨区域资源调度方案
   - 临时服务器紧急加入集群方案

3. **数据恢复预案**:
   - 数据备份与恢复流程
   - 数据修复工具与流程
   - 人工数据核对与录入应急方案 

## 8. 总结

本详细设计方案对课程表同步系统进行了全面的设计，从系统架构、模块设计、数据模型、接口设计、异常处理到高可用方案都进行了深入分析和规划。

### 8.1 设计原则回顾

在整个设计过程中，始终遵循以下原则:
- **可扩展性**: 微服务架构设计，支持横向扩展
- **高可用性**: 多层次冗余设计，确保系统稳定运行
- **可维护性**: 清晰的模块划分和接口定义，便于维护
- **安全性**: 完善的认证授权和数据加密机制
- **性能优化**: 合理使用缓存、消息队列等提升性能
- **异常处理**: 完整的异常分类和处理机制
- **数据一致性**: 严格的数据同步和一致性保障机制

### 8.2 实施建议

1. **分阶段实施**:
   - 第一阶段: 核心同步功能和基础架构
   - 第二阶段: 打卡和请假功能
   - 第三阶段: 统计分析和管理功能
   - 第四阶段: 系统优化和扩展功能

2. **测试策略**:
   - 单元测试: 覆盖关键业务逻辑
   - 集成测试: 验证各模块交互
   - 性能测试: 模拟高并发场景
   - 可靠性测试: 故障注入和恢复测试

3. **运维准备**:
   - 监控系统部署
   - 日志收集与分析平台
   - 运维手册和应急预案
   - 运维人员培训

#### 8.2.1 技术栈优化

1. **前端技术栈优化**:
   - **构建工具**: 
     - 使用Vite替代传统构建工具，提供更快的开发服务器和构建速度
     - 支持HMR (热模块替换)，优化开发体验
   - **UI框架**:
     - 采用Shadcn UI组件库，基于Radix UI的无障碍组件
     - 完全可定制的组件API，提高UI开发灵活性
   - **样式方案**:
     - 使用Tailwind CSS实用优先的CSS框架，加速UI开发
     - 响应式设计更简单直观，提升移动端体验

2. **前端项目结构**:
   ```
   web/
   ├── src/
   │   ├── components/      # Shadcn UI组件
   │   │   ├── ui/          # 基础UI组件
   │   │   └── custom/      # 业务组件
   │   ├── lib/             # 工具函数
   │   ├── styles/          # Tailwind配置
   │   └── pages/           # 页面组件
   ├── tailwind.config.js   # Tailwind配置
   └── vite.config.js       # Vite配置
   ```

3. **后端技术栈优化**:
   - 使用基于Fastify的Stratix框架替代Express
   - 性能提升30-40%，降低系统延迟
   - 内置请求验证和序列化，简化开发流程
   - 利用Fastify的异步非阻塞特性处理打卡高并发场景

4. **高并发场景优化**:
   - 结合Stratix框架的性能优势与Redis的原子操作
   - 前端使用Tailwind优化移动端打卡界面，提升用户体验
   - 后端利用Fastify的异步特性提高并发处理能力

### 8.3 风险与应对

1. **WPS API稳定性风险**:
   - 建立API监控机制
   - 实现本地缓存和降级策略
   - 与WPS平台建立技术支持渠道

2. **数据量增长风险**:
   - 实施数据分片和归档策略
   - 制定数据库扩容方案
   - 优化查询和索引结构

3. **高并发冲击风险**:
   - 实施流量控制和限流策略
   - 准备弹性扩容方案
   - 建立压力测试和容量评估机制

## 9. 业务流程与技术实现连接

本章节旨在将业务需求与技术实现紧密连接，确保技术方案切实满足业务目标，同时通过技术创新提升业务价值。

### 9.1 主要业务流程梳理

#### 9.1.1 课程表同步业务流程

课程表同步是系统的核心业务流程，包含以下关键环节：

1. **数据源接入阶段**
   - 业务需求：从多个教务系统获取原始课程数据，确保数据及时性和准确性
   - 技术实现：
     - 数据适配器模式实现多源数据接入
     - 增量同步算法减少数据传输量
     - 数据验证机制确保数据完整性
     - 实时监控接口状态，及时报警异常情况

2. **数据转换处理阶段**
   - 业务需求：将不同格式的原始数据转换为统一的WPS日历格式
   - 技术实现：
     - 映射转换引擎处理字段映射
     - 智能合并算法处理数据冗余
     - 数据清洗机制处理异常数据
     - 转换规则配置化，支持业务规则调整

3. **同步执行阶段**
   - 业务需求：高效可靠地将处理后的数据同步到WPS平台
   - 技术实现：
     - 批量同步与队列机制提高吞吐量
     - 事务与补偿机制确保数据一致性
     - 自适应限流保护WPS API
     - 同步状态跟踪与可视化监控

4. **数据验证与修正阶段**
   - 业务需求：确保同步后的数据与源数据一致，及时发现并修正不一致
   - 技术实现：
     - 数据对比算法验证同步结果
     - 自动修正机制处理一般性不一致
     - 人工干预流程处理复杂异常
     - 定期全量校验确保长期一致性

#### 9.1.2 考勤打卡业务流程

1. **打卡触发阶段**
   - 业务需求：支持多种打卡方式，确保便捷同时防作弊
   - 技术实现：
     - 地理围栏技术验证位置有效性
     - 生物特征识别增强身份验证
     - 分布式时钟确保时间准确性
     - 异常打卡智能识别与处理

2. **并发处理阶段**
   - 业务需求：高峰期能够快速处理大量并发打卡请求
   - 技术实现：
     - 消息队列削峰填谷
     - 分片处理减少锁竞争
     - 多级缓存加速数据访问
     - 异步处理非核心业务逻辑

3. **数据持久化阶段**
   - 业务需求：可靠记录打卡数据，支持后续统计分析
   - 技术实现：
     - 写入缓冲池优化写性能
     - 分表分库策略应对数据增长
     - 冷热数据分离优化存储成本
     - 数据压缩减少存储空间

#### 9.1.3 请假管理业务流程

1. **请假申请阶段**
   - 业务需求：支持多种请假类型，简化申请流程
   - 技术实现：
     - 动态表单引擎适应不同请假类型
     - 智能审批路由确定审批人
     - 预检验机制减少无效申请
     - 文件存储服务管理证明材料

2. **审批流转阶段**
   - 业务需求：灵活高效的审批流程，支持多级审批
   - 技术实现：
     - 工作流引擎管理审批流程
     - 消息推送确保及时处理
     - 超时提醒与自动升级机制
     - 审批历史完整记录与追溯

3. **结果处理阶段**
   - 业务需求：请假结果及时反馈并影响考勤统计
   - 技术实现：
     - 事件驱动架构实现系统联动
     - 状态机管理请假状态转换
     - 原子性更新确保数据一致性
     - 变更通知机制及时反馈结果

### 9.2 技术与业务的映射关系

以下表格展示了主要技术选型与核心业务需求的映射关系，说明每项技术如何服务于业务目标：

| 业务需求 | 技术实现 | 价值体现 |
|---------|---------|---------|
| 高并发打卡处理 | 消息队列(Kafka) + 分片处理 | 能够应对课程开始前的打卡高峰，确保系统稳定性 |
| 快速响应查询 | 多级缓存(Redis) + 预计算 | 教师查询考勤情况时响应迅速，提升用户体验 |
| 海量数据存储与分析 | 分表分库 + 数据仓库 | 支持长期数据积累，为教学分析提供数据基础 |
| 实时数据同步 | CDC技术 + 增量同步 | 确保课程表变更及时同步，减少信息不一致问题 |
| 稳定可靠的系统 | 微服务架构 + 熔断降级 | 局部故障不影响整体系统，提高服务可用性 |
| 个性化展示 | React前端 + 动态组件 | 根据用户角色提供差异化界面，提升用户体验 |
| 安全可靠的数据 | 多副本存储 + 定期备份 | 防止数据丢失，确保业务连续性 |
| 灵活的业务规则调整 | 规则引擎 + 配置中心 | 无需代码修改即可适应业务变化，降低维护成本 |

### 9.3 性能与业务需求的平衡

在系统设计中，我们针对不同业务场景进行了性能与业务需求的平衡：

1. **实时性与资源效率的平衡**
   - 业务场景：课程表同步
   - 平衡策略：
     - 采用"准实时"同步策略，一般情况下30分钟内完成同步
     - 关键变更（如临时调课）优先级提升，确保5分钟内同步
     - 非工作时间降低同步频率，减少资源消耗
     - 系统负载高峰期主动降低非关键同步频率

2. **并发性与数据一致性的平衡**
   - 业务场景：学生打卡
   - 平衡策略：
     - 采用最终一致性模型，优先保证打卡操作的响应速度
     - 打卡状态更新采用乐观锁，减少锁竞争
     - 统计数据异步更新，减轻实时计算压力
     - 关键业务路径代码优化，确保核心流程高效执行

3. **功能丰富性与系统复杂度的平衡**
   - 业务场景：请假管理
   - 平衡策略：
     - 核心请假类型内置实现，保证高效稳定
     - 特殊请假类型通过插件机制扩展，避免核心代码膨胀
     - 通用审批流程引擎，满足多样化需求同时控制复杂度
     - 渐进式功能发布，避免系统一次性过度复杂化

4. **用户体验与系统性能的平衡**
   - 业务场景：考勤统计查询
   - 平衡策略：
     - 常用统计报表预计算，确保快速响应
     - 复杂查询条件时展示进度指示器，管理用户预期
     - 大数据量导出采用异步生成+通知机制
     - 热门数据智能预加载，提升访问体验
