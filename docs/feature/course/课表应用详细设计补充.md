# 课表应用详细设计文档补充

## 1. 考勤统计需求补充

根据客户新的需求，需要对课表应用的考勤统计功能进行补充设计，主要关注以下方面：

1. 需要统计每门课的考勤信息
2. 基于开课号(kkh)创建每门课的考勤表
3. 计算每门课每一节课的打卡和请假情况
4. 通过关联表计算每节课的打卡、缺卡以及请假情况
5. 进而统计这门课的整体打卡，缺卡以及请假情况

## 2. 数据模型调整

### 2.1 新增课程考勤统计表

为满足按课程维度统计考勤情况的需求，新增课程考勤统计表：

```sql
CREATE TABLE `course_attendance_summary` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `kkh` varchar(60) NOT NULL COMMENT '开课号',
  `xnxq` varchar(20) NOT NULL COMMENT '学年学期',
  `kcmc` varchar(200) DEFAULT NULL COMMENT '课程名称',
  `total_classes` int(11) DEFAULT 0 COMMENT '总课程节数',
  `total_students` int(11) DEFAULT 0 COMMENT '总学生数',
  `total_punch_records` int(11) DEFAULT 0 COMMENT '总打卡记录数',
  `total_leave_records` int(11) DEFAULT 0 COMMENT '总请假记录数',
  `total_absent_records` int(11) DEFAULT 0 COMMENT '总缺勤记录数',
  `attendance_rate` decimal(5,2) DEFAULT 0.00 COMMENT '出勤率',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_kkh_xnxq` (`kkh`, `xnxq`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程考勤汇总表';
```

### 2.2 新增课程节次考勤详情表

为详细记录每门课每节课的考勤情况，新增课程节次考勤详情表：

```sql
CREATE TABLE `course_class_attendance` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `kkh` varchar(60) NOT NULL COMMENT '开课号',
  `xnxq` varchar(20) NOT NULL COMMENT '学年学期',
  `jxz` int(11) NOT NULL COMMENT '教学周',
  `zc` int(11) NOT NULL COMMENT '周几',
  `jc` int(11) NOT NULL COMMENT '节次',
  `rq` date NOT NULL COMMENT '日期',
  `class_group` varchar(20) DEFAULT NULL COMMENT '连续课节组，如1-2',
  `is_first_class_in_group` tinyint(1) DEFAULT 1 COMMENT '是否为组内第一节课',
  `total_students` int(11) DEFAULT 0 COMMENT '应出勤学生总数',
  `punched_count` int(11) DEFAULT 0 COMMENT '实际打卡人数',
  `leave_count` int(11) DEFAULT 0 COMMENT '请假人数',
  `absent_count` int(11) DEFAULT 0 COMMENT '缺勤人数',
  `attendance_rate` decimal(5,2) DEFAULT 0.00 COMMENT '当节出勤率',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_unique_class` (`kkh`, `xnxq`, `jxz`, `zc`, `jc`),
  KEY `idx_rq` (`rq`),
  KEY `idx_kkh_rq` (`kkh`, `rq`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程节次考勤详情表';
```

### 2.3 优化打卡任务表设计

调整打卡任务表，增加连续课程识别字段：

```sql
ALTER TABLE `punch_task` 
ADD COLUMN `class_group` varchar(20) DEFAULT NULL COMMENT '连续课节组，如1-2' AFTER `jc`,
ADD COLUMN `is_first_class_in_group` tinyint(1) DEFAULT 1 COMMENT '是否为组内第一节课' AFTER `class_group`;
```

## 3. 课程连续课节处理机制

### 3.1 连续课节识别算法

根据课程表数据识别连续课节，并生成连续课节组：

```javascript
/**
 * 识别连续课节
 * @param {Array} classList 课程列表
 * @returns {Array} 处理后的课程列表，包含连续课节信息
 */
function identifyContinuousClasses(classList) {
  // 按日期、开课号排序
  classList.sort((a, b) => {
    if (a.rq !== b.rq) return a.rq.localeCompare(b.rq);
    if (a.kkh !== b.kkh) return a.kkh.localeCompare(b.kkh);
    return a.jc - b.jc;
  });
  
  let result = [];
  let currentGroup = [];
  
  for (let i = 0; i < classList.length; i++) {
    const currentClass = classList[i];
    
    if (currentGroup.length === 0) {
      // 开始新分组
      currentGroup.push(currentClass);
    } else {
      const lastClass = currentGroup[currentGroup.length - 1];
      
      // 判断是否连续课节
      const isSameDay = lastClass.rq === currentClass.rq;
      const isSameCourse = lastClass.kkh === currentClass.kkh;
      const isConsecutiveClass = currentClass.jc === lastClass.jc + 1;
      
      // 考虑上下午分界
      const morningEndClass = 4; // 假设第4节是上午最后一节
      const isAcrossMorningAfternoon = lastClass.jc === morningEndClass && currentClass.jc === morningEndClass + 1;
      
      // 如果是同一天、同一课程、连续节次，且不跨越上下午，合并到当前组
      if (isSameDay && isSameCourse && isConsecutiveClass && !isAcrossMorningAfternoon) {
        currentGroup.push(currentClass);
      } else {
        // 处理当前组
        processClassGroup(currentGroup, result);
        // 开始新组
        currentGroup = [currentClass];
      }
    }
  }
  
  // 处理最后一组
  if (currentGroup.length > 0) {
    processClassGroup(currentGroup, result);
  }
  
  return result;
}

/**
 * 处理课节组
 * @param {Array} group 课节组
 * @param {Array} result 结果数组
 */
function processClassGroup(group, result) {
  const firstClass = group[0];
  const lastClass = group[group.length - 1];
  const groupName = `${firstClass.jc}-${lastClass.jc}`;
  
  // 为组内所有课节添加组信息
  for (let i = 0; i < group.length; i++) {
    const classItem = group[i];
    classItem.class_group = groupName;
    classItem.is_first_class_in_group = (i === 0) ? 1 : 0;
    result.push(classItem);
  }
}
```

### 3.2 打卡任务生成规则

只为连续课节组的第一节课生成打卡任务：

```javascript
/**
 * 生成打卡任务
 * @param {Array} processedClasses 处理后的课程列表
 * @returns {Array} 打卡任务列表
 */
function generatePunchTasks(processedClasses) {
  // 只为连续课节组中的第一节课生成打卡任务
  return processedClasses
    .filter(classItem => classItem.is_first_class_in_group === 1)
    .map(classItem => ({
      kkh: classItem.kkh,
      xnxq: classItem.xnxq,
      jxz: classItem.jxz,
      zc: classItem.zc,
      jc: classItem.jc,
      rq: classItem.rq,
      st: classItem.st,
      ed: classItem.ed,
      class_group: classItem.class_group,
      is_first_class_in_group: classItem.is_first_class_in_group,
      punch_start_time: calculatePunchStartTime(classItem.st),
      punch_end_time: calculatePunchEndTime(classItem.st),
      task_status: 0
    }));
}
```

## 4. 考勤数据统计流程

### 4.1 单节课考勤统计流程

```javascript
/**
 * 更新单节课考勤统计
 * @param {Object} classInfo 课程节次信息
 */
async function updateClassAttendance(classInfo) {
  // 获取应出勤学生列表
  const students = await getStudentsByCourse(classInfo.kkh, classInfo.xnxq);
  const totalStudents = students.length;
  
  // 获取打卡记录
  const punchRecords = await getPunchRecords(classInfo.kkh, classInfo.rq, classInfo.jc);
  const punchedStudents = punchRecords.filter(record => record.punch_status === 1).map(record => record.xh);
  
  // 获取请假记录
  const leaveRecords = await getLeaveRecords(classInfo.kkh, classInfo.rq, classInfo.jc);
  const leaveStudents = leaveRecords.map(record => record.xh);
  
  // 计算缺勤学生
  const absentStudents = students.filter(xh => 
    !punchedStudents.includes(xh) && !leaveStudents.includes(xh)
  );
  
  // 计算出勤率
  const attendanceRate = ((punchedStudents.length + leaveStudents.length) / totalStudents) * 100;
  
  // 更新考勤统计表
  await updateCourseClassAttendance({
    kkh: classInfo.kkh,
    xnxq: classInfo.xnxq,
    jxz: classInfo.jxz,
    zc: classInfo.zc,
    jc: classInfo.jc,
    rq: classInfo.rq,
    class_group: classInfo.class_group,
    is_first_class_in_group: classInfo.is_first_class_in_group,
    total_students: totalStudents,
    punched_count: punchedStudents.length,
    leave_count: leaveStudents.length,
    absent_count: absentStudents.length,
    attendance_rate: attendanceRate.toFixed(2)
  });
  
  // 如果是连续课节组的第一节，更新整个组的考勤状态
  if (classInfo.is_first_class_in_group === 1 && classInfo.class_group) {
    await updateGroupAttendance(classInfo);
  }
}
```

### 4.2 课程维度考勤统计

```javascript
/**
 * 更新课程整体考勤统计
 * @param {string} kkh 开课号
 * @param {string} xnxq 学年学期
 */
async function updateCourseAttendanceSummary(kkh, xnxq) {
  // 获取课程信息
  const courseInfo = await getCourseInfo(kkh, xnxq);
  
  // 获取课程所有节次统计
  const classStatistics = await getCourseClassAttendance(kkh, xnxq);
  
  // 计算汇总数据
  const totalClasses = classStatistics.length;
  const totalStudents = await getStudentCountByCourse(kkh, xnxq);
  
  let totalPunchRecords = 0;
  let totalLeaveRecords = 0;
  let totalAbsentRecords = 0;
  
  classStatistics.forEach(stat => {
    totalPunchRecords += stat.punched_count;
    totalLeaveRecords += stat.leave_count;
    totalAbsentRecords += stat.absent_count;
  });
  
  // 计算总出勤率
  const totalExpectedRecords = totalClasses * totalStudents;
  const attendanceRate = ((totalPunchRecords + totalLeaveRecords) / totalExpectedRecords) * 100;
  
  // 更新课程考勤汇总表
  await upsertCourseAttendanceSummary({
    kkh,
    xnxq,
    kcmc: courseInfo.kcmc,
    total_classes: totalClasses,
    total_students: totalStudents,
    total_punch_records: totalPunchRecords,
    total_leave_records: totalLeaveRecords,
    total_absent_records: totalAbsentRecords,
    attendance_rate: attendanceRate.toFixed(2)
  });
}
```

## 5. 数据关联与查询优化

### 5.1 考勤数据关联查询

为教师和学生提供考勤数据查询，基于开课号(kkh)关联各表：

```javascript
/**
 * 获取课程考勤详情
 * @param {string} kkh 开课号
 * @param {string} xnxq 学年学期
 * @returns {Object} 课程考勤详情
 */
async function getCourseAttendanceDetails(kkh, xnxq) {
  // 获取课程基本信息
  const courseInfo = await db.query(`
    SELECT kkh, kcmc, xnxq FROM kcb 
    WHERE kkh = ? AND xnxq = ? 
    GROUP BY kkh, kcmc, xnxq
  `, [kkh, xnxq]);
  
  // 获取课程考勤汇总
  const courseSummary = await db.query(`
    SELECT * FROM course_attendance_summary 
    WHERE kkh = ? AND xnxq = ?
  `, [kkh, xnxq]);
  
  // 获取课程节次考勤详情
  const classAttendance = await db.query(`
    SELECT * FROM course_class_attendance 
    WHERE kkh = ? AND xnxq = ? 
    ORDER BY jxz, zc, jc
  `, [kkh, xnxq]);
  
  // 获取学生详细考勤记录
  const studentAttendance = await db.query(`
    SELECT xh, 
           COUNT(CASE WHEN punch_status = 1 THEN 1 END) as punch_count,
           COUNT(CASE WHEN punch_status = 2 THEN 1 END) as leave_count,
           COUNT(CASE WHEN punch_status = 0 THEN 1 END) as absent_count
    FROM punch_record 
    WHERE kkh = ? AND xnxq = ?
    GROUP BY xh
  `, [kkh, xnxq]);
  
  return {
    courseInfo: courseInfo[0],
    courseSummary: courseSummary[0],
    classAttendance,
    studentAttendance
  };
}
```

### 5.2 查询性能优化

针对考勤查询的频繁需求，进行以下优化：

1. 添加复合索引优化查询性能
```sql
ALTER TABLE punch_record ADD INDEX idx_kkh_xnxq_rq (kkh, xnxq, rq);
ALTER TABLE course_class_attendance ADD INDEX idx_kkh_xnxq_jxz (kkh, xnxq, jxz);
```

2. 使用Redis缓存热门查询结果
```javascript
/**
 * 获取课程考勤详情（带缓存）
 */
async function getCourseAttendanceDetailsWithCache(kkh, xnxq) {
  const cacheKey = `course:attendance:${kkh}:${xnxq}`;
  
  // 尝试从缓存获取
  const cachedData = await redisClient.get(cacheKey);
  if (cachedData) {
    return JSON.parse(cachedData);
  }
  
  // 缓存未命中，从数据库查询
  const result = await getCourseAttendanceDetails(kkh, xnxq);
  
  // 设置缓存，过期时间30分钟
  await redisClient.setex(cacheKey, 1800, JSON.stringify(result));
  
  return result;
}
```

## 6. 前端界面设计补充

### 6.1 教师考勤查看界面

补充教师考勤查看界面，增加按课程维度查看考勤统计的功能：

1. **课程列表视图**
   - 显示教师所教授的所有课程
   - 每门课程展示：课程名称、开课号、总出勤率
   - 提供筛选、排序功能

2. **课程详情视图**
   - 课程基本信息展示
   - 课程考勤汇总数据（饼图展示打卡、请假、缺勤比例）
   - 按教学周、周次的考勤趋势图
   - 学生考勤排名列表

3. **单节课考勤详情**
   - 显示单节课的考勤情况
   - 分类展示：已打卡学生、已请假学生、缺勤学生
   - 提供手动修改考勤状态的功能

### 6.2 学生考勤统计界面

补充学生查看个人考勤统计的界面：

1. **课程考勤概览**
   - 显示学生所有课程的考勤情况
   - 每门课程显示：总出勤率、打卡次数、请假次数、缺勤次数

2. **单课程详情**
   - 课程基本信息
   - 按时间顺序展示历次课程的考勤记录
   - 考勤趋势图表

## 7. 定时任务设计

### 7.1 考勤统计任务

设计定时任务，自动更新考勤统计数据：

```javascript
/**
 * 每日考勤统计定时任务
 */
async function dailyAttendanceStatisticsTask() {
  try {
    // 获取昨日的所有课程
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = formatDate(yesterday);
    
    const yesterdayCourses = await db.query(`
      SELECT DISTINCT kkh, xnxq FROM kcb WHERE rq = ?
    `, [yesterdayStr]);
    
    // 为每门课更新考勤统计
    for (const course of yesterdayCourses) {
      await updateCourseAttendanceSummary(course.kkh, course.xnxq);
    }
    
    console.log(`Daily attendance statistics updated for ${yesterdayCourses.length} courses.`);
  } catch (error) {
    console.error('Error in daily attendance statistics task:', error);
  }
}

// 设置每日凌晨2点执行统计任务
schedule.scheduleJob('0 2 * * *', dailyAttendanceStatisticsTask);
```

## 8. API接口设计补充

### 8.1 新增考勤统计相关接口

```javascript
/**
 * 获取课程考勤统计
 * GET /api/v1/attendance/course/:kkh/:xnxq
 */
router.get('/course/:kkh/:xnxq', async (req, res) => {
  try {
    const { kkh, xnxq } = req.params;
    const result = await getCourseAttendanceDetailsWithCache(kkh, xnxq);
    res.json({ success: true, data: result });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * 获取学生在某课程的考勤详情
 * GET /api/v1/attendance/student/:xh/course/:kkh/:xnxq
 */
router.get('/student/:xh/course/:kkh/:xnxq', async (req, res) => {
  try {
    const { xh, kkh, xnxq } = req.params;
    const studentAttendance = await getStudentCourseAttendance(xh, kkh, xnxq);
    res.json({ success: true, data: studentAttendance });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * 获取教师教授的所有课程考勤统计
 * GET /api/v1/attendance/teacher/:ghs
 */
router.get('/teacher/:ghs', async (req, res) => {
  try {
    const { ghs } = req.params;
    const teacherCourses = await getTeacherCoursesAttendance(ghs);
    res.json({ success: true, data: teacherCourses });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});
```

## 9. 应对客户疑问的解决方案

### 9.1 关于打卡聚合表结构

问题：调课是否会影响聚合表的统计？

解决方案：
1. 打卡聚合表按周几和节次组织，确实可能受到调课影响
2. 引入课程节次考勤详情表(course_class_attendance)，按实际日期和节次记录考勤情况
3. 调课时更新相应的课程节次考勤详情记录
4. 通过定时统计任务重新计算课程整体的考勤数据

### 9.2 关于课表同步逻辑

问题：同步日志和同步策略不清晰

解决方案：
1. 增加详细的同步日志表，记录每次同步的状态和结果
2. 设置同步优先级：教师课表优先，学生课表次之
3. 提供同步状态查询接口，使校方能够监控同步情况
4. 实现按周同步策略，提前一周同步课表数据

### 9.3 关于连续课节打卡处理

问题：如何处理连续课节只需打卡一次的情况

解决方案：
1. 引入class_group字段和is_first_class_in_group标记
2. 识别连续课节组，只为组内第一节课生成打卡任务
3. 第一节课打卡后，自动处理同组内后续课节的考勤状态
4. 通过系统配置表设置上午、下午、晚上的课节划分，处理跨时段的课程 