# 服务层与仓储层代码开发规范 (Stratix)

## 1. 前言与适用范围

本文档旨在为基于 Stratix 框架的后端项目提供一套简洁、严谨且可执行的服务层（Service）与仓储层（Repository）开发规范。规范强制采用函数式编程（FP）范式，旨在提升代码的健壮性、可维护性与可测试性。所有使用 Stratix 框架的 Node.js 后端项目均需遵循此规范。

## 2. 分层与职责清单

严格遵循分层架构，确保职责边界清晰。

- **`Controllers`**:
  - **职责**: 解析 HTTP 请求、调用服务层、序列化响应。
  - **禁止**: 包含任何业务逻辑、直接访问数据库或仓储层（简单只读场景除外）。

- **`Service`**:
  - **职责**: 业务流程编排、领域逻辑校验、事务边界管理、跨仓储操作聚合、幂等与并发控制。
  - **禁止**: 直接访问数据库驱动（如 Kysely 实例）、处理 HTTP 协议细节。

- **`Repository`**:
  - **职责**: 数据持久化与访问（CRUD）、数据库查询构建、将底层数据结构映射为领域实体。
  - **禁止**: 包含业务逻辑、管理事务（事务上下文应由服务层注入）、触发数据库 Schema 变更。

### 调用路径

- **标准路径**: `Controller` -> `Service` -> `Repository`
- **例外路径 (仅限简单读/写)**: `Controller` -> `Repository`。此路径必须遵循与服务层相同的函数式返回约定（`Option`/`Either`）。

## 3. 仓储层规范 (Repository)

仓储层是数据访问的唯一出口，必须保证其行为的纯粹性与可预测性。

### 3.1. 基类继承与配置

所有仓储类 **必须** 继承自 `@stratix/database` 提供的 `BaseRepository`。

#### 3.1.1 类型参数与继承约束

```typescript
class XxxRepository extends BaseRepository<
  DB,
  'tableName',
  Entity,
  CreateEntity,
  UpdateEntity
> {
  protected readonly tableName = 'tableName';
  protected readonly logger: Logger;
  // ...
}
```

- **类型参数**:
  - `DB`: 数据库 Schema 类型（Kysely 类型）
  - `'tableName'`: 表名（字符串字面量）
  - `Entity`: 查询返回的实体类型（对应 `Selectable<DB['tableName']>`）
  - `CreateEntity`: 创建时的输入类型（对应 `Insertable<DB['tableName']>`）
  - `UpdateEntity`: 更新时的输入类型（对应 `Updateable<DB['tableName']>`）

- **必需属性**:
  - `tableName`: 表名，必须与数据库 Schema 中的表名一致
  - `logger`: Logger 实例，用于记录操作和错误

#### 3.1.2 构造函数与连接配置

```typescript
constructor(
  connectionOptions?: RepositoryConnectionOptions,
  autoTableCreation?: Partial<AutoTableCreationConfig>
) {
  super(connectionOptions, autoTableCreation);
}
```

**连接配置选项** (`RepositoryConnectionOptions`):

- 简单形式：`'default'` - 使用指定的连接名称进行读写
- 详细形式：
  ```typescript
  {
    readConnection?: string;      // 读连接名称，默认 'default'
    writeConnection?: string;     // 写连接名称，默认 'default'
    defaultConnection?: string;   // 默认连接名称，默认 'default'
    enableReadWriteSeparation?: boolean; // 是否启用读写分离，默认 false
  }
  ```

#### 3.1.3 自动建表配置

**默认配置**（严禁修改）:

- `enabled: false` - ❌ 禁用自动建表（强制）
- `forceRecreate: false` - ❌ 禁止强制重建表（危险操作）
- ✅ **所有 Schema 变更必须通过独立的迁移脚本执行**

```typescript
// ✅ 正确：使用默认配置
constructor() {
  super(); // 禁用自动建表
}

// ❌ 错误：不要这样做
constructor() {
  super(undefined, { enabled: true }); // 违反规范
}
```

### 3.2. 接口设计与返回类型

#### 3.2.1 标准方法与返回类型

BaseRepository 提供的标准方法及其返回类型：

| 方法              | 签名                          | 返回类型                                             | 说明               |
| ----------------- | ----------------------------- | ---------------------------------------------------- | ------------------ |
| `findById`        | `(id: string \| number)`      | `Promise<Maybe<T>>`                                  | 按主键查询单条记录 |
| `findOne`         | `(criteria: WhereExpression)` | `Promise<Maybe<T>>`                                  | 按条件查询单条记录 |
| `findMany`        | `(criteria?, options?)`       | `Promise<T[]>`                                       | 按条件查询多条记录 |
| `findAll`         | `(options?)`                  | `Promise<T[]>`                                       | 查询所有记录       |
| `create`          | `(data: CreateT)`             | `Promise<Either<DatabaseError, T>>`                  | 创建单条记录       |
| `createMany`      | `(data: CreateT[])`           | `Promise<Either<DatabaseError, T[]>>`                | 批量创建记录       |
| `update`          | `(id, data: UpdateT)`         | `Promise<Either<DatabaseError, T>>`                  | 更新单条记录       |
| `updateMany`      | `(criteria, data: UpdateT)`   | `Promise<Either<DatabaseError, number>>`             | 批量更新记录       |
| `delete`          | `(id)`                        | `Promise<Either<DatabaseError, T>>`                  | 删除单条记录       |
| `deleteMany`      | `(criteria)`                  | `Promise<Either<DatabaseError, number>>`             | 批量删除记录       |
| `count`           | `(criteria?)`                 | `Promise<number>`                                    | 统计记录数         |
| `exists`          | `(criteria)`                  | `Promise<boolean>`                                   | 检查记录是否存在   |
| `paginate`        | `(criteria?, pagination?)`    | `Promise<Either<DatabaseError, PaginatedResult<T>>>` | 分页查询           |
| `withTransaction` | `(fn)`                        | `Promise<Either<DatabaseError, R>>`                  | 事务包装           |

#### 3.2.2 返回类型说明

- **`Maybe<T>`**: 函数式容器，表示可能存在或不存在的值
  - 用于查询操作，因为查询可能无结果
  - 使用 `fromNullable()` 创建，使用 `isSome()` / `isNone()` 检查

- **`Either<DatabaseError, T>`**: 函数式容器，表示操作成功或失败
  - 用于命令操作（create, update, delete），因为这些操作可能失败
  - 使用 `isLeft()` / `isRight()` 检查，使用 `fold()` 处理结果

- **`DatabaseError`**: 数据库操作错误类型
  - 包含 `type` 和 `message` 字段
  - 由 `ErrorClassifier.classify()` 自动分类

#### 3.2.3 函数式工具使用

优先使用 `@stratix/utils/functional` 中的工具函数：

```typescript
import {
  pipe,
  fromNullable,
  tryCatchAsync,
  map,
  flatMap,
  chain,
  isLeft,
  isNone,
  eitherLeft,
  eitherRight
} from '@stratix/utils/functional';
```

- **`fromNullable(value)`**: 将可能为 null/undefined 的值转换为 `Maybe<T>`
- **`tryCatchAsync(fn, errorHandler)`**: 异步操作的错误捕获，返回 `Either<Error, T>`
- **`pipe(...fns)`**: 函数组合，从左到右执行
- **`map(fn)`**: 对容器内的值进行转换
- **`flatMap(fn)` / `chain(fn)`**: 对容器内的值进行异步转换

### 3.3. 查询与事务

#### 3.3.1 查询方法

- **Where 表达式**: 使用函数式的 `WhereExpression<DB, TB>` 构建查询条件

  ```typescript
  const criteria = (qb) =>
    qb.where('status', '=', 'active').where('age', '>', 18);
  const users = await userRepository.findMany(criteria);
  ```

- **查询选项**: 配置排序、分页等

  ```typescript
  const users = await userRepository.findMany(criteria, {
    orderBy: { field: 'created_at', direction: 'desc' },
    limit: 10,
    offset: 0
  });
  ```

- **查询助手**: 使用 `QueryHelpers` 简化常见模式

  ```typescript
  import { QueryHelpers } from '@stratix/database';

  // IN 查询
  await userRepository.findMany(QueryHelpers.whereIn('id', [1, 2, 3]));

  // 范围查询
  await userRepository.findMany(QueryHelpers.whereBetween('age', 18, 65));

  // 模糊查询
  await userRepository.findMany(QueryHelpers.whereLike('name', 'john'));

  // 组合条件
  await userRepository.findMany(
    QueryHelpers.and(
      QueryHelpers.whereIn('status', ['active', 'pending']),
      QueryHelpers.whereBetween('age', 18, 65)
    )
  );
  ```

#### 3.3.2 事务处理

- **事务发起**: 事务 **必须** 在服务层通过 `withTransaction` 方法启动
- **自动管理**: `withTransaction` 自动管理事务的开启、提交和回滚
  - 回调函数正常完成 → 事务自动提交
  - 回调函数抛出异常 → 事务自动回滚
  - 返回 `Either<DatabaseError, R>` 类型
- **错误处理**: 在事务中 **必须** 抛出异常来触发回滚，不能返回 `Either.Left`

  ```typescript
  const result = await userRepository.withTransaction(async (repo) => {
    const user = await repo.create({ name: 'John' });
    if (isLeft(user)) throw new Error(user.left.message); // ✅ 正确
    await repo.update(user.right.id, { status: 'active' });
    return user.right;
  });
  ```

#### 3.3.3 时间戳自动管理

BaseRepository 自动管理 `created_at` 和 `updated_at` 字段（STRING 类型）：

- 自动添加到表 Schema
- `create` 操作自动设置两个字段
- `update` 操作自动更新 `updated_at`
- ❌ 禁止在 Schema 中手动定义这两个字段

```typescript
// ❌ 错误
const schema = SchemaBuilder.create('users').addPrimaryKey().addTimestamps(); // 会抛出错误！

// ✅ 正确
const schema = SchemaBuilder.create('users')
  .addPrimaryKey()
  .addColumn('name', DataColumnType.STRING);
// created_at 和 updated_at 会自动添加
```

### 3.4. 仓储层代码骨架

#### 3.4.1 完整示例

```typescript
import {
  BaseRepository,
  SchemaBuilder,
  DataColumnType
} from '@stratix/database';
import type { Logger } from '@stratix/core';
import type { Maybe } from '@stratix/utils/functional';
import type { Selectable, Insertable, Updateable } from 'kysely';

// 1. 定义数据库 Schema 类型
interface Database {
  users: {
    id: number;
    name: string;
    email: string;
    status: 'active' | 'inactive';
    created_at: string;
    updated_at: string | null;
  };
}

// 2. 定义实体类型
type User = Selectable<Database['users']>;
type CreateUserInput = Insertable<Database['users']>;
type UpdateUserInput = Updateable<Database['users']>;

// 3. 实现 Repository
export default class UserRepository extends BaseRepository<
  Database,
  'users',
  User,
  CreateUserInput,
  UpdateUserInput
> {
  protected readonly tableName = 'users';
  protected readonly logger: Logger;

  constructor(protected readonly logger: Logger) {
    // 调用 super() 时不传递自动建表配置，使用默认值（禁用）
    super();
  }

  /**
   * 定义表 Schema（可选，用于自动建表）
   */
  protected tableSchema = SchemaBuilder.create('users')
    .addPrimaryKey('id')
    .addColumn('name', DataColumnType.STRING, { length: 255, nullable: false })
    .addColumn('email', DataColumnType.STRING, {
      length: 255,
      nullable: false,
      unique: true
    })
    .addColumn('status', DataColumnType.STRING, { length: 50, nullable: false })
    .addUniqueIndex('idx_email', ['email'])
    .build();

  /**
   * 按邮箱查找用户
   */
  public async findByEmail(email: string): Promise<Maybe<User>> {
    return this.findOne((qb) => qb.where('email', '=', email));
  }

  /**
   * 按状态查找用户列表
   */
  public async findByStatus(status: string) {
    return this.findMany((qb) => qb.where('status', '=', status), {
      orderBy: { field: 'created_at', direction: 'desc' }
    });
  }

  /**
   * 验证创建数据
   */
  protected validateCreateData(data: CreateUserInput) {
    // 可以在这里添加业务级别的验证
    return super.validateCreateData(data);
  }

  /**
   * 验证更新数据
   */
  protected validateUpdateData(data: UpdateUserInput) {
    // 可以在这里添加业务级别的验证
    return super.validateUpdateData(data);
  }
}
```

#### 3.4.2 Schema 定义指南

使用 `SchemaBuilder` 定义表结构：

```typescript
import { SchemaBuilder, DataColumnType } from '@stratix/database';

// 基础表定义
const schema = SchemaBuilder.create('users')
  // 主键
  .addPrimaryKey('id')

  // 普通字段
  .addColumn('name', DataColumnType.STRING, { length: 255, nullable: false })
  .addColumn('age', DataColumnType.INTEGER, { nullable: true })
  .addColumn('balance', DataColumnType.DECIMAL, {
    precision: 10,
    scale: 2,
    nullable: false
  })

  // 外键
  .addForeignKey('department_id', 'departments', 'id', 'CASCADE', 'CASCADE')

  // 索引
  .addIndex('idx_name', ['name'])
  .addUniqueIndex('idx_email', ['email'])

  // 表注释
  .setComment('用户表')

  .build();

// 注意：不要手动添加 created_at 和 updated_at，BaseRepository 会自动添加
```

**支持的字段类型** (`DataColumnType`):

- 数字：`INTEGER`, `BIGINT`, `SMALLINT`, `TINYINT`, `DECIMAL`, `FLOAT`, `DOUBLE`
- 字符串：`STRING`, `CHAR`, `TEXT`, `MEDIUMTEXT`, `LONGTEXT`
- 日期时间：`DATE`, `TIME`, `TIMESTAMP`, `DATETIME`
- 其他：`BOOLEAN`, `JSON`, `BLOB`, `BINARY`, `UUID`

#### 3.4.3 连接配置示例

```typescript
// 使用默认连接
export default class UserRepository extends BaseRepository<
  Database,
  'users',
  User
> {
  constructor(logger: Logger) {
    super(); // 使用默认连接 'default'
    this.logger = logger;
  }
}

// 使用指定连接
export default class UserRepository extends BaseRepository<
  Database,
  'users',
  User
> {
  constructor(logger: Logger) {
    super('replica'); // 使用 'replica' 连接
    this.logger = logger;
  }
}

// 使用读写分离
export default class UserRepository extends BaseRepository<
  Database,
  'users',
  User
> {
  constructor(logger: Logger) {
    super({
      readConnection: 'replica',
      writeConnection: 'primary',
      enableReadWriteSeparation: true
    });
    this.logger = logger;
  }
}
```

## 4. 服务层规范 (Service)

服务层是封装业务规则的核心，负责协调一个或多个仓储来完成一个完整的业务用例。

### 4.1. 职责与依赖注入

- **职责**: 编排、校验、事务、聚合。
- **依赖注入**: 服务应通过构造函数接收其依赖的仓储实例。

### 4.2. 事务控制

- **事务边界**: 事务的生命周期 **必须** 在服务层中控制
- **多表操作**: 多个 Repository 的操作需要在同一事务中时，使用 `withTransaction`
  - 所有 Repository 通过 AsyncLocalStorage 自动共享事务上下文
  - 不需要显式传递事务对象
- **错误处理**: 在事务中抛出异常触发回滚，返回 `Either<DatabaseError, R>`
  ```typescript
  const result = await userRepository.withTransaction(async (repo) => {
    const user = await repo.create(userData);
    if (isLeft(user)) throw new Error(user.left.message);
    return user.right;
  });
  if (isRight(result)) {
    // 事务成功
  } else {
    // 事务失败，已自动回滚
  }
  ```

### 4.3. 输入与输出

- **输入**: 方法入参 **必须** 是经过校验的 DTO (`Data Transfer Object`)。
- **输出**: 方法返回值 **必须** 是 `Promise<Either<AppError, ResultVO>>`，其中 `ResultVO` (`View Object`) 是为前端裁剪后的安全数据结构。

### 4.4. 服务层代码骨架

```typescript
import { isLeft, eitherLeft, eitherRight } from '@stratix/utils/functional';
import type { Either } from '@stratix/utils/functional';
import type { DatabaseError } from '@stratix/database';
import type { AppError } from '@stratix/core';
import { UserRepository } from '../repository/user.repository';

export default class UserService {
  constructor(private readonly userRepository: UserRepository) {}

  public async register(dto: RegisterDTO): Promise<Either<AppError, UserVO>> {
    // 1. 校验 DTO
    if (!isValidRegisterDTO(dto)) {
      return eitherLeft(toAppError('VALIDATION_FAILED', 'Invalid data'));
    }

    // 2. 检查重复
    const existing = await this.userRepository.findOne((qb) =>
      qb.where('email', '=', dto.email)
    );
    if (existing.isSome()) {
      return eitherLeft(toAppError('DUPLICATE_ACCOUNT', 'Email exists'));
    }

    // 3. 使用事务创建
    const result = await this.userRepository.withTransaction(async (repo) => {
      const user = await repo.create({ email: dto.email, name: dto.name });
      if (isLeft(user)) throw new Error(user.left.message);
      return user.right;
    });

    // 4. 处理结果
    if (isLeft(result)) {
      return eitherLeft(toAppError('USER_CREATE_FAILED', result.left.message));
    }

    return eitherRight(toUserVO(result.right));
  }
}

// 错误映射函数
function toAppError(code: string, message: string): AppError {
  return { code, message, meta: { timestamp: new Date().toISOString() } };
}
```

## 5. 高级特性

### 5.1 JSON 字段处理

BaseRepository 自动序列化对象字段为 JSON 字符串，查询时需手动解析：

```typescript
// 创建时自动序列化
await userRepository.create({
  name: 'John',
  metadata: { age: 30 } // 自动转换为 JSON 字符串
});

// 查询时手动解析
const user = await userRepository.findById(1);
if (user.isSome()) {
  const metadata = JSON.parse(user.value.metadata);
}
```

### 5.2 自定义验证

在 Repository 中覆盖验证方法添加业务级别的验证：

```typescript
protected validateCreateData(data: CreateUserInput) {
  const parentResult = super.validateCreateData(data);
  if (isLeft(parentResult)) return parentResult;

  if (data.email && !isValidEmail(data.email)) {
    return eitherLeft(ValidationError.create('Invalid email format', 'email', data.email));
  }
  return eitherRight(data);
}
```

### 5.3 日志与调试

BaseRepository 自动记录所有操作，敏感字段自动脱敏（password, token, secret 等）。

## 6. 控制器对接要点

- **职责单一**: 控制器只负责解析请求（`body`, `params`, `query`）并调用服务层方法。
- **禁止业务逻辑**: 严禁在控制器中编写任何业务判断、数据转换或错误处理逻辑。
- **响应处理**: 控制器接收服务层返回的 `Either` 对象，并使用 `fold` 方法将其转换为标准的成功或失败 HTTP 响应。
- **简单场景**: 在极简的只读场景下，控制器可直接调用仓储，但仍需遵循 `Option`/`Either` 和 `fold` 的处理模式。

## 7. 类型 / DTO / VO 规则

- **DTO (Data Transfer Object)**: 用于封装从外部（如 HTTP 请求体）传入的数据。**必须** 在服务层或控制器入口处使用 `class-validator` 或类似库进行严格校验。
- **VO (View Object)**: 用于封装向外部（如 HTTP 响应体）返回的数据。**必须** 只包含客户端需要的安全字段，严禁泄露密码、内部 ID 等敏感信息。
- **Entity**: 领域实体，与数据库表结构一一对应。**严禁** 将裸的 ORM/DB 实体直接返回给控制器。

## 8. 错误码与异常映射

- **`AppError`**: 项目中所有业务异常都应封装为 `AppError` 对象。
  - `code`: 大写蛇形风格的错误码 (e.g., `USER_NOT_FOUND`)。
  - `message`: 面向用户的错误信息。
  - `meta`: 可选的、用于调试的上下文信息（严禁包含敏感数据）。

- **`DatabaseError`**: Repository 返回的数据库错误类型
  - `type`: 错误类型（如 `UNIQUE_VIOLATION`, `FOREIGN_KEY_VIOLATION` 等）
  - `message`: 错误信息
  - 由 `ErrorClassifier.classify()` 自动分类

- **错误码清单 (最小集)**:
  - `VALIDATION_FAILED`: 输入数据校验失败。
  - `NOT_FOUND`: 资源不存在。
  - `DUPLICATE_RECORD`: 记录已存在（如用户名、邮箱重复）。
  - `PERMISSION_DENIED`: 无权执行操作。
  - `AUTHENTICATION_FAILED`: 认证失败。
  - `DATABASE_ERROR`: 通用数据库操作失败。
  - `USER_CREATE_FAILED`: 特定领域的创建失败。

## 9. 事务与并发控制指引

- **事务发起**: 事务 **必须** 在服务层通过 `repository.withTransaction()` 启动
- **自动管理**: 异常自动回滚，正常完成自动提交，无需手动控制
- **多表事务**: 多个 Repository 通过 AsyncLocalStorage 自动共享事务上下文
- **并发控制**: 需要锁定时使用数据库行级锁（如 `SELECT ... FOR UPDATE`），通过服务层事务确保原子性
- **详细指南**: 参考 `docs/跨表事务实现指南.md`

## 10. 测试建议与覆盖清单

- **仓储层测试**:
  - **类型**: 集成测试。
  - **策略**: 使用测试专用的数据库或内存数据库（如 `sqlite-in-memory`），验证每个仓储方法的 SQL 执行是否正确，返回数据是否符合预期。
- **服务层测试**:
  - **类型**: 单元测试。
  - **策略**: Mock (模拟) 所有依赖的仓储。验证服务层在不同输入下，业务逻辑、事务调用和错误处理是否正确。
- **测试用例清单**:
  - [ ] 成功路径（Happy Path）。
  - [ ] 输入校验失败分支。
  - [ ] 依赖的仓储方法返回 `None` 或 `Left` 的分支。
  - [ ] 事务成功提交的场景。
  - [ ] 业务异常导致事务回滚的场景。

## 11. 禁止事项清单

- ❌ 不继承 `BaseRepository`
- ❌ 开启自动建表 (`enabled: true`)
- ❌ 强制重建表 (`forceRecreate: true`)
- ❌ 手动定义 `created_at` 或 `updated_at` 字段
- ❌ 在 Repository 中手动拼接 SQL
- ❌ 在 Repository 中处理事务（应由服务层管理）
- ❌ 控制器内写业务逻辑
- ❌ 服务层直连数据库驱动（必须通过 Repository）
- ❌ 可变共享状态/隐藏副作用
- ❌ 返回裸 ORM 实体（必须映射为 VO）
- ❌ 模糊/隐式错误（必须使用 `AppError` 和 `Either`）
- ❌ 混淆 `Maybe<T>` 和 `Either<DatabaseError, T>`
- ❌ 忽视 `DatabaseError` 类型（需在服务层映射为 `AppError`）

## 12. 落地清单 (Pull Request Self-Checklist)

**仓储层**:

- [ ] 继承 `BaseRepository<DB, 'tableName', Entity, CreateEntity, UpdateEntity>`
- [ ] 定义 `protected readonly tableName` 和 `protected readonly logger`
- [ ] 未开启自动建表和强制重建
- [ ] 查询方法返回 `Promise<Maybe<T>>` 或 `Promise<T[]>`
- [ ] 命令方法返回 `Promise<Either<DatabaseError, T>>`
- [ ] 使用 `SchemaBuilder` 定义表结构
- [ ] 未手动定义 `created_at` 和 `updated_at`
- [ ] 使用 `WhereExpression` 和 `QueryHelpers`

**服务层**:

- [ ] 方法返回 `Promise<Either<AppError, VO>>`
- [ ] 通过构造函数注入仓储
- [ ] 多步写操作使用 `withTransaction()`
- [ ] 正确处理 `Either<DatabaseError, R>` 类型
- [ ] 将 `DatabaseError` 映射为 `AppError`
- [ ] 输入为校验的 DTO，输出为安全的 VO

**控制器**:

- [ ] 无业务逻辑，只解析请求和调用服务
- [ ] 正确处理服务层返回的 `Either` 结果

**测试**:

- [ ] 服务层单元测试（Mock 仓储）
- [ ] 仓储层集成测试（测试数据库）
- [ ] 覆盖成功和失败路径
- [ ] 验证事务提交和回滚

**类型**:

- [ ] 正确区分 `Maybe<T>` 和 `Either<DatabaseError, T>`
- [ ] 使用 `Selectable`, `Insertable`, `Updateable` 类型
